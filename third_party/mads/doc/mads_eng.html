<html>
<head>

<title>MAD-ASSEMBLER INSTRUCTIONS</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">

<BODY>

<style type="text/css">

.duzy {
	font-family: Tahoma, Verdana, Arial;
	font-size: 24px;
	color: #000000;
	background-position: left;
	font-weight: bold;
}

.tekst {
	font-family: Tahoma, Verdana, Arial;
	font-size: 11px;
	color: #000000;
	background-position: left;
}

.tekst-wiekszy {
	font-family: Tahoma, Verdana, Arial;
	font-size: 14px;
	color: #000000;
	background-position: left;
	font-weight: bold;
	border-bottom-width: 1px;
	border-bottom-style: solid;
	border-bottom-color: #666666;
}

.stopka {
	font-family: Tahoma, Verdana, Arial;
	font-size: 9px;
	color: #666666;
	text-decoration: none;
	background-position: center;}
 
.editors-note {
    font-family: Tahoma, Verdana, Arial, sans-serif;
    font-style: italic;
}
 
</style>


</head>

<CENTER>
<p class="duzy"><u>MAD-ASSEMBLER 1.9.5</u></p>
<p class="stopka">Tebe/Madteam (01.01.2013)
<p class="stopka">translated poorly to English by Phaeron using Google Translate (01.26.2013)

<HR>

<TABLE>
<TR><TD VALIGN=top>
<UL>

<tt>
<b><LI><A HREF="#wprow">Introduction</A></b>
<UL>

<LI><A HREF="#mads">Preface</A>
<LI><A HREF="#komp">Compilation</A>
<LI><A HREF="#roznice">Differences and similarities between XASM and MADS</A>
<UL>
<LI><A HREF="#podob">Similarities</A>
<LI><A HREF="#rozni">Differences and new features</A>
</UL>
</UL>

<br />

<b><LI><A HREF="#sposob">USAGE</A></b>
<UL>
<LI><A HREF="#switches">Assembler switches</A>
<LI><A HREF="#err">Error codes</A>
<LI><A HREF="#lst">.LST file structure</A>
<LI><A HREF="#lab">.LAB file structure</A>
<LI><A HREF="#plikh">.H file structure</A>
</UL>

<br />

<b><LI><A HREF="#sdx">SPARTADOS X</A></b>
<UL>
<LI><A HREF="#sdx_plik">SpartaDOS X and Atari DOS formats</A>
<LI><A HREF="#sparta">Programming SpartaDOS X</A>
</UL>

<br />

<b><LI><A HREF="#mnemo">MNEMONICS</A></b>
<UL>
<LI><A HREF="#8bit">6502</A>
<LI><A HREF="#8bit_ill">6502 (illegal)</A>
<LI><A HREF="#16bit">65816</A>
</UL>

<br />


<b><LI><A HREF="#det_cpu">CPU DETECTION</A></b>

<br />
<br />

<b><LI><A HREF="#banks">MEMORY BANKS</A></b>
<UL>
<LI><A HREF="#banks_wir">Virtual</A>
<LI><A HREF="#banks_spr">Hardware</A>
</UL>

<br />


<b><LI><A HREF="#_relok">RELOCATABLE CODE</A></b>
<UL>
<LI><A HREF="#_reloc">Block relocation</A>
<LI><A HREF="#labels_ext">External symbols</A>
<LI><A HREF="#labels_pub">Public symbols</A>
<LI><A HREF="#_link">Linking</A>
</UL>

<b><LI><A HREF="#types">TYPES</A></b>
<UL>
<b><LI><A HREF="#structs">STRUCTURES</A></b>
<UL>
<LI><A HREF="#struct">Declaring structured types</A>
<LI><A HREF="#struct_wy">Defining structured data</A>
</UL>
<b><LI><A HREF="#enums">ENUMERATIONS</A></b>
<UL>
<LI><A HREF="#enums">Declaring enumerated types</A>
<LI><A HREF="#enums">Defining enumerated data</A>
</UL>
</UL>

<br />


<b><LI><A HREF="#zmiany">HISTORY</A></b>
</UL>
</tt>

</TD>


<TD VALIGN=top>
<UL>
<tt>
<b><LI><A HREF="#syntax">SYNTAX</A></b>
<UL>
<LI><A HREF="#kom">Comments</A>
<LI><A HREF="#znak_p">Combining multiple lines into one line</A>
<LI><A HREF="#znak_d">Combining multiple mnemonics</A>

<b><LI><A HREF="#expres">Expressions</A></b>
<UL>
<LI><A HREF="#numbers">Numbers</A>
<LI><A HREF="#opers">Operators</A>
</UL>

<b><LI><A HREF="#labels">Labels</A></b>
<UL>
<li><a HREF="#labels_anm">Anonymous</a>
<LI><A HREF="#labels_lok">Local</A>
<LI><A HREF="#labels_glo">Global</A>
<LI><A HREF="#labels_set">Temporary</A>
<LI><A HREF="#labels_mae">MAE-style Locals</A>
</UL>

<b><LI><A HREF="#_opt">Assembly control</A></b>
<UL>
<LI><A HREF="#_opt">Changing assembly options</A>
<LI><A HREF="#warun">Conditional assembly</A>
<LI><A HREF="#_error">Stopping assembly</A>
<LI><A HREF="#zpage">Assembling into zero page</A>
</UL>

<b><LI><A HREF="#makrorozkazy">Macro commands</A></b>
<UL>

</UL>

<b><LI><A HREF="#pseudo">Pseudo commands</A></b>
<UL>
<LI><A HREF="#_blk">Defining SDX blocks</A><br>
<LI><A HREF="#_smb">Defining SDX symbols</A><br>
<LI><A HREF="#_dta">Defining data</A><br>
</UL>

<b><LI><A HREF="#dyrekt">Directives</A></b>
<UL>
<LI><A HREF="#_rept">Repetition (.REPT)</A><br>
<LI><A HREF="#_symbol">Defining SDX symbols (.SYMBOL)</A><br>
<LI><A HREF="#_segment">Defining segments (.SEGDEF)</A><br>
</UL>

<b><LI><A HREF="#dyrekt6502">6502 code generation directives</A></b>
<UL>
<LI><A HREF="#_while6502">Defining loops (#WHILE)</A><br>
<LI><A HREF="#_test6502">Defining conditionals (#IF)</A><br>
<LI><A HREF="#_cycle6502">#CYCLE</A><br>
</UL>

<b><LI><A HREF="#arrays">Arrays</A></b>
<UL>
<LI><A HREF="#array">Declaring arrays</A>
</UL>


<b><LI><A HREF="#macros">Macros</A></b>
<UL>
<LI><A HREF="#makra">Declaring macros</A>
<LI><A HREF="#makra_wy">Calling macros</A>
</UL>

<b><LI><A HREF="#procs">Procedures</A></b>
<UL>
<LI><A HREF="#proc">Declaring procedures</A>
<LI><A HREF="#proc_wy">Procedure calls</A>
<LI><A HREF="#para_od">Procedure parameters</A>
</UL>

<b><LI><A HREF="#locals">Local scopes</A></b>
<UL>
<LI><A HREF="#obszar_lok">Declaring local scopes</A>
</UL>

</UL>
</UL>
</TD></TR>
</TABLE>

</CENTER>

</tt>
<HR>


<tt>

<div align="justify">


<A NAME="wprow">
<p class="duzy">
INTRODUCTION
</p>


<A NAME="mads">
<u><tt><h2>Preface</h2></tt></u>
<p>
<tt>Mad-Assembler (MADS)</tt> is a <tt>32</tt> bit application, written in <tt>Delphi</tt>.
Most applications are written in <tt>C</tt>, so to be different I used <tt>Delphi 7.0 ;)</tt>.
</p>

<p>
<tt>MADS</tt> is oriented toward users of <tt>QA</tt>, <tt>XASM</tt>, and <tt>FA</tt>.
The syntax is borrowed from <tt>QA</tt>, some macro commands and syntax come from <tt>XASM</tt>,
and <tt>SpartaDOS X (SDX)</tt> syntax is inherited from <tt>FA</tt>. Additional characters are
allowed in label names. Also added are support for the <tt>65816 CPU</tt>, macros, procedures,
splitting across virtual memory banks, and nested label names.
</p>

<p>
The number of labels and macros are limited only by the memory in your <tt>PC</tt>. Specifically,
you can have <tt>2147483647</tt> <tt>(INTEGER)</tt> table entries. I'm sure this amount is
sufficient. :)
</p>

Arithmetic operations are done with values of type <tt>INT64</tt> (signed 64 bit), with the result
represented with a value of type <tt>CARDINAL</tt> (unsigned 32 bit).

<p>
A line can be up to <tt>65535</tt> bytes, which is also the length limit of a label name.
However, I have not had the opportunity to check labels as long as poems. :)
</p>

<p>
With the free compiler <b><tt>Free Pascal Compiler</tt></b>, it is possible to compile <tt>MADS</tt>
for other platforms, such as <tt>Linux, Mac, OS/2</tt>, etc. For more information on how to build,
see the chapter on <A HREF="#komp">Compilation</A>.
</p>

If your system can run a version of <tt>Free Pascal</tt>, you can use <tt>MADS</tt>.
<p></p>

<li><tt>XASM</tt> home page: <a href="http://atariarea.histeria.pl/x-asm/">http://atariarea.krap.pl/x-asm/</a>
<p></p>
<br />



<A NAME="komp">
<u><tt><h2>Compilation</h2></tt></u>
<p>
To compile <tt>MADS</tt> source, you can use the <tt>Delphi</tt> compiler, if
<tt>Delphi 7.0</tt> or later is installed.
</p>

<p>
Another, more multi-platform way is to use the compiler package from the <tt><b>Free Pascal
Compiler (FPC)</b></tt>, which can be downloaded from: <a href="http://www.freepascal.org/">http://www.freepascal.org/</a>
</p>

Run the installer, and select the folder in which you installed <tt>FP</tt>. It is important
not to use a directory name which contains <tt>'!'</tt> or other special characters, or
else you will not be able to compile any files, and it should probably not be a standard
path name. The command-line to start compilation could look like this (the case in the
parameter names is important):

<pre>
fpc -Mdelphi -v mads.pas

<li>-Mdelphi     compile in <tt>Delphi</tt> mode
<li>-v           show all errors and warnings
<li>-O3          enable code optimization
</pre>

Compared to the <tt>Delphi</tt> compiler, <tt>FPC</tt> generates bigger code,
but the speed of the compiled <tt>MADS</tt> is much faster, even by a few seconds.
The included <tt>MADS.EXE</tt> is compiled using <tt>FPC</tt>.

<p></p>
<br />



<A NAME="roznice">
<p class="duzy">
DIFFERENCES AND SIMILARITIES BETWEEN MADS AND XASM
</p>


<A NAME="podob">
<u><tt><h2>Similarities</h2></tt></u>

<li>the same syntax
<li>the same exit codes
<li>the same macro commands

<p></p>
<br />



<A NAME="rozni">
<u><tt><h2>Differences and new behaviors</h2></tt></u>

<li>small additions to <tt>ORG</tt>, e.g.. <tt>'ORG [[expression]]adres[,adres2]'</tt>
<li><tt>XASM</tt> does not like whitespace, <tt>MADS</tt> tolerates and accepts it in logical/arithmetic expressions and static/variable definitions
<li><tt>MADS</tt> allows expressions to be grouped with <tt>(), []</tt>, <tt>XASM</tt> only within <tt>[]</tt>
<li><tt>MADS</tt> provides static and variable definitions of local, global, and temporary scope, <tt>XASM</tt> only global
<li><tt>MADS</tt> does not accept <tt>ORG a:adres</tt> or <tt>ORG f:adres</tt>
<li><tt>MADS</tt> encodes real numbers using the directive <b>.FL</b> .FL real, XASM by pseudo-command <b>DTA R</b> <tt>DTA R(real)</tt>
<li><tt>MADS</tt> has expanded support in the pseudo-command <tt>INS</tt>
<li><tt>MADS</tt> does not accept the addressing form 'lda (203),0'
<li><tt>MADS</tt> allows writing programs for SpartaDOS X
<li><tt>MADS</tt> permits writing relocatable code in a custom format
<li>when encoding the value of a character, i.e.
<pre>
  lda #' '
  lda #" "
</pre>
</p>

<p>
<tt>MADS</tt> distinguishes between single quotes (<tt>ATASCII</tt> coding) and double
quotes (<tt>INTERNAL</tt> coding), whereas <tt>XASM</tt> treats both forms the same (<tt>ATASCII</tt> coding).
Of course, the quote types are treated the same in <tt>DTA</tt> by <tt>MADS</tt>.
</p>

<li>in indexed modes, a <tt>'+'</tt> or <tt>'-'</tt> sign increments or decrements the index register, e.g.
<pre>
 lda $2000,x+    -&gt;    lda $2000,x
                       inx
</pre>

<li>but if the <tt>'+'</tt> or <tt>'-'</tt> sign is used with a value, it change the value of the main operand instead
(this only works with absolute indexed addressing):
<pre>
 lda $2000,x+2   -&gt;    lda $2002,x
</pre>
<br />



<A NAME="sposob">
<p class="duzy">
USAGE
</p>

<A NAME="switches">
<u><tt><h2>Assembler switches</h2></tt></u>

<span style="color: #0000FF">
<pre>
Syntax: mads source [switches]

-b:address      Generate binary file at specific address
-c              Label case sensitivity
-d:label=value  Define a label
-f              CPU command at first column
-hc[:filename]  Header file for CC65
-hm[:filename]  Header file for MADS
-i:path         Additional include directories
-l[:filename]   Generate listing
-m:filename     File with macro definition
-o:filename     Set object file name
-p              Print fully qualified file names in listing and error messages
-s              Silent mode
-t[:filename]   List label table
-x              Exclude unreferenced procedures
-vu             Verify code inside unreferenced procedures
-u              Warn of unused labels
</pre>
</span>

<p>
The default filenames are:
</p>

<span style="color: #0000FF">
<tt>
<li>source.lst
<li>source.obx
<li>source.lab
<li>source.h
<li>source.hea
<li>source.mac
</tt>
</span>

<p>
If no extension is specified for the <tt><b>source</b></tt> file, <tt>MADS</tt> will default to
the extension <tt>.ASM</tt>.
</p>

Switches can be given in any order, preceded by <tt>'/'</tt> or <tt>'-'</tt>, and case does not matter.
Also, switches can be combined:

<span style="color: #0000FF">
<pre>
mads -lptd:label=value -d:label2=value source.asm
mads -l  -p  -t  source
mads source.asm  -lpt
mads.exe "%1" -ltpi:"d:\!atari\macro\"
mads -i:"c:\atari\macros\" -c source.asm  -lpt
</pre>
</span>

By default, after assembly <tt>MADS</tt> will save the output with the extension '.OBX',
which can be changed with a batch file:
<span style="color: #0000FF">
<pre>
mads "%1" -o:%~n1.xex
</pre>
</span>

More can be learned about the operators by doing "CALL /?" in Microsoft DOS.

</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-b:address</div>
<div align="justify">
Using the <b><tt>-b</tt></b> allows specification of a target address for a file that
does not specify an address itself (the <A HREF="#_org">ORG</A> psuedo-command specifies
an assembly address).
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-c</div>
<div align="justify">
The <b><tt>-c</tt></b> switch causes label, variable, and constant names to be treated as
case-sensitive. Assembler directives and <tt>6502/65816 CPU</tt> instructions are always recognized
regardless of case.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-d:label=value</div>
<div align="justify">
Use the <b><tt>-d</tt></b> switch to define a new label in <tt>MADS</tt> memory from
the command-line. This switch can be used multiple times in a single invocation of <tt>MADS</tt>,
which is useful when assembling from a batch file (<tt>BAT</tt>).
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-f</div>
<div align="justify">
Use <b><tt>-f</tt></b> to allow CPU instructions to be recognized in the first column instead of
just labels.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-hc[:filename]</div>
<div align="justify">
The switch <b><tt>-hc</tt></b> saves a header file for the <tt>CC65</tt> compiler.
It also lets you specify a new name for the file. The default extension for the <tt>CC65</tt>
header file is <tt>*.H</tt>.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-hm[:filename]</div>
<div align="justify">
The switch <b><tt>-hm</tt></b> saves a header file for <tt>MADS</tt>. It also lets you specify
a new name for the file. The default extension for the <tt>MADS</tt> is <tt>*.HEA</tt>.
Such a file contains information about the banks and values assigned to labels. Additionally,
the labels are grouped by their types: <tt>CONSTANTS, VARIABLES, PROCEDURES</tt>.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-i:path</div>
<div align="justify">
The <b><tt>-i</tt></b> switch is used to set the search path for <tt>ICL</tt> and <tt>INS</tt>.
This switch can be use multiple times in the same command line to <tt>MADS</tt>, i.e.:
<span style="color: #0000FF">
<pre>
 -i:"c:\program files" -i:c:\temp -i:"d:\atari project"
</pre>
</span>
<p></p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-l:filename</div>
<div align="justify">
The <b><tt>-l</tt></b> switch enables writing of a listing file. It also lets you specify a new name for the file.
</p>



</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-m:filename</div>
<div align="justify">
The <b><tt>-m</tt></b> switch specifies a file with macro definitions, which <tt>MADS</tt>
assembles before the main <tt>.ASM</tt> file.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-o:filename</div>
<div align="justify">
The <b><tt>-o</tt></b> switch specifies a new name for the
<tt>Atari DOS</tt> or <tt>SpartaDOS X</tt> executable file, which is created at the end of assembly.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-p</div>
<div align="justify">
The <b><tt>-p</tt></b> switch is useful in conjunction with Code Genie.
When an error occurs during assembly, <tt>MADS</tt> generated error messages will appear in the
Output Bar of Code Genie:
<span style="color: #0000FF">
<pre>
D:\!Delphi\Masm\test.asm (29) ERROR: Missing .PROC
</pre>
</span>
Now just double-click the message line, and the cursor in the editor will move to the line with the error.
<p></p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-s</div>
<div align="justify">
Use the <b><tt>-s</tt></b> switch to activate the so-called <tt>'Silent mode'</tt>, where no messages will be displayed,
only errors <tt>(ERROR)</tt> and warnings <tt>(WARNING)</tt>.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-t[:filename]</div>
<div align="justify">
The <b><tt>-t</tt></b> switch writes a file with referenced label definitions. It also lets you specify an
alternate name for the file.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-x</div>
<div align="justify">
<b><tt>-x</tt></b> skips assembly of unreferenced procedures defined with the <b>.PROC</b> directive.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-vu</div>
<div align="justify">
<b><tt>-vu</tt></b> enables verification of code inside procedures even if they are not emitted, usually used in conjunction with <b>-x</b>.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-u</div>
<div align="justify">
<b><tt>-u</tt></b> lists unreferenced labels in the program.
</p>

<br />




<A NAME="err">
<u><tt><h2>Exit codes</h2></tt></u>

<span style="color: #0000FF">
<pre>
3 = bad parameters, assembling not started
2 = error occured
0 = no errors
</pre>
</span>

Warnings do not change the value of the exit code.
<p></p>
<br />



<A NAME="lst">
<u><tt><h2>.LST file format</h2></tt></u>

<p>
The listing format is the same as <tt>XASM</tt>, except that the virtual memory bank
is added before the address (if the bank is &lt;&gt;0). For more on virtual banks, see <A HREF="#banks">Memory banks</A>.
</p>

<span style="color: #0000FF">
<pre>
     3
     4 = 01,9033		picture equ $9033
     5 = 01,00A0		scr1 equ $a0
     6
     7
     8 01,2000 EA		main nop
</pre>
</span>
<br />


<A NAME="lab">
<u><tt><h2>.LAB file format</h2></tt></u>

<p>
As with <tt>XASM</tt>, the <tt>*.LAB</tt> file stores information about labels in the program.
</p>

<u>There are three columns:</u>
<p>
<li>The first column is the virtual bank number assigned to the label (if &lt;&gt;0).
<li>The second column is the label value.
<li>The third column is the label name.
</p>

Virtual bank numbers with values &gt;= $FFF9 have special meanings:
<pre>
 $FFF9   label for parameter in procedure defined by .PROC
 $FFFA   label for array defined by .ARRAY
 $FFFB   label for structured data defined by the pseudo-command DTA STRUCT_LABEL
 $FFFC   label for SpartaDOS X symbol - SMB
 $FFFD   label for macro defined by .MACRO directive
 $FFFE   label for structure defined by .STRUCT directive
 $FFFF   label for procedure defined by .PROC directive
</pre>

<p>
<u>Characters with special meanings in label names:</u>
</p>
<p>
<li>label defined in a macro (with two colons) <tt>::</tt>
<li>a dot (<tt>'.'</tt>) separates the name of a scope (<tt>.MACRO, .PROC, .LOCAL, .STRUCT</tt>) from the field name in the scope
</p>

<p>
The numeric value after <tt>::</tt> is the number of the macro call.
</p>

<span style="color: #0000FF">
<pre>
Mad-Assembler v1.4.2beta by TeBe/Madteam
Label table:
00	0400	@STACK_ADDRESS
00	00FF	@STACK_POINTER
00	2000	MAIN
00	2019	LOOP
00	201C	LOOP::1
00	201C	LHEX
00	0080	LHEX.HLP
00	204C	LHEX.THEX
00	205C	HEX
00	205C	HEX.@GETPAR0.LOOP
00	2079	HEX.@GETPAR1.LOOP
</pre>
</span>
<br />


<A NAME="plikh">
<u><tt><h2>.H file format</h2></tt></u>

<p>
I'm not sure if the file is OK, but Eru wanted something so here it is. :)
It is useful for linking together <tt>ASM</tt> and <tt>CC65</tt>, or <tt>C</tt> ported to the Atari.
Its contents can look like this (example file <tt>TEST.ASM</tt>):
</p>

<span style="color: #0000FF">
<pre>
#ifndef _TEST_ASM_H_
#define _TEST_ASM_H_

#define TEST_CPU65816 0x200F
#define TEST_CPU6502 0x2017
#define TEST_TEXT6502 0x201F
#define TEST_TEXT65816 0x2024

#endif
</pre>
</span>
<br />


<A NAME="makrorozkazy">
<p class="duzy">
MACRO COMMANDS
</p>


<span style="color: #0000FF">
<pre>
 <A HREF="#_req">REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS</A>

 <A HREF="#_seq">SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS</A>

 <A HREF="#_jeq">JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS</A>

 <A HREF="#_add">ADD, SUB</A>

 <A HREF="#_adb">ADB, SBB</A>

 <A HREF="#_adw">ADW, SBW</A>

 <A HREF="#_phr">PHR, PLR</A>

 <A HREF="#_inw">INW, INL, IND, DEW, DEL, DED</A>

 <A HREF="#_mv">MVA, MVX, MVY</A>

 <A HREF="#_mw">MWA, MWX, MWY</A>

 <A HREF="#_cp">CPB, CPW, CPL, CPD</A>
</pre>
</span>

The purpose of macro commands is to save time when writing programs and to shorten listings. Macro
commands replace commonly used groups of instructions.

<p></p>


<A NAME="_req">
<p>
<u><tt><h3>REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS</h3></tt></u>
<p>
These macro commands are similar to the <tt>6502</tt> branch instructions <tt>BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS</tt>,
but branch to the previously assembled instruction ("repeat"):
</p>
<span style="color: #0000FF">
<pre>
   lda:cmp:req 20           ->      lda 20
                            -> wait cmp 20
                            ->      beq wait

   ldx #0                   ->      ldx #0 
   mva:rne $500,x $600,x+   -> loop lda $500,x
                            ->      sta $600,x
                            ->      inx
                            ->      bne loop
</pre> 
</span>
<br />


<A NAME="_seq">
<p>
<u><tt><h3>SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS</h3></tt></u>
<p>
These macro commands are similar to the <tt>6502</tt> branch instructions <tt>BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS</tt>, but
branch over the next assembled instruction ("skip"):
</p>
<span style="color: #0000FF">
<pre>
   lda #40         ->       lda #40
   add:sta  $80    ->       clc
   scc:inc  $81    ->       adc $80
                   ->       sta $80
                   ->       bcc skip
                   ->       inc $81
                   ->  skip
</pre> 
</span>
<br />


<A NAME="_jeq">
<p>
<u><tt><h3>JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS</h3></tt></u>
<p>
These macro commands are similar to the <tt>6502</tt> branch instructions <tt>BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS</tt>,
but can target the entire 64KB address space ("jump"):
</p>

<span style="color: #0000FF">
<pre>
 jne dest   ->  beq *+4
            ->  jmp dest
</pre> 
</span>

If the distance is short (in the range -128 ... +127), MADS uses a regular BEQ, BNE, BPL, BMI, BCC, BCS, BVC, or BVS branch instruction.
<br />


<A NAME="_add">
<p>
<u><tt><h3>ADD, SUB</h3></tt></u>
<p>
These macro commands add or subtract from the accumulator without including the carry flag.

<span style="color: #0000FF">
<pre>
  ADD -> CLC         SUB -> SEC
      -> ADC ...         -> SBC ...
</pre>
</span>
<p></p>
<br />


<A NAME="_adb">
<p>
<u><tt><h3>ADB, SBB</h3></tt></u>
<p>
These macro commands add or subtract a value from a byte location in memory and store it either back
or to another location.

<span style="color: #0000FF">
<pre>
  ADB SRC #$40 -> LDA SRC       ADB A B C  -> LDA A
               -> CLC                      -> CLC
               -> ADC #$40                 -> ADC B
               -> STA SRC                  -> STA C

  SBB SRC #$80 -> LDA SRC       SBB A B C  -> LDA A
               -> SEC                      -> SEC
               -> SBC #$80                 -> SBC B
               -> STA SRC                  -> STA C
</pre>
</span>
<p></p>
<br />


<A NAME="_adw">
<p>
<u><tt><h3>ADW, SBW</h3></tt></u>
<p>
These macro commands add or subtract a value from a word location in memory and store it either back
or to another location.
<span style="color: #0000FF">
<pre>
  ADW SRC #$40 -> CLC             ADW A B C  -> CLC
               -> LDA SRC                    -> LDA A
               -> ADC #$40                   -> ADC B
               -> STA SRC                    -> STA C
               -> SCC                        -> LDA A+1
               -> INC SRC+1                  -> ADC B+1
                                             -> STA C+1

  ADW SRC #$40 SRC -> CLC
                   -> LDA SRC
                   -> ADC #$40
                   -> STA SRC
                   -> LDA SRC+1
                   -> ADC #$00
                   -> STA SRC+1
                                             
  SBW SRC #$4080 -> SEC           SBW A B C  -> SEC
                 -> LDA SRC                  -> LDA A
                 -> SBC &lt;$4080               -> SBC B
                 -> STA SRC                  -> STA C
                 -> LDA SRC+1                -> LDA A+1
                 -> SBC &gt;$4080               -> SBC B+1
                 -> STA SRC+1                -> STA C+1 
</pre>
</span>
<p></p>
<br />


<A NAME="_phr">
<p>
<u><tt><h3>PHR, PLR</h3></tt></u>
<p>
These macros are similar to the <tt>6502</tt> mnemonics <tt>PHA</tt> and <tt>PLA</tt>, but push or
pop the A, X, and Y registers to and from the stack.

<span style="color: #0000FF">
<pre>
  PHR  -> PHA         PLR  -> PLA
       -> TXA              -> TAY
       -> PHA              -> PLA
       -> TYA              -> TAX
       -> PHA              -> PLA
</pre>
</span>
<p></p>
<br />


<A NAME="_inw">
<p>
<u><tt><h3>INW, INL, IND, DEW, DEL, DED</h3></tt></u>
<p>
The macro commands <b>INW</b>, <b>INL</b>, and <b>IND</b> increment 16-bit (word), 24-bit (long), and 32-bit (dword) memory locations.
<p></p>
The macro commands <b>DEW</b>, <b>DEL</b>, and <b>DED</b> decrement 16-bit (word), 24-bit (long), and 32-bit (dword) memory locations.
The accumulator is also changed after the decrement macro commands.
<span style="color: #0000FF">
<pre>
    inw dest  ->       inc dest    ->   inc dest
              ->       bne skip    ->   sne
              ->       inc dest+1  ->   inc dest+1
              ->  skip             ->

    dew dest  ->       lda dest    ->   lda dest
              ->       bne skip    ->   sne
              ->       dec dest+1  ->   dec dest+1
              ->  skip dec dest    ->   dec dest   
</pre>
</span>
<p></p>
<br />



<A NAME="_mv">
<p>
<u><tt><h3>MVA, MVX, MVY</h3></tt></u>
<p>
The macro commands <b>MVA</b>, <b>MVX</b>, <b>MVY</b> transfer bytes using the A, X, or Y registers, respectively.
<b>OPT R+</b> can potentially reduce the code size from these macros by removing redundant instructions.
<span style="color: #0000FF">
<pre>
    lda src    ->  mva src dst
    sta dst    ->

    ldy $10,x  ->  mvy $10,x $a0,x
    sty $a0,x  ->

    ldx #$10   ->  mvx #$10 dst
    stx dst    ->
</pre>
</span>
<p></p>
<br />


<A NAME="_mw">
<p>
<u><tt><h3>MWA, MWX, MWY</h3></tt></u>
<p>
The macro commands <b>MWA</b>, <b>MWX</b>, <b>MWY</b> transfer words using the A, X, or Y registers, respectively.
<b>OPT R+</b> can potentially reduce the code size from these macros by removing redundant instructions.
<span style="color: #0000FF">
<pre>
    ldx &lt;adr    ->  mwx #adr dst
    stx dst     ->
    ldx &gt;adr    ->
    stx dst+1   ->

    mwa #0 $80  ->  lda #0           mwy #$3040 $80  ->  ldy <$3040
                ->  sta $80                          ->  sty $80
                ->  sta $81                          ->  ldy >$3040
                                                     ->  sty $81

    mwa ($80),y $a000,x  ->  lda ($80),y
                         ->  sta $a000,x
                         ->  iny
                         ->  lda ($80),y
                         ->  sta $a001,x
</pre>
</span>
<p></p>
<br />


<A NAME="_cp">
<p>
<u><tt><h3>CPB, CPW, CPL, CPD</h3></tt></u>
<p>
The macro commands <b>CPB</b>, <b>CPW</b>, <b>CPL</b>, and <b>CPD</b> perform comparison of
byte, word (16-bit), long (24-bit), and dword (32-bit) values, respectively.
<span style="color: #0000FF">
<pre>
 cpw temp #$4080
 bcc skip

 cpd v0 v1
 beq skip
</pre>
</span>
<p></p>
<br />




<A NAME="pseudo">
<p class="duzy">
PSEUDOCOMMANDS
</p>


<span style="color: #0000FF">
<pre>
 <A HREF="#_ift">IFT</A> [.IF] expression
 <A HREF="#_ift">ELS</A> [.ELSE]
 <A HREF="#_ift">ELI</A> [.ELSEIF] expression
 <A HREF="#_ift">EIF</A> [.ENDIF]
 
 <A HREF="#_error">ERT</A> ERT 'string'["string"] | ERT expression

 label EQU expression
 label  =  expression

 label <A HREF="#_set">SET</A> expression
 
 label <A HREF="#labels_ext">EXT</A> type

 <A HREF="#_opt">OPT</A> [bcfhlmorst][+-]
 <A HREF="#_org">ORG</A> [[expression]]address[,address2]
 <A HREF="#_ins">INS</A> 'filename'["filename"][*][+-value][,+-ofset[,length]]
 <A HREF="#_icl">ICL</A> 'filename'["filename"]
 <A HREF="#_dta">DTA</A> [abfghltv](value1,value2...)[(value1,value2...)]
 DTA [cd]'string'["string"]
 RUN expression
 INI expression
 <A HREF="#_en">END</A> [.EN]

 <A HREF="#_sin">SIN</A> (centre,amp,size[,first,last])
 <A HREF="#_rnd">RND</A> (min,max,length)

 <A HREF="#_repeat">:repeat</A>

 <A HREF="#_blk">BLK</A> N[one] X
 <A HREF="#_blk">BLK</A> D[os] X
 <A HREF="#_blk">BLK</A> S[parta] X
 <A HREF="#_blk">BLK</A> R[eloc] M[ain]|E[xtended]
 <A HREF="#_blk">BLK</A> E[mpty] X M[ain]|E[xtended]
 <A HREF="#_blk">BLK</A> U[pdate] S[ymbols]
 <A HREF="#_blk">BLK</A> U[pdate] E[xternal]
 <A HREF="#_blk">BLK</A> U[pdate] A[dress]
 <A HREF="#_blk">BLK</A> U[pdate] N[ew] X 'string'

 label <A HREF="#_smb">SMB</A> 'string'

 <A HREF="#_nmb">NMB</A>
 <A HREF="#_rmb">RMB</A>
 <A HREF="#_lmb">LMB</A> #expression
</pre>
</span>


<p>
These are mostly the same, although there are some differences with quoted strings.
Both <tt>' '</tt> and <tt>" "</tt> are treated the same except in operands, where
<tt>''</tt> gives the ATASCII code of a character, and <tt>""</tt> gives the INTERNAL code.
</p>
<br />


<A NAME="_blk">
<p>
<u><tt><h3>BLK</h3></tt></u>
<pre>
 BLK N[one] X                    - set program counter to X without adding a header block

 BLK D[os] X                     - DOS block with header $FFFF or without header when
                                   the program counter is already set to X

 BLK S[parta] X                  - fixed address block with header $FFFA, set program counter to X

 BLK R[eloc] M[ain]|E[xtended]   - relocatable block in MAIN or EXTENDED memory

 BLK E[mpty] X M[ain]|E[xtended] - relocatable block reserving MAIN or EXTENDED memory
                                   <b>NOTE:</b> the program counter is immediately raised by X bytes

 BLK U[pdate] S[ymbols]          - update block for updating previous SPARTA or RELOC blocks with the
                                   addresses of SDX symbols

 BLK U[pdate] E[xternal]         - update block for updating addresses of external labels ($FFEE header)
                                   <b>NOTE:</b> does not apply to SpartaDOS X, as this is a MADS extension

 BLK U[pdate] A[dress]           - update block for addresses in RELOC blocks

 BLK U[pdate] N[ew] X 'string'   - block declaring a new symbol 'string' in a RELOC block
                                   with address X. If the symbol name is prefixed with @,
                                   the address is in main memory and can be invoked by
                                   command.com
</pre>
For more information on <tt>SpartaDOS X</tt> blocks, see <A HREF="#sdx">SpartaDOS X file format</A> and <A HREF="#sdx">Programming SpartaDOS X</A>.
<p></p>
<br />


<A NAME="_set">
<u><tt><h3>label SET expression</h3></tt></u>
<p>
The pseudo-command SET redefines a label, with similar effect as temporary labels that
begin with '?':

<span style="color: #0000FF">
<pre>
temp set 12

     lda #temp

temp set 23

     lda #temp
</pre>
</span>
<br />



<A NAME="_smb">
<u><tt><h3>label SMB 'string'</h3></tt></u>
<p>
Declares a label as a <tt>SDX</tt> symbol. The symbol name can have a maximum of 8 characters.
<b><tt>BLK UPDATE SYMBOLS</tt></b> will direct the assembler to generate the correct update block
for symbols. Example:
<span style="color: #0000FF">
<pre>
       pf  smb 'PRINTF'
           jsr pf
           ...
</pre>
</span>

will make the <tt>SDX</tt> system insert the correct address into the <b><tt>JSR</tt></b> instruction.
</p>

<b><tt>Note:</tt></b> This statement is not transitive, so the following example will cause errors
at compile time:
<span style="color: #0000FF">
<pre>
       cm  smb 'COMTAB'
       wp  equ cm-1       (b³±d !)

           sta wp
</pre>
</span>

Use this instead:
<span style="color: #0000FF">
<pre>
       cm  smb 'COMTAB'

           sta cm-1       (ok !)
</pre>
</span>
<p>
<b><tt>Note:</tt></b> use labels for all symbols and declare before usage for correct operation!
</p>
<br />



<A NAME="_repeat">
<p>
<u><tt><h3>:repeat</h3></tt></u>
<span style="color: #0000FF">
<pre>
Example: 
           :4 asl @
           :2 dta a(*)
           :256 dta #/8

ladr :4 dta l(line:1)
hadr :4 dta h(line:1)           
</pre>
</span>
A <tt>':'</tt> specifies the number of times to repeat the line <i>(in the case of a macro,
this specifies a macro parameter by number if it is in decimal)</i>. 
The repeat count should be in the range <tt>&lt;0..2147483647&gt;</tt>.
When repeating a line with ':repeat', it is possible to use the loop counter in the repeated
line using a hash sign ('#') or the parameter :1.
</p>

When attempting to use the character <tt>':'</tt> to repeat lines in a macro:
<span style="color: #0000FF">
<pre>
.macro test
 :2 lsr @
.endm
</pre>
</span>
The <tt>':'</tt> prefixed number in this case is interpreted as the <b>second macro parameter</b>.
To prevent this interpretation by <tt>MADS</tt>, add something after the <tt>':'</tt>
that does nothing, such as the plus sign (<tt>'+'</tt>).

<span style="color: #0000FF">
<pre>
.macro test
 :+2 lsr @
.endm
</pre>
</span>

<p>
Now, the <tt>':'</tt> is correctly interpreted as <b>:repeat</b>.
</p>
<br />


<A NAME="_opt">
<u><tt><h3>OPT</h3></tt></u>
The <tt><b>OPT</b></tt> pseudo-command allows options to be enabled or disabled during
assembly.
<pre>
 b+  enable bank sensitivity
 b-  disable bank sensitivity                                         (default)
 c+  use 65816 instruction set (16bit)
 c-  use 6502 instruction set (8bit)                                  (default)
 f+  emit file as a single block (useful for cartridges)
 f-  emit file as multiple blocks                                     (default)
 h+  write DOS executable file headers                                (default)
 h-  omit DOS executable file headers
 l+  enable writing to listing file (LST)
 l-  disable writing to listing file (LST)                            (default)
 m+  expand macros in listing
 m-  include only macro invocation in listing                         (default)
 o+  enable writing to object file (OBX)                              (default)
 o-  disable writing to object file (OBX)
 r+  enable optimization for MVA, MVX, MVY, MWA, MWX, MWY
 r-  disable optimization for MVA, MVX, MVY, MWA, MWX, MWY            (default)
 s+  print listing to screen
 s-  do not print listing to screen                                   (default)
 t+  enable SEP/REP tracking (65816 CPU)
 t-  disable SEP/REP tracking (65816 CPU)                             (default)
 ?+  labels beginning with '?' are local (MAE style)
 ?-  labels beginning with '?' are temporary                          (default)
<span style="color: #0000FF">
Example:
 
 OPT c+ c  - l  + s +
 OPT h-
 OPT o +
</pre>
</span>

<p>
All options controlled by <b><tt>OPT</tt></b> can be used anywhere in the listing, e.g. if it is
turned on at line 12 and off at line 20 then the listing will only contain lines 12 through 20.
</p>
<b><tt>OPT C+</tt></b> is required to use <tt>65816</tt> addressing modes.

<p>
If you use CodeGenie and <b><tt>'OPT S+'</tt></b>, the listing file is unnecessary as the listing is
printed in the lower pane (Output Bar).
</p>
<br />



<A NAME="_org">
<u><tt><h3>ORG</h3></tt></u>
The <tt><b>ORG</b></tt> pseudo-command sets a new assembly address and therefore a new position
for data in <tt>RAM</tt>.
<pre>
 adr                 assembles to ADR, setting the address in the header to ADR
 adr,adr2            assembles to ADR, setting the address in the header to ADR2
 [b($ff,$fe)]        write $FFFE header (will generate 2 bytes)
 [$ff,$fe],adr       write $FFFE header, setting the address in the header to ADR
 [$d0,$fe],adr,adr2  write $D0FE header, assemble at address ADR, set the address in the header to ADR2
 [a($FFFA)],adr      write SpartaDOS $FAFF header, set address in the header to ADR
<span style="color: #0000FF">
Example:

 opt h-
 ORG [a($ffff),d'atari',c'ble',20,30,40],adr,adr2
</pre>
</span>

<p>
Brackets <b><tt>[ ]</tt></b> are used to write a new header, which can be any length. Other
values following closing <tt>']'</tt>, separated by a comma, are the assembly address and the
address in the header.
</p>

Here is an example of a file with a single header, assembled at address $2000, with valid
block start and end addresses in the header.

<span style="color: #0000FF">
<pre>
Example:

 opt h-f+
 ORG [a(start), a(over-1)],$2000

start
 nop
 .ds 128
 nop
over
</pre>
</span>

<br />



<A NAME="_ins">
<u><tt><h3>INS 'filename'["filename"][*][+-value][,+-ofset[,length]]</h3></tt></u>
<p>
The <tt><b>INS</b></tt> pseudo-command allows inclusion of an external binary file. The included
file does not have to be in the same directory as the main file being assembled. Search paths for
the file can be configurated using the <tt><b>/i</b></tt> switch (see <A HREF="#switches">assembly switches</A>).
</p>

Additionally, you can perform the following operations on the binary data:
<pre>
*          invert bytes
+-VALUE    increase or decrease each byte by the value of the expression VALUE

+OFSET     skip OFSET bytes at the beginning of the file     (seek to OFSET)
-OFSET     read OFSET bytes at the end of the file           (seek to FileLength-OFSET)

LENGTH     read LENGTH bytes from the file
</pre>

If the <tt>LENGTH</tt> value is not specified, the default behavior is to read to the end.
<p></p>
<br />



<A NAME="_icl">
<u><tt><h3>ICL 'filename'["filename"]</h3></tt></u>
<p>
The pseudo-command <tt><b>ICL</b></tt> includes an additional source file in the assembly process.
The attached file does not have to be in the same directory as the main assembly file. Additional
paths are added to the MADS search path using the <tt><b>/i</b></tt> switch (see <A HREF="#switches">assembly switches</A>).
</p> 
<br />



<A NAME="_dta">
<u><tt><h3>DTA</h3></tt></u>
The pseudo-command <tt><b>DTA</b></tt> defines typed data. If the type is not specified, byte data is assumed (b).
<pre>
   b   byte data (8-bit)
   a   word data (16-bit)
   v   relocatable WORD data (16-bit)
   l   byte data (8-bit)
   h   byte data (8-bit)
   t   long data (24-bit)
   e   long data (24-bit)
   f   doubleword data (32-bit)
   g   doubleword data (32-bit) in reversed byte order (big-endian)
   c   ATASCII string, delimited by '' or ""; <b>*</b> at the end encodes inverse
       video, e.g. dta c'abecadlo'*
   d   INTERNAL string, delimited by '' or ""; <b>*</b> at the end encodes inverse
       video, e.g. dta d'abecadlo'*
<span style="color: #0000FF">
Example:

  dta 1 , 2, 4
  dta a ($2320 ,$4444)
  dta d'sasasa', 4,a ( 200 ), h($4000)
  dta  c  'file' , $9b
  dta c'invers'*
</pre>
</span>
<p></p>
<br />


<A NAME="_sin">
<u><tt><h3>SIN(centre,amp,size[,first,last])</h3></tt></u>
<pre>
where: 

centre     is a number which is added to every sine value 
amp        is the sine amplitude 
size       is the sine period 
first,last define range of values in the table. They are optional.
           Default are 0,size-1. 
<span style="color: #0000FF">
Example: dta a(sin(0,1000,256,0,63))
         defines table of 64 words representing a quarter of sine with
         amplitude of 1000.
</pre>
</span>
<br />



<A NAME="_rnd">
<p>
<u><tt><h3>RND(min,max,length)</h3></tt></u>
This pseudo-command generates <tt>LENGTH</tt> pseudorandom values in the range <tt>&lt;MIN..MAX&gt;</tt>.
<span style="color: #0000FF">
<pre>
Example: dta b(rnd(0,33,256))
</pre>
</span>
<br />


<A NAME="_ift">
<u><tt><h3>IFT, ELS, ELI, EIF</h3></tt></u>
<span style="color: #0000FF">
<pre>
 IFT [.IF] expression
 ELS [.ELSE]
 ELI [.ELSEIF] expression
 EIF [.ENDIF]
</pre>
</span>
<p>
These pseudo-commands and directives conditionally include lines based on the value of an expression.
</p>
<br />



<A NAME="dyrekt">
<p class="duzy">
DIRECTIVES
</p>

<span style="color: #0000FF">
<pre>
 <A HREF="#_align">.ALIGN</a> N[,fill]
 
 <A HREF="#arrays">.ARRAY</A> label index type [= default_value]
 <A HREF="#arrays">.ENDA, [.AEND]</A>

 <A HREF="#_def">.DEF</A> label [= expression]

 <A HREF="#enums">.ENUM</A> label
 <A HREF="#enums">.ENDE, [.EEND]</A>

 <A HREF="#_error">.ERROR</A> [ERT] 'string'["string"] lub .ERROR [ERT] expression

 <A HREF="#labels_ext">.EXTRN</A> label [,label2,...] type

 <A HREF="#warun">.IF</A> [IFT] expression
 <A HREF="#warun">.ELSE</A> [ELS]
 <A HREF="#warun">.ELSEIF</A> [ELI] expression
 <A HREF="#warun">.ENDIF</A> [EIF]

 <A HREF="#_ifdef">.IFDEF</A> label
 <A HREF="#_ifndef">.IFNDEF</A> label

 <A HREF="#locals">.LOCAL</A> label
 <A HREF="#locals">.ENDL, [.LEND]</A>

 <A HREF="#_link">.LINK</A> 'filename'
 
 <A HREF="#macros">.MACRO</A> label
 <A HREF="#macros">.ENDM, [.MEND]</A>
 <A HREF="#macros">:[%%]parameter</A>
 <A HREF="#macros">.EXITM</A> [.EXIT]

 <A HREF="#_nowarn">.NOWARN</A>

 <A HREF="#_print">.PRINT</A> [.ECHO] 'string1','string2'...,value1,value2,...

 <A HREF="#_pages">.PAGES</A> [expression]
 <A HREF="#_pages">.ENDPG, [.PGEND]</A> 

 <A HREF="#labels_pub">.PUBLIC, [.GLOBAL], [.GLOBL]</A> label [,label2,...]

 <A HREF="#procs">.PROC</A> label
 <A HREF="#procs">.ENDP, [.PEND]</A>
 <A HREF="#procs">.REG, .VAR</A>

 <A HREF="#_rept">.REPT</A> expression [,parameter1, parameter2, ...]
 <A HREF="#_rept">.ENDR, [.REND]</A>
 <A HREF="#_rept">.R</A>

 <A HREF="#_reloc">.RELOC</A> [.BYTE|.WORD]

 <A HREF="#structs">.STRUCT</A> label
 <A HREF="#structs">.ENDS, [.SEND]</A>

 <A HREF="#_symbol">.SYMBOL</a> label
 
 <A HREF="#_segment">.SEGDEF</a> label address length [bank]
 <A HREF="#_segment">.SEGMENT</a> label
 <A HREF="#_segment">.ENDSEG</a>
 
 <A HREF="#_using">.USING, [.USE]</A> proc_name, local_name

 <A HREF="#__var">.VAR</A> var1[=value],var2[=value]... (.BYTE|.WORD|.LONG|.DWORD)
 <A HREF="#__zpvar">.ZPVAR</A> var1, var2... (.BYTE|.WORD|.LONG|.DWORD)

 <A HREF="#__end">.END</A>

 <A HREF="#_en">.EN</A>

 <A HREF="#_byte">.BYTE</A>
 <A HREF="#_byte">.WORD</A>
 <A HREF="#_byte">.LONG</A>
 <A HREF="#_byte">.DWORD</A>

 <A HREF="#_or">.OR</A>
 <A HREF="#_or">.AND</A>
 <A HREF="#_or">.XOR</A>
 <A HREF="#_or">.NOT</A>

 <A HREF="#_lohi">.LO</A> (expression)
 <A HREF="#_lohi">.HI</A> (expression)

 <A HREF="#_db">.DB</A>
 <A HREF="#_dw">.DW</A>
 <A HREF="#_ds">.DS</A> expression

 <A HREF="#_by">.BY</A> [+byte] bytes and/or ASCII
 <A HREF="#_wo">.WO</A> words
 <A HREF="#_he">.HE</A> hex bytes
 <A HREF="#_sb">.SB</A> [+byte] bytes and/or ASCII
 <A HREF="#_cb">.CB</A> [+byte] bytes and/or ASCII
 <A HREF="#_fl">.FL</A> floating point numbers

 <A HREF="#_adr">.ADR</A> label
 <A HREF="#_len">.LEN</A> label

 <A HREF="#_get">.GET</A> [index] 'filename'["filename"][*][+-value][,+-ofset[,length]]
 <A HREF="#_put">.PUT</A> [index] = value
 <A HREF="#_sav">.SAV</A> [index] ['filename',] length
</pre>
</span>
<br />


<A NAME="_symbol">
<u><tt><h3>.SYMBOL label</h3></tt></u>
<p>
The directive .SYMBOL is equivalent to the pseudo-command SMB except that the symbol name does
not need to be specified, as it is implied to be <b>label</b>.
A .SYMBOL directive can be placed anywhere within a relocatable SDX block (BLK RELOC), unlike SMB.

<p>
Whenever there is a .SYMBOL directive, the following block update will be generated:
</p>

<span style="color: #0000FF">
<pre>
BLK UPDATE NEW LABEL 'LABEL'
</pre>
</span>

More on the declaration of SDX symbols is found in the section <A HREF="#_smb">Defining symbols with SMB</A>.
<p></p>
<br />


<A NAME="_align">
<p>
<u><tt><h3>.ALIGN N [,fill]</h3></tt></u>
The directive .ALIGN aligns the assembly address to the value N, using FILL as the memory preset value for
any needed fill. It is possible to align relocatable code provided that the FILL value is given.
<p>
The defaults are: N=$0100, FILL=0.
</p>


<span style="color: #0000FF">
<pre>
Example:

 .align

 .align $400
 
 .align $100,$ff
</pre>
</span>

<br />
<p></p>


<A NAME="_rept">
<p>
<u><tt><h3>.REPT expression [,parameter1, parameter2, ...]</h3></tt></u>
The directive <b><tt>REPT</tt></b> is the same as the <a href="#_repeat"><b>:repeat</b></a> syntax,
except that a block is repeated instead of a single line. The beginning of the block is defined 
with the <b><tt>.REPT</tt></b> directive, which is followed by a repeat count in the range
<b><tt>&lt;0..2147483647&gt;</tt></b> and then optional parameters. Unlike macro parameters, the
parameters to .REPT are always calculated first and the result is substituted immediately (this
feature can be used to define new labels). The parameters specified in the .REPT block are used
like parameters to a .MACRO block. A .REPT block is ended using the <b><tt>.ENDR</tt></b> directive,
before which there should be no label.
</p>

Additionally, within a <b>.REPT</b>...<b>.ENDR</b> block, the hash sign '#' (or directive <b>.R</b>)
gives the current value of the loop counter (like for <b>:repeat</b>).
<span style="color: #0000FF">
<pre>
Example:

 .rept 12, #*2, #*3        ; a .REPT block can be combined with :rept
 :+4 dta :1                ; :+4 to distinguish from repeat block parameter :4
 :+4 dta :2
 .endr

 .rept 9, #                ; define 9 labels label0..label8
label:1 mva #0 $d012+#
 .endr
</pre>
</span>
<br />


<A NAME="_pages">
<p>
<u><tt><h3>.PAGES [expression]</h3></tt></u>
The directive <tt><b>.PAGES</b></tt> specifies that a piece of code delimited by a <b>&lt;.PAGES .. .ENDPG&gt;</b> block
should fit within a number of memory pages (the default is 1). If the program code exceeds the given
number of memory pages, the error <tt><b>Page error at ????</b></tt> is generated.

<p></p>
These directives can help when we want part of the program to be within one memory page, or when
we write a program stored in an additional memory bank (64 pages of memory), such as:
<span style="color: #0000FF">
<pre>
Example:

 org $4000
 
 .pages $40
  ...
  ...
 .endpg
</pre>
</span>
<br />


<A NAME="_segment">
<u><tt><h3>.SEGDEF label address length [attrib] [bank]<br />
.SEGMENT label<br />
.ENDSEG
</h3></tt></u>
<p>
The directive .SEGDEF defines a new segment LABEL at address ADDRESS and with length LENGTH. Read/write attributes can be assigned
to the segment (R-read, W-write, RW-read/write), as well as a virtual bank number BANK (default=0).
</p>
<p>
The .SEGMENT directive begins writing of code and data to the code segment LABEL. Exceeding the preset length of the
segment produces error message <tt><b>Segment LABEL error at ADDRESS</b></tt>.
</p>
<p>

The directive .ENDSEG ends writing to the current segment and returns to the main program block.
</p>

<span style="color: #0000FF">
<pre>
Example:

	.segdef sdata adr0 $100
	.segdef test  adr1 $40

	org $2000

	nop

	.cb 'ALA'

	.segment sdata

	nop
	
	.endseg

	lda #0

	.segment test
	ldx #0
	clc

	dta c'ATARI'

	.endseg

adr0	.ds $100
adr1	.ds $40 
</pre>
</span>
<br />


<A NAME="__end">
<p>
<u><tt><h3>.END</h3></tt></u>
The directive <tt><b>.END</b></tt> can be used interchangeably with the directives <tt><b>.ENDP</b></tt>, <tt><b>.ENDM</b></tt>, <tt><b>.ENDS</b></tt>, <tt><b>.ENDA</b></tt>, <tt><b>.ENDL</b></tt>, <tt><b>.ENDR</b></tt>, <tt><b>.ENDPG</b></tt>, <tt><b>.ENDW</b></tt>,
and <tt><b>.ENDT</b></tt>.

<p></p>
<br />



<A NAME="__var">
<p>
<u><tt><h3>.VAR var1[=value1],var2[=value2]... (.BYTE|.WORD|.LONG|.DWORD) [=address]</h3></tt></u>

The directive <tt><b>.VAR</b></tt> is used to declare and initialize variables in the main program
block and in .PROC and .LOCAL blocks. MADS does not use the information in these variables in further
operations involving pseudo and macro commands. Acceptable types of variables are .BYTE, .WORD, .LONG,
and .DWORD, multiples of those types, and types declared by .STRUCT and .ENUM.
<span style="color: #0000FF">
<pre>
Example:

 .var a,b , c,d   .word          ; 4 variables of type .WORD
 .var a,b,f  :256 .byte          ; 3 variables each with a size of 256 bytes
 .var c=5,d=2,f=$123344 .dword   ; 3 .DWORD variables with values 5, 2, and $123344

 .var .byte i=1, j=3             ; 2 variables of type .BYTE with values 1, 3

 .var a,b,c,d .byte = $a000      ; 4 variables of type .BYTE with addresses $A000, $A001, $A002, $A003
 
 .var .byte a,b,c,d = $a0        ; 4 variables of type byte, with the last variable 'D' having address $A0
                                 ; !!! in this form it is not possible to determine the address of variables

  .proc name
  .var .word p1,p2,p3            ; declare three variable of type .WORD
  .endp

 .local
  .var a,b,c .byte
  lda a
  ldx b
  ldy c
 .endl

 .struct Point                   ; new structure of type POINT
 x .byte
 y .byte
 .ends

  .var a,b Point                 ; declare structured variables
  .var Point c,d                 ; equivalent to syntax 'label DTA POINT'
</pre>
</span>

Declared variables are physically allocated at the end of the block, as determined by the directives
.ENDP, .ENDL, or .END. The exception is that in a .PROC block, variables declared with .VAR are
always allocated in front of the .ENDP directive even if the .VAR statements are within nested
.LOCAL blocks.
<p></p>
<br />


<A NAME="__zpvar">
<p>
<u><tt><h3>.ZPVAR var1, var2... (.BYTE|.WORD|.LONG|.DWORD) [=address]</h3></tt></u>
The directive <tt><b>.ZPVAR</b></tt> is used to declare zero page variables in the main
program block and in .PROC and .LOCAL blocks. Attempting to assign to or initialize a variable
of this type will generate the warning message <b>Uninitialized variable</b>.
MADS does not use the information in these variables in further operations involving
pseudo and macro commands. Acceptable variable types are .BYTE, .WORD., .LONG, .DWORD,
multiples of those types, and types declared by .STRUCT and .ENUM:
<span style="color: #0000FF">
<pre>
Example:

 .zpvar a b c d  .word = $80    ; 4 variables of type .WORD starting at address $0080
 .zpvar i j .byte               ; two more byte variables starting at address $0080+8

 .zpvar .word a,b               ; 2 variables of type .WORD
                                ; !!! in this form it is not possible to determine the addresses of the variables

 .struct Point                  ; declare new structure POINT
 x .byte
 y .byte
 .ends

  .zpvar a,b Point              ; declare structured variables
  .zpvar Point c,d              ; equivalent to syntax 'label DTA POINT'                                
</pre>
</span>

The zero-page variable will be assigned addresses only at the end of the block in which it was declared, at
.ENDP, .ENDL, or .END. The exception is a .PROC block where variables declared with .ZPVAR are assigned
at the .ENDP directive even if variables are declared within nested .LOCAL blocks.

<p>
Using .ZPVAR with only an address will specify the first address to assign to the next variable (the
default address is $0080).
</p>
<span style="color: #0000FF">
<pre>
Example:

 .zpvar = $40                       
</pre>
</span>


<p>
The address is automatically incremented by MADS and the warning message <b>Access violations at address $xxxx</b>
is generated if addresses are repeated. In the case of a zero page overflow, the error <b>Value out of range</b> is generated.
</p>

<p></p>
<br />



<A NAME="_print">
<p>
<u><tt><h3>.PRINT [.ECHO]</h3></tt></u>
Prints on screen parameter values or string expressions delimited by <b><tt>' '</tt></b> or <b><tt>" "</tt></b> quotes:
</p>
<span style="color: #0000FF">
<pre>
Example:

 .print "End: ",*,'..',$8000-*
 .echo "End: ",*,'..',$8000-*
</pre>
</span>
<p class="editors-note">
(Editor's note: Values are printed out as hexadecimal with a $ prefix.)
</p>
<br />


<A NAME="_error">
<p></p>
<u><tt><h3>.ERROR</A> [ERT] 'string'["string"] | .ERROR [ERT] expression</h3></tt></u>

The directive <b><tt>.ERROR</tt></b> and pseudo-command <b><tt>ERT</tt></b> are equivalent and
stop assembly, displaying a message given as a parameter delimited by <b><tt>' '</tt></b> or <b><tt>" "</tt></b>.
If the parameter is a boolean expression, then assembly will stop when the expression is true (with <b><tt>User error</tt></b>):

<span style="color: #0000FF">
<pre>
Example:

 ert "halt"            ; ERROR: halt
 .error "halt"

 ert *>$7fff           ; ERROR: User error
 .error *>$7fff
</pre>
</span>

<br />



<A NAME="_byte">
<u><tt><h3>.BYTE, .WORD, .LONG, .DWORD</h3></tt></u>

These directives are used to determine the allowable types for parameters in a procedure
declaration. They can also be used in place of the pseudo command <b><tt>DTA</tt></b> for
data definition.

<span style="color: #0000FF">
<pre>
Example:

.proc test (.word tmp,a,b .byte value)

 .byte "atari",5,22
 .word 12,$FFFF
 .long $34518F
 .dword $11223344
</pre>
</span>
<br />



<A NAME="_db">
<p>
<u><tt><h3>.DB</h3></tt></u>
Define data of type <b><tt>BYTE</tt></b>. Equivalent to the pseudo command <b><tt>DTA B</tt></b> or the <b><tt>.BYTE</tt></b> directive.
<p></p>
<br />



<A NAME="_dw">
<p>
<u><tt><h3>.DW</h3></tt></u>
Define data of type <b><tt>WORD</tt></b>. Equivalent to the pseudo command <b><tt>DTA A</tt></b> or the <b><tt>.WORD</tt></b> directive.
<p></p>
<br />



<A NAME="_ds">
<p>
<u><tt><h3>.DS expression</h3></tt></u>
This directive has been adapted from <tt>MAC'65</tt> and reserves uninitialized memory. This
is equivalent to the pseudo command <tt><b>ORG *+expression</b></tt>. The .DS directive cannot
be used in relocatable code like ORG can.
</p>

<span style="color: #0000FF">
<pre>
purpose: reserves space for data without initializing then space to any particular value(s).

usage: [label] .DS expression

Using ".DS expression" is exactly equivalent of using "ORG *+expression". That is, the label
(if it is given) is set equal to the current value of the location counter. Then then value
of the expression is added to then location counter.

Example: BUFFERLEN .DS 1 ;reserve a single byte
         BUFFER   .DS 256  ;reserve 256 bytes
</pre>
</span>
<br />


<A NAME="_by">
<p>
<u><tt><h3>.BY [+byte] bytes and/or ASCII</h3></tt></u>
<span style="color: #0000FF">
<p>
Store byte values in memory. ASCII strings can be specified by enclosing the string in either single or double quotes.
</p>
If the first character of the operand field is a '+', then the following byte will be used as a constant and added to all remaining bytes of the instruction.
<pre>
Example:
      .BY +$80 1 10 $10 'Hello' $9B

will generate:
        81 8A 90 C8 E5 EC EC EF 1B
</pre>

Values in .BY statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</span>
<p></p>
<br />


<A NAME="_wo">
<p>
<u><tt><h3>.WO words</h3></tt></u>
<span style="color: #0000FF">
Stores words in memory. Multiple words can be entered.

<br />
<br />

Values in .WO statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.

</span>
<p></p>
<br />


<A NAME="_he">
<p>
<u><tt><h3>.HE hex bytes</h3></tt></u>
<span style="color: #0000FF">
Store hex bytes in memory. This is a convenient method to enter strings of hex bytes, since it does not require the use of the '$' character. The bytes are still separated by spaces however, which I feel makes a much more readable layout than the 'all run together' form of hex statement that some other assemblers use.
<p>
Example:
      .HE 0 55 AA FF
</p>

Values in .HE statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.

</span>
<p></p>
<br />


<A NAME="_sb">
<p>
<u><tt><h3>.SB [+byte] bytes and/or ASCII</h3></tt></u>
<span style="color: #0000FF">
This is in the same format as the .BY pseudo-op, except that it will convert all bytes into ATASCII screen codes before storing them. The ATASCII conversion is done before any constant is added with the '+' modifier.

<br />
<br />

Values in .SB statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</span>

<p></p>
<p></p>
<br />


<A NAME="_cb">
<p>
<u><tt><h3>.CB [+byte] bytes and/or ASCII</h3></tt></u>
<span style="color: #0000FF">
This is in the same format as the .BY pseudo-op, except that the last character on the line will be EOR'ed with $80.

<br />
<br />

Values in .CB statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</span>

<p></p>
<br />


<A NAME="_fl">
<p>
<u><tt><h3>.FL floating point numbers</h3></tt></u>
<span style="color: #0000FF">
Stores 6-byte BCD floating point numbers for use with the OS FP ROM routines.

<br />
<br />

Values in .FL statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</span>

<p></p>
<br />



<A NAME="_en">
<p>
<u><tt><h3>.EN</h3></tt></u>
The directive .EN is equivalent to the pseudo command END and ends assembly.
<p>
<span style="color: #0000FF">
This is an optional pseudo-op to mark the end of assembly. It can be placed before
the end of your source file to prevent a portion of it from being assembled.
</span>
</p>
<p></p>
<br />


<A NAME="_adr">
<p>
<u><tt><h3>.ADR label</h3></tt></u>
The directive .ADR returns the address of LABEL before the assembly address is changed (you
can put LABEL between parentheses or square brackets). For example:
<span style="color: #0000FF">
<pre>
 org $2000

.proc tb,$1000
tmp lda #0
.endp

 lda .adr tb.tmp  ; = $2000
 lda tb.tmp       ; = $1000
</pre>
</span>
<p></p>
<br />


<A NAME="_len">
<p>
<u><tt><h3>.LEN label</h3></tt></u>
The directive .LEN returns the length in bytes of a block declared with .PROC, .ARRAY, .LOCAL,
or .STRUCT. The label is the name of the .PROC, .ARRAY, .LOCAL, or .STRUCT block (the label
name can be within parentheses or square brackets):
<span style="color: #0000FF">
<pre>
label .array [255] .dword
      .enda

      dta a(.len label)   ; = $400

.proc wait
 lda:cmp:req 20
 rts
.endp

 dta .len wait    ; = 7
</pre>
</span>
<br />


<A NAME="_def">
<p></p>
<u><tt><h3>.DEF label [= expression]</h3></tt></u>

The directive .DEF is used to check for the presence of the <b><tt>LABEL</tt></b> definition or
to define it. If the label is defined it returns <tt><b>1</b></tt> or <b><tt>TRUE</tt></b>, otherwise
it returns <tt><b>0</b></tt> or <b><tt>FALSE</tt></b>. It is possible to put the name
LABEL between parentheses or square brackets:

<span style="color: #0000FF">
<pre>
 ift .not(.def label)
 .def label
 eif
</pre>
</span>

<span style="color: #0000FF">
This unary operator tests whether the following label has been defined yet, returning TRUE or FALSE as appropriate.

<p>
<b>CAUTION</b>: Defining a label AFTER the use of a .DEF which references it can be dangerous, particularly if the .DEF is used in a .IF directive.
</p>
</span>
<br />


<A NAME="_ifdef">
<p></p>
<u><tt><h3>.IFDEF label</h3></tt></u>
The directive .IFDEF is equivalent to <b>.IF .DEF LABEL</b>.
<span style="color: #0000FF">
<pre>
Example:

.ifdef label
       jsr proc1
.else
       jsr proc2
.endif
</pre>
</span>

<br />


<A NAME="_ifndef">
<p></p>
<u><tt><h3>.IFNDEF label</h3></tt></u>
The directive .IFNDEF is equivalent to <b>.IF .NOT .DEF LABEL</b>.
<span style="color: #0000FF">
<pre>
Example:

.ifndef label
      clc
.else
      sec
.endif
</pre>
</span>

In the following example, the .IFNDEF (.IF) block will be processed and the label defined
only when the block is first encountered. If there are any errors associated with their definition,
this will only be reported when a reference to one of them is attempted, resulting in the
error  <b>Undeclared label LABEL_NAME</b>.

<span style="color: #0000FF">
<pre>
 .ifndef label
 .def label
 lda #0               ; this will only be generated once and not be reassembled
 temp = 100           ; label TEMP is defined only once during assembly
 .endif
</pre>
</span>

<br />



<A NAME="_nowarn">
<p></p>
<u><tt><h3>.NOWARN</h3></tt></u>
The directive .NOWARN disables warning messages for the current line being assembled.

<span style="color: #0000FF">
<pre>
Example:

.nowarn .proc temp       ; warning not generated: 'Unreferenced procedure TEMP'
        .endp
</pre>
</span>

<br />



<A NAME="_using">
<p>
<u><tt><h3>.USING, [.USE]</h3></tt></u>
The directive .USING (.USE) allows an additional scope to be specified for label lookup.
.USING (.USE) is valid in the current namespace.

<span style="color: #0000FF">
<pre>
Example:

.local move

tmp    lda #0
hlp    sta $a000

.local move2

tmp2   ldx #0
hlp2   stx $b000

.endl

.endl

.local main

.use move.move2

       lda tmp2
 
.use move

       lda tmp

.endl
</pre>
</span>
<br />



<A NAME="_get">
<p>
<u><tt><h3>.GET [index] 'filename'... [.BYTE, .WORD, .LONG, .DWORD]</h3></tt></u>
This is equivalent to the pseudo command <b><tt>INS</tt></b> (similar syntax), except
that the file is loaded into memory instead of included in assembly. This directive
allows the specified file to be loaded into memory and for its bytes to be referred to
as a one-dimensional array.
</p>
<span style="color: #0000FF">
<pre>
Example:

 .get 'file'                    ; load the file into a MADS array
 .get [5] 'file'                ; load the file into an array starting at index 5

 .get 'file',0,3                ; load the file into an array of size 3

 lda #.get[7]                   ; load the value of element 7 of the file array
 adres = .get[2]+.get[3]&lt;&lt;8     ; use bytes 2 and 3 of the file array as an address
</pre>
</span>
With the help of the directives <tt>.GET, .PUT</tt> a module for <tt>Theta Music Composer (TMC)</tt>
can be read and relocated. The <tt>MADS</tt> makro in the directory <tt>../EXAMPLES/MSX/TMC_PLAYER/tmc_relocator.mac</tt>
accomplishes this.
<p></p>
The permitted range of values is <tt>INDEX = &lt;0..65535&gt;</tt>. The values read by <tt>.GET</tt> are of type <tt>BYTE</tt>.

<p></p>
<br />



<A NAME="_put">
<p>
<u><tt><h3>.PUT [index] = value</h3></tt></u>
The directive <tt>.PUT</tt> stores a value of type <tt>BYTE</tt> into a one-dimensional array in
<tt>MADS</tt> memory. This is the same array in which the directive <tt>.GET</tt> reads a file.
<p>
The permitted range of values is <tt>INDEX = &lt;0..65535&gt;</tt>.
</p>
<span style="color: #0000FF">
<pre>
Example:

 .put [5] = 12       ; store the value 12 into MADS memory at element 5
</pre>
</span>
<br />


<A NAME="_sav">
<p>
<u><tt><h3>.SAV [index] ['filename',] length</h3></tt></u>
The directive <tt>.SAV</tt> saves the buffer used by the directives <tt>.GET</tt> and <tt>.PUT</tt>
to an external file or inserts it into the current assembly output.
<span style="color: #0000FF">
<pre>
Example:

 .sav ?length            ; add elements [0..?length-1] to current assembly output
 .sav [200] 256          ; add elements  [200..200+256-1] to current assembly output
 .sav [6] 'filename',32  ; save elements [6..6+32-1] to file FILENAME
</pre>
</span>
The permitted range of values for <tt>INDEX = &lt;0..65535&gt;</tt>.
<p></p>
<br />


<A NAME="_or">
<p>
<u><tt><h3>.OR, .AND, .XOR, .NOT</h3></tt></u>
These directives are equivalent to the logical operators <tt>||</tt> <tt>(.OR)</tt>, <tt>&&</tt> <tt>(.AND)</tt>, <tt>^</tt> <tt>(.XOR)</tt>, <tt>!</tt> <tt>(.NOT)</tt>.
</p>
<br />


<A NAME="_lohi">
<p>
<u><tt><h3>.LO (expression), .HI (expression)</h3></tt></u>
These directives are equivalent to '&lt;' (low byte) and '&gt;' (high byte), respectively.
</p>
<br />


<A NAME="warun">
<u><tt><h3>.IF, .ELSE, .ELSEIF, .ENDIF</h3></tt></u>
<span style="color: #0000FF">
<pre>
 .IF     [IFT] expression
 .ELSE   [ELS]
 .ELSEIF [ELI] expression
 .ENDIF  [EIF]
</pre>
</span>
<p>
These directives and pseudo commands can be used interchangeably to conditionally assemble
portions of code:
</p>

<span style="color: #0000FF">
<pre>
Example:

 .IF .NOT .DEF label_name
   label_name = 1
 .ENDIF

 .IF [.NOT .DEF label_name] .AND [.NOT .DEF label_name2]
   label_name = 1
   label_name2 = 2
 .ENDIF
</pre>
</span>

<p>
In these examples the parentheses or square brackets are required as otherwise the parameter
to the first <tt>.DEF</tt> directive would be the label <b><tt>label_name.AND.NOT.DEFlabel_name2</tt></b> (spaces are ignored and periods are allowed in label names).
</p>
<br />



<A NAME="dyrekt6502">
<p class="duzy">
6502 CODE GENERATION DIRECTIVES
</p>

<span style="color: #0000FF">
<pre>
 <A HREF="#_test6502">#IF</A> type expression [.OR type expression] [.AND type expression]
 <A HREF="#_test6502">#ELSE</A>
 #END

 <A HREF="#_while6502">#WHILE</A> type expression [.OR type expression] [.AND type expression]
 #END

 <A HREF="#_cycle6502">#CYCLE #N</A>
 </pre>
</span>


<A NAME="_test6502">
<p>
<u><tt><h3>#IF type expression [.OR type expression] [.AND type expression]</h3></tt></u>
The #IF directive is somewhat equivalent to the IF statement of higher-level languages (C, Pascal).
<p>
The #IF, #ELSE, and #END directives produce 6502 machine code for an IF conditional
statement around the designated program block and can be nested. All types are
acceptable (.BYTE, .WORD, .LONG, and .DWORD). It is possible to combine terms
using the .AND and .OR directives, but it is impossible to control the order of evaluation
with parentheses.
</p>
</p>

The implementation of the #IF directive begins with the calculation of the value
that is a simple expression consisting of two operands and one operator (expression
can be combined using the .OR or .AND directives).
    <p>

If the expression is non-zero (TRUE), the program block within the #IF is executed,
terminated by a JMP instruction to the next instruction after #END if there is an
#ELSE block.
    </p>

If the expression is zero (FALSE), the code following #ELSE is executed. If there is no
#ELSE directive, then control is transferred to the next instruction after the #END
directive. Example:

<span style="color: #0000FF">
<pre>
#if .byte label>#10 .or .byte label<#5
#end

#if .byte label>#100

#else

 #if .byte label<#200
 #end
 
#end

#if .byte label>#100 .and .byte label<#200 .or .word lab=temp
#end

#if .byte @
#end
</pre>
</span>
<br />



<A NAME="_while6502">
<p>
<u><tt><h3>#WHILE type expression [.OR type expression] [.AND type expression]</h3></tt></u>
The #WHILE directive is equivalent to the WHILE statement in higher-level languages (C, Pascal).
<p>
The directives #WHILE and #END allow generation of 6502 machine code for a loop around
the given program block and can be nested. All types .BYTE, .WORD, .LONG, and .DWORD are
acceptable. Multiple terms can be connected with the .OR and .AND directives, but order
of evaluation cannot be controlled by parentheses.
    </p>
<p>
The sequence of operations in the expansion of the #WHILE statement is as follows:
<ul>
    <li>1. Calculate the value of the expression and check if it is equal to zero (FALSE).
        <ul>
            <li>if so, skip step 2;
            <li>if not (TRUE), go to step 2.
        </ul>
    <li>2. Execute the code block bounded by the #WHILE and #END directives, then go to step 1.
</ul>

<p>
If the first evaluation of the expression produces zero, the program block will never be
executed and control passes to the next statement after #END.
</p>
<span style="color: #0000FF">
<pre>
#while .byte label>#10 .or .byte label<#5
#end

#while .byte label>#100
 #while .byte label2<#200
 #end
#end

#while .byte label>#100 .and .byte label<#200 .or .word lab=temp
#end
</pre>
</span>
<br />


<A NAME="_cycle6502">
<p>
<u><tt><h3>#CYCLE #N</h3></tt></u>
<p>
The directive #CYCLE generates code to take a given number of cycles. The generated code does not
modify any memory or any general purpose register.
</p>

<span style="color: #0000FF">
<pre>
#cycle #17  ; pha      3 cycle
            ; pla      4 cycle
            ; pha      3 cycle
            ; pla      4 cycle
            ; cmp $00  3 cycle
                      ---------
                      17 cycle
</pre>
</span>
<br />



<A NAME="zpage">
<u><tt><h2>Assembling into zero page</h2></tt></u>

<p>
Unlike two-pass assemblers like <tt>QA</tt> and <tt>XASM</tt>, <tt>MADS</tt>
is a multi-pass assembler. Why?
</p>

Take this example:

<span style="color: #0000FF">
<pre>
 org $00
 
 lda tmp+1
 
tmp lda #$00
</pre>
</span>

A two-pass assembler does not know the value of the <tt>TMP</tt> label and will assume that it is
16-bit (<tt>WORD</tt> type) and generate <tt>LDA abs</tt>.

<p>
However, <tt>MADS</tt> nicely generates <tt>LDA zp</tt>. This is the simplest benefit of multiple passes.
</p>

Now, suppose referring to zero page with <tt>LDA abs</tt> is required. No problem, just extend the
mnemonic:

<span style="color: #0000FF">
<pre>
 org $00
 
 lda.w tmp+1
 
tmp lda #$00
</pre>
</span>

Three mnemonic extensions are allowed:
<pre>
 <b>.b</b>[<b>.z</b>]
 <b>.w</b>[<b>.a</b>][<b>.q</b>]
 <b>.l</b>[<b>.t</b>]
</pre>
meaning <tt>BYTE</tt>, <tt>WORD</tt>, and <tt>LONG</tt> <tt>(TRIPLE)</tt>. The last one generates a
24-bit value for 65816 long addressing (seldom used). For more information <tt>6502</tt> and <tt>65816</tt>
CPU mnemonics, see <A HREF="#mnemo">Mnemonics</A>.

<p>
Another way to force zero page addressing is to use curly braces <tt>{ }</tt>:
</p>

<span style="color: #0000FF">
<pre>
 dta {lda $00},$80    ; lda $80
</pre>
</span>

Either will work with <tt>MADS</tt>, but the last pass will do the trick for us. :) The next problem is
putting this code on your computer. Loading directly into page zero will probably work if the
target area is within <tt>$80..$FF</tt>, but below that the <tt>OS</tt> is unlikely to survive.

<p>
Therefore, <tt>MADS</tt> allows the following:
</p>

<span style="color: #0000FF">
<pre>
 org $20,$3080
 
 lda tmp+1
 
tmp lda #$00
</pre>
</span>

This assembles at address <tt>$0020</tt>, but with a load address of <tt>$3080</tt>. Of course, moving
the code to the correct address (<tt>$0020</tt> in our example) is now the responsibility of the programmer.

<p>
In summary:
</p>

<span style="color: #0000FF">
<pre>
 org adres1,adres2
</pre>
</span>

<p>
Assembles at <tt><b>adres1</b></tt>, but loads to address <tt><b>adres2</b></tt>. The <tt><b>ORG</b></tt>
will always create a new block in the file, which adds an additional four bytes for the header of
the new block.
</p>

If it is OK for the new address of the data in memory to be the current address, then
the property of .LOCAL and .PROC blocks can be used to avoid writing a new header:

<span style="color: #0000FF">
<pre>
     1
     2 					org $2000
     3
     4 FFFF> 2000-200D> A9 00		lda #0
     5 2002 EA				nop
     6
     7 0060			.local	temp, $60
     8
     9 0060 BD FF FF			lda $ffff,x
    10 0063 BE FF FF			ldx $ffff,y
    11
    12 				.endl
    13
    14 2009 A5 60			lda temp
    15 200B AD 03 20			lda .adr temp
    16
</pre>
</span>

In this example the block <b>TEMP</b> will assemble with the new address <b>= $60</b>
and be placed in memory at address <b>$2003</b>. After the block end directive (.ENDL, .ENDP, .END),
assembly will resume at the previous assembly address plus the length of the block,
which in this case is  <b>$2009</b>.

<p>
The directives .ADR and .LEN can then be used to copy the block to the correct address:
</p>

<span style="color: #0000FF">
<pre>
      ldy #0
copy  mva .adr(temp),y temp,y+
      cpy #.len temp
      bne copy
</pre>
</span>

For more information on the directives, see <a href="#_ADR">.ADR</a> and <a href="#_LEN">.LEN</a>.

<p></p>
<br />


<A NAME="types">
<p class="duzy">
TYPES
<p>
MADS allows the declaration of two types of data: structured (.STRUCT), and enumerated (.ENUM).

</p>


<A NAME="structs">
<p class="duzy">
STRUCTURED TYPES, STRUCTURES
</p>


If you have programmed in <b><tt>C</tt></b>, you have probably already encountered structures.
Overall, a <tt>MADS</tt> structure defines an array of virtual, one-dimensional fields
of varying <b><tt>.BYTE</tt></b>, <b><tt>.WORD</tt></b>, <b><tt>.LONG</tt></b>, or <b><tt>.DWORD</tt></b>
types or multiples thereof. They are virtual because they exist only in memory during assembly.

<p>
The fields of the structure contain information about offsets from the beginning of the structure.
</p>
<br />



<A NAME="struct">
<u><tt><h2>Declaring structures (<b>.STRUCT</b>)</h2></tt></u>

<p>
Structure declaration directives:
</p>
<span style="color: #0000FF">
<pre>
name .STRUCT
     .STRUCT name
     .ENDS [.SEND] [.END]
</pre>
</span>

<u><tt><h3>name .STRUCT</h3></tt></u>

Declares a structure with the name <tt><b>name</b></tt> preceding the <tt><b>.STRUCT</b></tt> directive.
The name of the structure is required and an error is generated if it is missing.
Structures cannot be named with mnemonic or psuedo-instruction names. If the name
is reserved, a <b><tt>Reserved word</tt></b> error is reported.

<p></p>
<u>Example of structure declaration:</u>

<span style="color: #0000FF">
<pre>
.STRUCT name

  x .word      ; lda #name.x = 0
  y .word      ; lda #name.y = 2
  z .long      ; lda #name.z = 4
  v .dword     ; lda #name.v = 7

  q :3 .byte   ; lda #name.q = 11

.ENDS          ; lda #name   = 14 (length)
</pre>
</span>

Each line defines a field by name and type (.BYTE, .WORD, .LONG, or .DWORD). The
field name may be preceded by whitespace. Between the .STRUCT and .ENDS directives,
CPU mnemonics may not be used. Attempting to do so or having other invalid
characters will result in a <b>Improper syntax</b> or <b>Illegal instruction</b>
error.
<p>
In summary, the label <b><tt>name</tt></b> contains information about the total length
of the structure (in bytes). The other labels describing the fields contain information
about the offsets to each field from the beginning of the structure.
</p>

Structure declarations cannot be nested, but previously declared structures can be nested
in other ones (declaration order does not matter). For example:

<span style="color: #0000FF">
<pre>
.STRUCT temp

x .word
y .word
v .byte
z .word

.ENDS


.STRUCT test

tmp  temp

.ENDS

 lda #temp.v
 lda #test.tmp.x
 lda #test.tmp.z
</pre>
</span>

What are structures useful for?

<p></p>

Suppose you have a table of different types, where you can read each table field with
a predetermined offset value. If a field is added to the table, or the table is modified
in any other way, the program code will have to be updated to use new field offsets.
Defining the table using a structure means that offsets can be determined by the structure
definition, which are then automatically updated even if the structure of the table is
changed.

<p>
Another example of structure usage can be found in the section on <a href="#labels_ext">External symbols</a>, <a href="#_prz_str">Using external symbols with structures (.STRUCT)</a>.
</p>

<p></p>
<br />




<A NAME="struct_wy">
<u><tt><h2>Defining structured data, references</h2></tt></u>
<p>
Structured data can be defined by assigning a new label with the pseudo-command DTA and
a specific structure name, or just with the structure name without the pseudo-command.
The result is that the virtual structure definition is turned into actual reserved memory.
</p>

<span style="color: #0000FF">
<pre>
label DTA struct_name [count] (data1,data2,data3...) (data1,data2,data3...) ...

label struct_name
</pre>
</span>

<p>
<tt><b>COUNT</b></tt> specifies a number in the range <tt>&lt;0..COUNT&gt;</tt>,
which defines the maximum element index in a one-dimensional array and thus the amount
of memory reserved.
</p>

Examples of structure and structured data declarations:

<span style="color: #0000FF">
<pre>
;-----------------------;
; structure declaration ;
;-----------------------;
.STRUCT temp

x .word
y .word
v .byte
z .word

.ENDS

;---------------;
; defining data ;
;---------------;

data dta temp [12] (1,20,200,32000) (19,2,122,42700)

data2 dta temp [0]

data3 temp          // shorter equivalent to DATA2
</pre>
</span>

The value in square brackets must be a value between <b><tt>&lt;..2147483647&gt;</tt></b>,
which defines the maximum value of a one-dimensional array index and thus the amount of memory
reserved for the structured data.

<p>
After the square brackets an optional list of initializer values (in parentheses) may follow.
Otherwise, the field values default to zero. However, if the initializer list is shorter than
the number of declared fields, the remaining fields are initialized to the previous value
given for those fields:
</p>

<span style="color: #0000FF">
<pre>
data dta temp [12] (1,20,200,32000)
</pre>
</span>

Such a declaration will result in all fields being initialized to the values <tt>1,20,200,32000</tt>,
not just the first element <tt>data[0]</tt>.


<p>
If the list of initializers is longer than the number of elements, the error <b><tt>Constant
expression violates subrange bounds</tt></b> will result.
</p>

To refer to fields in the structured data, use its name, followed by an index in square
brackets and the field name after a dot:
<span style="color: #0000FF">
<pre>
 lda data[4].y
 ldx #data[0].v
</pre>
</span>

<p>

Forgetting the brackets with an index in the syntax <b>label[index]</b> results in the error <b><tt>Undeclared label</tt></b>.
</p>
<br />


<A NAME="enums">
<p class="duzy">
ENUMERATED TYPES, ENUMERATION
</p>

<p>
These directives are used with enumerations:
</p>
<span style="color: #0000FF">
<pre>
name .ENUM
     .ENDE [.EEND] [.END]

Example:

.enum portb
 rom_off = $fe
 rom_on = $ff
.ende

.enum test
 a             ; a=0
 b             ; b=1
 c = 5         ; c=5
 d             ; d=6
.ende
</pre>
</span>
<p>
Enumerations are declared using the directives <b>.ENUM</b> and <b>.ENDE</b>.
The name of the enumeration is required and an error will be generated otherwise.
Enumeration names may not be the same as mnemonics or pseudo-commands, which will
produce a <b>Reserved word</b> error.
</p>

The label values are automatically assigned starting with a default value of 0
and incrementing by 1. You can define the value of each label directly or
have them be automatically set.
<p>
Enumerated labels are referenced using this syntax:
</p>

<span style="color: #0000FF">
<pre>
 enum_name (field)
</pre>
</span>

or directly like with .LOCAL and .PROC blocks, with a dot between the enumeration
name and the field name:

<span style="color: #0000FF">
<pre>
 lda #portb(rom_off)

 dta portb.rom_on, portb.rom_off
</pre>
</span>

Enumerations can be used for field declarations in structures (.STRUCT) and variable declarations (.VAR):

<span style="color: #0000FF">
<pre>
bank portb           // allocate variable BANK of size 1 byte
.var bank portb      // allocate variable BANK of size 1 byte

.struct test
 a portb
 b portb
.ends
</pre>
</span>

The size of an enumeration is dependent upon the maximum value of its labels:
<span style="color: #0000FF">
<pre>
    .enum EState
        DONE, DIRECTORY_SEARCH=$ff, INIT_LOADING, LOADING
    .ende
</pre>
</span>

In this example, the enumeration "EState" will have a size of two bytes (WORD).

<p>
The size of an enumeration can be checked with the .LEN directive (equivalent to SIZEOF),
where the result will be a value in the range 1..4 (1=BYTE, 2=WORD, 3=LONG, 4=DWORD):
</p>

<span style="color: #0000FF">
<pre>
 .print .len EState
</pre>
</span>

<p></p>
<br />


<A NAME="arrays">
<p class="duzy">
ARRAYS
</p>


<A NAME="array">
<u><tt><h2>Declaring dimensional arrays (<b>.ARRAY</b>)</h2></tt></u>

Directives for arrays:
</p>
<span style="color: #0000FF">
<pre>
name .ARRAY index type [= default_value]
     .ARRAY name count type [= default_value]
     .ENDA [.AEND] [.END]
</pre>
</span>

Available types are <b><tt>.BYTE</tt></b>, <b><tt>.WORD</tt></b>, <b><tt>.LONG</tt></b>, and <b><tt>.DWORD</tt></b>.

<p>
<tt>INDEX</tt> specifies the maximum permitted value of the array index range [0..INDEX].
This value can be a constant or an expression in the range  <b><tt>&lt;0..65535&gt;</tt></b>.
If INDEX is omitted, the range is determined by the number of input values.
</p>

CPU mnemonics cannot be used between .ARRAY and .ENDA, and attempting to do so or having
other illegal characters will result in the error <b>Improper syntax</b>.
        <p></p>
The array index used for initialization can be specified along with initializer values.
A new array index is set by placing it in square brackets at the beginning of a new
line, i.e. <b>[expression]</b>. Additional indices can be supplied, separated by
a colon (<b>':'</b>). The array values then follow after a equals sign (<b>'='</b>):
<span style="color: #0000FF">
<pre>
.array tab .byte      ; define array TAB with an unspecified number of elements
 1,3                  ; [0]=1, [1]=3
 5                    ; [2]=5 
 [12] = 1             ; [12]=1
 [3]:[7]:[11] = 9,11  ; [3]=9, [4]=11, [7]=9, [8]=11, [11]=9, [12]=11
.enda
</pre>
</span>

<p>
This facility may seem strange and of limitd use, but it is occasionally useful, such as
for declaring lookup tables for translating the scan code of a pressed key or between
<tt>ATASCII</tt> and <tt>INTERNAL</tt> code.
</p>

<span style="color: #0000FF">
<pre>
.array TAB [255] .byte = $ff   ; allocate 256 bytes [0..255] with initial value $FF

 [63]:[127] = "A"              ; assign new values TAB[63]="A", TAB[127]="A"
 [21]:[85]  = "B"
 [18]:[82]  = "C"
 [58]:[122] = "D"
 [42]:[106] = "E"
 [56]:[120] = "F"
 [61]:[125] = "G"
 [57]:[121] = "H"
 [13]:[77]  = "I"
 [1] :[65]  = "J"
 [5] :[69]  = "K"
 [0] :[64]  = "L"
 [37]:[101] = "M"
 [35]:[99]  = "N"
 [8] :[72]  = "O"
 [10]:[74]  = "P"
 [47]:[111] = "Q"
 [40]:[104] = "R"
 [62]:[126] = "S"
 [45]:[109] = "T"
 [11]:[75]  = "U"
 [16]:[80]  = "V"
 [46]:[110] = "W"
 [22]:[86]  = "X"
 [43]:[107] = "Y"
 [23]:[87]  = "Z"
 [33]:[97]  = " "

 [52]:[180] = $7e
 [12]:[76]  = $9b

.enda
</pre>
</span>

<p>
In this example, an array <tt>TAB</tt> is created with indices <tt>[0..255]</tt> and 256 <tt>.BYTE</tt>s in size,
pre-initialized to <tt>$FF</tt>. The array elements are then set to translate keyboard scan codes
(both upper and lowercase, ignoring case) to <tt>INTERNAL</tt>.
</p>

The colon (<tt>':'</tt>) is used to separate array indices.

<p></p>
Another example is to center a string:
<span style="color: #0000FF">
<pre>
 org $bc40

.array txt 39 .byte
 [17] = "ATARI"
.enda
</pre>
</span>



<p>
In summary, the <b><tt>.ARRAY</tt></b> directive allows creation of a one-dimensional array
of values with a specified type.
</p>

To refer to an array:
<span style="color: #0000FF">
<pre>
 lda tab,y
 lda tab[23],x
 ldx tab[200]
</pre>
</span>

If the index given in square brackets exceeds the maximum index of the array, the error message
<b><tt>Constant expression violates subrange bounds</tt></b> is reported.
</p>
<br />




<A NAME="macros">
<p class="duzy">
MACROS
<p>

Macros help perform repetitive tasks by automating them. They are only kept in memory during assembly
unless invoked. With their aid, <tt>MADS</tt> can push and pop parameters off a software stack for
a procedure declared with the directive <tt>.PROC</tt> and switch extended memory banks with
the option <tt>BANK SENSITIVE (OPT B+)</tt>.

<p></p>


<A NAME="makra">
<u><tt><h2>Declaring macros</h2></tt></u>

<p>
Macro pseudo-commands and directives:
</p>
<span style="color: #0000FF">
<pre>
name .MACRO [arg1, arg2 ...] ['separator'] ["separator"]
     .MACRO name [(arg1, arg2 ...)] ['separator'] ["separator"]
     .EXITM [.EXIT]
     .ENDM [.MEND]
     :[%%]parameter
     :[%%]label
</pre>
</span>

<tt><h3>name .MACRO [(arg1, arg2 ...)] ['separator'] ["separator"]</h3></tt>

Declares a macro named <b><tt>name</tt></b> with the directive <b><tt>.MACRO</tt></b>.
The macro name is required and an error is reported without it. Macro names cannot be
the same as an instruction mnemonic or pseudo-command, which will cause a
<b><tt>Reserved word</tt></b> error.

<p></p>
A list of named arguments can be specified for the macro, optionally wrapped in parentheses.
Assigning name to macro arguments improves readability of macro code.
Argument names and numeric arguments can be used interchangeably.

<span style="color: #0000FF">
<pre>
.macro SetColor val,reg
 lda :val
 sta :reg
.endm
</pre>
</span>

<p></p>
At the end of the macro declaration, the argument separator and the argument parsing mode
can be supplied (unchanged for single quotes, split into parameters and addressing modes
for double quotes).
<p>
<b>The default separators</b> for macro argument parsing are a comma (<tt>','</tt>) and a space (' ').
</p>

<span style="color: #0000FF">
<pre>
<li>name .MACRO 'separator'
</pre>
</span>
Between the quotes <tt>''</tt> we place the separator character used to separate parameters when
invoking the macro (only with single quotes).

<span style="color: #0000FF">
<pre>
<li>name .MACRO "separator"
</pre>
</span>

Double quotes (<tt>""</tt>) can also be used to set separators for the macro parameters, but this also
indicates to <tt>MADS</tt> that the parameters should be split into two parts: addressing mode
and argument.

<span style="color: #0000FF">
<pre>
 test #12 200 <30

test .macro " "
.endm
</pre>
</span>

This <tt>TEST</tt> macro is declared with a space as the separator using <b><tt>"</tt></b>,
which then causes the macro parameter to be divided into two parts, addressing mode and argument.
<span style="color: #0000FF">
<pre>
 #12   -&gt;  addressing mode '#' argument 12
 200   -&gt;  addressing mode ' ' argument 200
 &lt;30   -&gt;  addressing mode '#' argument 0   (calculated expression value of "<30")

 test '#' 12 ' ' 200 '#' 0
</pre>
</span>

<b>NOTE #1:</b> The sign operators <tt>'&lt;', '&gt;'</tt> are evaluated before parameters are passed
to a macro, with the result substituted as the parameter.

<p>
<b>NOTE #2:</b> If the macro parameter is the loop counter <b>'#'</b> or <b>'.R'</b>
(!!! the single character '#' or the directive '.R', and not an expression involving one of them !!!)
the value of the loop counter is substituted as the macro parameter.
</p>

This property can be used to create iterated label names like "label0", "label1", "label2", "label3"... :

<span style="color: #0000FF">
<pre>
 :32 find #

find .macro
      ift .def label:1
      dta a(label:1)
      eif
     .endm
</pre>
</span>

In this example, the address of each numbered label is written (if it is defined).
<p></p>
<br />


<p>
<u><tt><h3>.EXITM [.EXIT]</h3></tt></u>
End the macro. This terminates the macro invocation.
</p>

<p>
<u><tt><h3>.ENDM [.MEND]</h3></tt></u>
The directive .ENDM or .MEND ends the current macro definition. The .END directive cannot
be used as for the .LOCAL, .PROC, .ARRAY, .STRUCT, and .REPT directives.
</p>

<u><tt><h3>:[%%]parameter</h3></tt></u>
The parameter is a <b>positive decimal number</b> <tt>(>=0)</tt>, followed by a colon (<tt>':'</tt>)
or two percent signs (<tt>'%%'</tt>). If in a macro you want to use <tt>':'</tt> for repetition and
not to signify a macro parameter, ensure that the next character after the colon is outside of
the range <tt>'0'..'9'</tt>:
<span style="color: #0000FF">
<pre>
 :$2 nop
 :+2 nop
 :%10 nop
</pre>
</span>

Parameter <tt>:0 (%%0)</tt> has special meaning and contains the number of parameters passed.
This can be used to check if the required number of parameters was passed to a macro:
<span style="color: #0000FF">
<pre>
  .IF :0<2 || :0>5
    .ERROR "Wrong number of arguments"
  .ENDIF

  IFT %%0<2 .or :0>5
    ERT "Wrong number of arguments"
  EIF 
</pre>
</span>


<p>
<u>Example macro:</u>
</p>
<span style="color: #0000FF">
<pre>
.macro load_word

   lda <:1
   sta :2
   lda >:1
   sta :2+1   
 .endm

 test ne
 test eq

.macro test
  b%%1 skip
.endm
</pre>
</span>
<br />




<A NAME="makra_wy">
<u><tt><h2>Calling macros</h2></tt></u>

<p>
Macros are called by name, with arguments separated by default with commas (<tt>','</tt>) or spaces (' ').
The maximum number of parameters is limited only by PC memory. If the number of parameters passed
is fewer than the number of parameters in the macro, the missing parameters are set to the value
<b><tt>-1 ($FFFFFFFF)</tt></b>. This property can be used to test if a parameter has been passed,
but it is easier to use parameter zero (%%0).

<span style="color: #0000FF">
<pre>
 macro_name [Par1, Par2, Par3, 'Par4', "string1", "string2" ...]
</pre>
</span>

<p>
A parameter can be a value or a string delimited by either single quotes (<tt>''</tt>) or double quotes.
(<tt>""</tt>).
</p>

<li><u>Single quotes</u> <tt>' '</tt> are passed to the macro along with the characters within them
<li><u>Double quotes</u> <tt>" "</tt> mean that only the string within the quotes and not the quotes themselves are passed to the macro

<p>
All label definitions within a macro are local.
</p>

If the assembler does not find a label within the macro, it will then look in the local scope
(if there was a <b><tt>.LOCAL</tt></b> directive), then in the procedure (if a procedure is
currently being defined), and then finally in the main program.

<p>
<u>Examples of macro calls:</u>
</p>
<span style="color: #0000FF">
<pre>
 macro_name 'a',a,>$a000,cmp    ; the default separator ','
 macro_name 'a'_a_>$a000_cmp    ; the declared separator '_'
 macro_name 'a' a >$a000 cmp    ; the default separator ' '
</pre>
</span>

Macros can be called from other macros as well as called recursively. In the latter case,
care should be taken to avoid causing stack overflow in <tt>MADS</tt>. <tt>MADS</tt> is
protected against infinite recursion and will stop with an error once the nesting depth
reaches <tt>4095</tt> (with <tt><b>Infinite recursion</b></tt>).

<p>
<u>An example of a macro will overflow the <tt>MADS</tt> stack:</u>
</p>
<span style="color: #0000FF">
<pre>
jump .macro

      jump

     .endm
</pre>
</span>


<u>Example program that passes parameters to pseudo-procedures, from <tt>..\EXAMPLES\MACRO.ASM</tt>:</u>
<span style="color: #0000FF">
<pre>
 org $2000
 
 proc PutChar,'a'-64    ; call macro PROC, with as parameters
 proc PutChar,'a'-64    ; the name of a procedure to call by JSR
 proc PutChar,'r'-64    ; and a single argument (INTERNAL character code)
 proc PutChar,'e'-64
 proc PutChar,'a'-64

 proc Kolor,$23         ; call another procedure to change the background color

;---

loop jmp loop           ; endless loop to show the effect

;---

proc .macro             ; declare PROC macro
 push =:1,:2,:3,:4      ; call PUSH macro to push arguments onto the satck
                        ; =:1 calculates the memory bank
 
 jsr :1                 ; jump to procedure (procedure name is the first parameter)
 
 lmb #0                 ; Load Memory Bank, setting bank to 0
 .endm                  ; end of PROC macro

;---

push .macro             ; declare PUSH macro

  lmb #:1               ; set up virtual memory bank

 .if :2<=$FFFF          ; if passed argument is less than or equal to $FFFF
  lda <:2               ; put it on the stack
  sta stack
  lda >:2
  sta stack+1
 .endif 

 .if :3<=$FFFF
  lda <:3
  sta stack+2
  lda >:3
  sta stack+3
 .endif 

 .if :4<=$FFFF
  lda <:4
  sta stack+4
  lda >:4
  sta stack+5
 .endif 
 
 .endm
 

* ------------ *            ; KOLOR procedure
*  PROC Kolor  *
* ------------ *
 lmb #1                     ; set virtual bank to 1
                            ; label definitions are now local to this bank
stack org *+256             ; stack for KOLOR procedure
color equ stack

Kolor                       ; code for KOLOR procedure
 lda color
 sta 712
 rts

 
* -------------- *          ; PUTCHAR procedure
*  PROC PutChar  *
* -------------- *
 lmb #2                     ; set virtual bank to 1 2
                            ; label definitions are now local to this bank
stack org *+256             ; stack for PUTCHAR procedure
char  equ stack

PutChar                     ; code for PUTCHAR procedure
 lda char
 sta $bc40
scr equ *-2

 inc scr
 rts
</pre>
</span>

Of course, this example uses a software stack, whereas with the <tt>65816</tt>
the hardware stack could be used instead. Because the defined variables are each local to
a particular bank, procedure calls can be created with similar structure and function
to those of higher-level languages.

<p>
However, it is simpler and more efficient to use the procedures allowed by <tt>MADS</tt>,
which are declared with <b><tt>.PROC</tt></b>. For more information on procedure declaration
and operations, see <A HREF="#procs">Procedures</A>. 
</p>
<br />



<A NAME="procs">
<p class="duzy">
PROCEDURES (.PROC)
</p>

<tt>MADS</tt> adds the ability to use procedures with parameters. This feature resembles the
familiar mechanisms of high-level languages and is just as easy for a programmer to use.

<p>
The built-in <tt>MADS</tt> macros (<tt>@CALL.MAC, @PULL.MAC, @EXIT.MAC</tt>) provide
a software stack of 256 bytes, the same size as the hardware stack, a way to pop
from the software stack, and to save and restore parameters when calling other
procedures. <tt>MADS</tt> supports recursive procedure calls.
</p>

<p>
The programmer is not involved in this mechanism and can focus on his program, only needing
to define the appopriate labels and include the needed macros when assembling the program.
</p>

Also, the software stack can be omitted and arguments passed using a more classical method
with CPU registers (.REG directive) or with variables (.VAR directive).

<p>
Another feature of .PROC procedures is that it is possible to omit them during assembly if
they are not referenced. This produces the warning message <b>Unreferenced procedure ????</b>.
They can be removed during assembly by specifying the <b>-x</b> 'Exclude unreferenced procedures'
command-line parameter to MADS.
</p>


<p></p>
All labels defined in a <tt>.PROC</tt> procedure are local but can also be accessed globally,
which is uncommon in other programming languages.

<p></p>

It is possible to define a global label from Within a <tt>.PROC</tt> procedure (see
<A HREF="#labels_glo">Global labels</A>). 

<p></p>

To access labels within a procedure from outside of it, address it using a dot ('.'):

<span style="color: #0000FF">
<pre>
 lda test.pole

.proc test

pole nop

.endp
</pre>
</span>

If a referenced label is not found within a <tt>.PROC</tt> procedure, <tt>MADS</tt> will then
look for in enclosing scopes until the global scope is reached. To directly address a global label
from within a <tt>.PROC</tt> procedure (or any other scope) prefix the label name with a colon (':').

<p></p>


For procedures that use a software stack, <tt>MADS</tt> requires three specific globally defined labels
(the stack location, the stack pointer, and the address of the procedure variables):
<span style="color: #0000FF">
<pre>
<li>@PROC_VARS_ADR
<li>@STACK_ADDRESS
<li>@STACK_POINTER
</pre>
</span>

<p>
If these labels are undefined and a .<tt><b>.PROC</b></tt> procedure with a software stack is used,
MADS assumes the following default values: <b>@PROC_VARS_ADR = $0500</b>, <b>@STACK_ADDRESS = $0600</b>,
and <b>@STACK_POINTER = $FE</b>.
</p>

For procedures using a software stack, <tt>MADS</tt> also requires the declaration of macros with
specific names. Declarations of these macros are included with <tt>MADS</tt> in the following files:

<span style="color: #0000FF">
<pre>
<li>@CALL    ..\EXAMPLES\MACROS\@CALL.MAC
<li>@PUSH    ..\EXAMPLES\MACROS\@CALL.MAC
<li>@PULL    ..\EXAMPLES\MACROS\@PULL.MAC
<li>@EXIT    ..\EXAMPLES\MACROS\@EXIT.MAC
</pre>
</span>

These macros implement the loading and pushing of parameters onto the software stack, the popping
and saving of procedure parameters off the software stack, and calling other procedures using
the software stack.

<p></p>


<A NAME="proc">
<u><tt><h2>Declaration of .PROC procedures</h2></tt></u>

<p>
Procedure declaration directives:
</p>
<span style="color: #0000FF">
<pre>
 name .PROC [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR]
 .PROC name [,address] [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR]
 .ENDP [.PEND] [.END]
</pre>
</span>


<p></p>


<u><tt><h3>name .PROC [(.TYPE Par1,Par2 .TYPE Par3 ...)] [.REG] [.VAR]</h3></tt></u>

Declares a procedure <b>name</b> using the <tt><b>.PROC</b></tt> directive. The procedure name is
required and an error is generated without it. Mnemonic names and pseudo-commands cannot be used
as procedure names and will cause a <b><tt>Reserved word</tt></b> error.

<p></p>

To use <tt>MADS's</tt> parameter passing mechanism, the parameters have to be declared beforehand.
Parameter declarations are enclosed in parentheses <tt>( )</tt>. There are four types of parameters:

<pre>
<li><tt>.BYTE</tt>  (8-bit)  relocatable
<li><tt>.WORD</tt>  (16-bit) relocatable
<li><tt>.LONG</tt>  (24-bit) non-relocatable
<li><tt>.DWORD</tt> (32-bit) non-relocatable
</pre>

<tt><b>
In current versions of <tt>MADS</tt>, it is not possible to pass parameters of structure type (<tt><b>.STRUCT</b>).
</b></tt>

<p></p>

The parameter type comes first, followed by at least one space, followed by the parameter name.
Multiple parameters of the same type can be declared, separated by commas (<tt>','</tt>).

<p></p>

<u>Example procedure declarations using the software stack:</u>
<span style="color: #0000FF">
<pre>
name .PROC ( .WORD par1 .BYTE par2 )
name .PROC ( .BYTE par1,par2 .LONG par3 )
name .PROC ( .DWORD p1,p2,p3,p4,p5,p6,p7,p8 )
</pre>
</span>

<p>
Additionally, by using the .REG or .VAR directives, parameters can be passed to MADS procedures
by CPU registers (.REG) or variables (.VAR). The directive specifying the parameter passing
convention is placed at the end of the .PROC procedure declaration.
</p>

<u>Example procedure declarations using CPU registers:</u>
<span style="color: #0000FF">
<pre>
name .PROC ( .BYTE x,y,a ) .REG
name .PROC ( .WORD xa .BYTE y ) .REG
name .PROC ( .LONG axy ) .REG
</pre>
</span>

<p>
The .REG directive requirse that the parameter names are made up of the letters 'A', 'X', 'Y', or
a combination thereof. These refer to the names of the CPU registers and affect the order in which
they are used. The number of parameters passed is limited by the number of CPU registers, so at most
three bytes can be passed to the procedure. The advantage of this method is speed and lower memory
usage.
</p>

<u>Example procedure declarations using variables:</u>
<span style="color: #0000FF">
<pre>
name .PROC ( .BYTE x1,x2,y1,y2 ) .VAR
name .PROC ( .WORD inputPointer, outputPointer ) .VAR
name .PROC ( .WORD src+1, dst+1 ) .VAR
</pre>
</span>

With .VAR, the parameter names indicate the variable names which will be loaded with the passed
parameters. This method is slower than .REG but still faster than software stack methods.
</p>

<p>
Procedures are exited in the usual way, using the RTS command. Adding the <b><tt>RTS</tt></b>
instruction at the end of each code path is the responsibility of the programmer, not the assembler.
</p>

As with a .LOCAL block, a new address can be specified for assembling a .PROC block:
<span style="color: #0000FF">
<pre>
.PROC label,$8000
.ENDP

.PROC label2,$a000 (.word ax) .reg
.ENDP
</pre>
</span>

For procedures that use the software stack, MADS invokes the macro <tt><b>@EXIT</b></tt> at
the end of the procedure, whose task is to modify the software stack pointer
<b><tt>@STACK_POINTER</tt></b>. This is necessary for proper software stack operation.
Users can write their own <tt><b>@EXIT</b></tt> macro, or use the one included
with MADS (file <tt>..\EXAMPLES\MACROS\@EXIT.MAC</tt>), which currently looks like this:

<span style="color: #0000FF">
<pre>
.macro @EXIT

 ift :1<>0

  ift :1=1
   dec @stack_pointer

  eli :1=2
   dec @stack_pointer
   dec @stack_pointer

  els
   pha
   lda @stack_pointer
   sub #:1
   sta @stack_pointer
   pla

  eif

 eif

.endm
</pre>
</span>

<p>
The macro <b><tt>@EXIT</tt></b> should not alter the contents of <tt>CPU</tt> registers if you want
to return a result from a .PROC procedure using CPU registers.
<p></p>


<u><tt><h3>.ENDP</h3></tt></u>

The <tt><b>.ENDP</b></tt> directive ends a procedure declaration block.
<p></p>



<A NAME="proc_wy">
<u><tt><h2>Procedure calls</h2></tt></u>

<p>
A procedure is called by name (the same as for a macro), followed by any provided parameters,
separated by a commas (<tt>','</tt>) or spaces (' '). It is not possible to use other separators.
</p>

If the type of a parameter is different than the type used in the procedure declaration, an
<b><tt>Incompatible types</tt></b> error is reported.

<p>
If the number of parameters passed is different than the number of parameters in the procedure
declaration, the result is an <b><tt>Improper number of actual parameters</tt></b> error.
The exception is procedures which use parameters passed by CPU register (.REG) or
variable (.VAR), in which case the extra parameters are assumed to be already loaded into
the correct registers or variables.
</p>

<p>
<u>There are three ways to pass parameters:</u>
</p>
<li>'#' by value
<li>' ' by address (without prefix)
<li>'@' by accumulator (parameter type .BYTE)
<li>"string" as a string, e.g. "label,x"

<p>
<u>Example procedure calls:</u>
</p>
<span style="color: #0000FF">
<pre>
 name @ , #$166 , $A400  ; with the software stack
 name , @ , #$3f         ; with .REG or .VAR
 name "(hlp),y" "tab,y"	 ; with .VAR or the stoftware stack (the software stack uses the X register)
</pre>
</span>

<p>
When <tt>MADS</tt> encounters a procedure call that uses the software stack, it executes the
macro <tt>@CALL</tt>. However, if the procedure does not use the software stack, a plain
<b><tt>JSR PROCEDURE</tt></b> is used instead of the <tt>@CALL</tt> macro.
</p>

To the <b><tt>@CALL</tt></b> macro, <tt>MADS</tt> passes parameters computed based on the
procedure declaration, breaking each parameter into three components: addressing mode, parameter
type, and parameter value.
<span style="color: #0000FF">
<pre>
@CALL_INIT 3\ @PUSH_INIT 3\ @CALL '@','B',0\ @CALL '#','W',358\ @CALL ' ',W,"$A400"\ @CALL_END PROC_NAME
</pre>
</span>

Here, the <b><tt>@CALL</tt></b> macro pushes the contents of the accumulator, then the value
<tt>$166 (358 dec)</tt>, then the value at the address <tt>$A400</tt>. For more information on
how parameters are passed to the macro (and the importance of '' and ""), see <A HREF="#makra_wy">Calling macros</A>.

<p>
Parameters passed using the accumulator (<tt>'@'</tt>) should always be the first parameter
passed to the procedure. If it is used elsewhere, the accumulator is already modiied by that
point (this restriction is imposed by the <b><tt>@CALL</tt></b> macro). Of course, this can be
lifted with a custom version of the <b><tt>@CALL</tt></b> macro.

<u><b>With procedures that use .REG or .VAR, a '@' parameter can be used in any position.</b></u>
</p>

The end of a <b><tt>.PROC</tt></b> procedure is marked by an RTS. After the procedure call,
MADS invokes the <b>@EXIT</b> macro to modify the <b><tt>@STACK_POINTER</tt></b>, which is necessary
for proper operation of the software stack. The number of bytes passed to the procedure is passed
as a parameter to the macro, which then subtracts that number of bytes from the software stack.

<p class="editors-note">
(Editor's note: This is known as a caller-pops convention, since the caller both pushes and pops
the parameters off the stack, and is common in C implementations.)
</p>

<p>
Adding an <b><tt>RTS</tt></b> instruction at the end of every code path in the procedure is the responsibility
of the programmer, and not the assembler.
</p>
<br />



<A NAME="para_od">
<u><tt><h2>Referencing procedure parameters</h2></tt></u>

Referring to procedure parmaeters does not require additional effort by the programmer:
<span style="color: #0000FF">
<pre>
@stack_address equ $400
@stack_pointer equ $ff
@proc_vars_adr equ $80

name .PROC (.WORD par1,par2)

 lda par1
 clc
 adc par2
 sta par1
 
 lda par1+1
 adc par2+1
 sta par1+1

.endp

 icl '@call.mac'
 icl '@pull.mac'
 icl '@exit.mac'
</pre>
</span>

At the time of declaration, MADS automatically defines these parameters by assigning values
based on @PROC_VARS_ADR. In the preceding example, MADS will define the parameters as PAR1 =
@PROC_VARS_ADR and PAR2 = @PROC_VARS_ADR + 2.

<p>
The programmer uses these parameters by the names given in the procedure declaration, similarly
as with higher-level languages. In MADS, it is possible to access procedure parameters externally,
which is unusual in higher-level languages. For instance, PAR1 can be read as follows:
</p>

<span style="color: #0000FF">
<pre>
 lda name.par1
 sta $a000
 lda name.par1+1
 sta $a000+1
</pre>
</span>

This copies the two bytes at PAR1 to addresses $A000 and $A000+1. Of course, this can only be
done after completion of this particular procedure. Remember that each procedure has parameters
stored at the same area addressed by @PROC_VARS_ADR, so with each new procedure call
the parameter area at &lt;@PROC_VARS_ADR
.. @PROC_VARS_ADR + $FF&gt; changes.

<p>
If a procedure is declared using .REG type parameters, the programmer should remember to
preserve or use parameters before they are modified by the procedure code. With .VAR type
parameters, this is not an issue because the parameters are saved in specific memory locations
where they can always be read.
</p>


<p></p>
<br />



<A NAME="locals">
<p class="duzy">
LOCAL AREA
</p>


The main purpose of a local area in <tt>MADS</tt> is to create a new scope for labels.

<p></p>

All labels defined in a <tt>.LOCAL</tt> area are local. However, you can still refer to a local
label globally, which is uncommon in other programming languages.

<p></p>

It is possible to define a global label within a <tt>.LOCAL</tt> area
(see <A HREF="#labels_glo">Global labels</A>). 

<p></p>

If the assembler cannot find a label within a <tt>.LOCAL</tt> area, <tt>MADS</tt> will then look
in the global scope. To refer to global labels directly from a <tt>.LOCAL</tt> area, prefix
the label name with a colon (':').

<p></p>


<A NAME="obszar_lok">
<u><tt><h2>Declaring .LOCAL scopes</h2></tt></u>

<p>
Local scope directives:
</p>
<span style="color: #0000FF">
<pre>
 [name] .LOCAL [,address]
 .LOCAL [name] [,address]
 .ENDL [.LEND] [.END]
</pre>
</span>

<u><tt><h3>[name] .LOCAL [,address]</h3></tt></u>
<p>
Declares a local scope named <b>name</b> with the directive <tt><b>.LOCAL</b></tt>.
The local scope name is not required and can be omitted. Local scope names cannot be the same
as mnemonics and pseudo-commands, and attempting to use a reserved name will result in a
<b><tt>Reserved word</tt></b> error.
</p>

<p>
After the name of the local scope (or the .LOCAL directive), a new assembly address can be
provided. After the end of the block (.ENDL), the assembly address reverts to the previous
address plus the length of the block.
</p>

<span style="color: #0000FF">
<pre>
label .local,$4000
.endl

.local label2,$8000
.endl

.local
.endl

.local label3
.endl
</pre>
</span>

All definitions within a <b><tt>.LOCAL</tt></b> block are local. To refer to a global label with
the same name as a local name, prefix the name with a colon (<tt>':'</tt>):

<span style="color: #0000FF">
<pre>
lab equ 1

.local

lab equ 2

 lda #lab
 ldx #:lab

.endl
</pre>
</span>

In this example, the A register is set to 2, while the X register is set to 1.

<p>
If the assembler cannot find a label in a <b><tt>.LOCAL</tt></b> scope, it will then check
an enclosing macro (if one is being processed), then the enclosing procedure (if there is one),
and finally the main program at global scope.
</p>

Within a local scope, all label definitions are qualified by the local scope's name. To reach
labels defined in another local scope, both the name of the local scope and the label must be
supplied:

<span style="color: #0000FF">
<pre>
 lda #name.lab1
 ldx #name.lab2

.local name

lab1 = 1
lab2 = 2

.endl
</pre>
</span>

<p>
A dot (<tt>'.'</tt>) is used to address labels within a <b><tt>.LOCAL</tt></b> block.
</p>

<p>
Local scopes can be nested, as well as placed within procedures declared using
the <tt><b>.PROC</b></tt> directive. Local scopes are cumulative, i.e. there may
be multiple scopes of the same name and all symbols in those scopes will belong
to a common namespace.
</p>


<u><tt><h3>.ENDL</h3></tt></u>
<p>
The <b>.ENDL</b> directive ends a local scope.
</p>

<u>Local scope declaration example:</u>
<span style="color: #0000FF">
<pre>
 org $2000
 
tmp ldx #0   <-------------   label in global scope
                          |
 lda obszar.pole  <---    |   reference to local scope
                     |    |
.local obszar        |    |   local scope declaration
                     |    |
 lda tmp   <---      |    |
              |      |    |
 lda :tmp     |      | <---   reference to global scope
              |      |
tmp nop    <---      |        definition in local scope
                     | 
pole lda #0       <---   <--- definition in local scope
                            |
 lda pole  <----------------- reference within local scope

.endl                         end of local scope
</pre>
</span>

<br />



<A NAME="syntax">
<p class="duzy">
SYNTAX
</p>

<tt>MADS</tt> accepts the same syntax as <tt>QA</tt> and <tt>XASM</tt>.
However, it is stricter with comments placed at the end of a line (comments
should be preceded the appropriate symbol) and more lenient with
whitespace and <tt>CPU</tt> instruction mnemonics without arguments, i.e.:

<span style="color: #0000FF">
<pre>
   asl            ->  asl @
   lda #          ->  lda #0
</pre>
</span>

<p></p>

<tt>MADS</tt> will accept no whitespace separating the mnemonic and operand, provided
that the operand does not start with a <tt>'@'</tt>, which is used in the names
of labels, or <tt>'%' and ':'</tt>, which are used to denote numbered macro
parameters (<tt>%%number, :number</tt>), e.g.:

<span style="color: #0000FF">
<pre>
   lda$44
   lda#
   lda(80),y
</pre>
</span>


<p></p>


<A NAME="kom">
<u><tt><h2>Comments</h2></tt></u>

Comment lines must start with a <tt>';'</tt> or <tt>'*'</tt>.
For a single-line comment, however, the safest way is to use a semicolon (<tt>';'</tt>),
as the asterisk (<tt>'*'</tt>) has other meanings and can mean multiplication or
the current assembly address. On the other hand, the semicolon is dedicated only
for comments.

<p></p>

The characters <tt>'//'</tt> can also be used for a single-line comment, and
<tt>'/* */'</tt> for a multi-line or inline comment.

<span style="color: #0000FF">
<pre>
 * this is a comment
                 ; this is a comment
 lda #0      ; this is a comment
 dta  1 , 3     * BAD COMMENT, WILL BE MISINTERPRETED

 org $2000 + 1      BAD COMMENT, WILL BE MISINTERPRETED

 nop // this is a comment

 // this is a comment

 dta 1,2, /* comment */ 3,4

 lda /* comment */ #0

/*
  ...
  this is a multi-line comment
  ...
*/

/************************************
  this is also a multi-line comment
*************************************/
</pre>
</span>

<p>
The multi-line comment signs <tt>'/* */'</tt> and the end-line comment sign <tt>'//'</tt> can be used without restrictions.
</p>
<br />



<A NAME="znak_p">
<u><tt><h2>Splicing multiple lines into a single line</h2></tt></u>

<p>
Multiple lines can be spliced into a single line using <tt>'\'</tt>, e.g.:
</p>

<span style="color: #0000FF">
<pre>
 lda 20\ cmp 20\ beq *-2
 
    lda 20   \ cmp  20   \   beq *-2
 
  lda #0  \lop  sta $a000,y  \ iny  \ bne lop     ; comments only at the end of this line
</pre>
</span>

<p>
If there is no space after the <tt>'\'</tt> character, a mnemonic or other string can be
interpreted as a label, so make sure to treat <tt>'\'</tt> as the beginning of a new line.
</p>

<p>
<tt>MADS</tt> stops processing the line once either at the end of the chain or when a comment is reached,
so comments can be placed only at the end of the line.
</p>

<b>WARNING!!!</b> <u>Putting a '\' at the end of a line tells MADS to splice the current line with
the next line. For example:</u>

<span style="color: #0000FF">
<pre>
 lda\
 #\
 12
</pre>
</span>

In this case, we get the result 'LDA #12'.
<p></p>
<br />


<A NAME="znak_d">
<u><tt><h2>Combining multiple mnemonics</h2></tt></u>
<p>
<tt>XASM</tt> already provided the ability to combine two mnemonics using a <tt>':'</tt>.
In <tt>MADS</tt>, this is extended to combine any number of <tt>MADS-known</tt> mnemonics:

<span style="color: #0000FF">
<pre>
 lda:cmp:req 20

 lda:iny:sta:iny $600,y
</pre>
</span>

<p class="editors-note">
(Editor's note: All mnemonics in a combined statement are processed with the same argument.
This is fine when some of the instructions only have implied addressing. However, it can lead
to accidents with instructions that have both implied and memory forms. For instance,
"STA:INC:RNE pixels,X+"
will assemble as STA pixels,X / INX / INC pixels,X / INX / BNE *.)
</p>

<br />



<A NAME="expres">
<p class="duzy">
EXPRESSIONS
</p>

The term <b>expression</b> means a series of operators and operands (arguments) that
specifies the order of operations, i.e. type and order of evaluation. A compound expression
is an expression with two or more operators. Operators that affect only one operand are
called unary, and operators with two arguments are called binary.

<p></p>
Expressions are evaluated in the order determined by priority of each operator in the
direction specified by the precedence of each operator.

<p></p>


<A NAME="numbers">
<u><tt><h2>NUMBERS</h2></tt></u>

<p>
<tt>MADS</tt> accepts numbers in decimal, hexadecimal, binary, ATASCII, and INTERNAL
format.
</p>

<li>decimal notation:
<pre>
 -100
 -2437325
 1743
</pre>

<li>hexadecimal notation:
<pre>
 $100
 $e430
 $000001
 
 0x12
 0xa000
 0xaabbccdd
</pre>

<li>binary notation:
<pre>
 %0001001010
 %000000001
 %001000
</pre>

<li>ATASCII code:
<pre>
 'a'
 'fds'
 'W'*
</pre>


<li>INTERNAL code:
<pre>
 "B"
 "FDSFSD"
 "."*
</pre>

Only the first charcater of ATASCII or INTERNAL coding is significant. A <tt>'*'</tt> after the closing
quote specifies inverse characters.
<p></p>
Additionally, there are two possible operations '+' and '-' for strings, which increase or decrease the
values of the quoted characters.

<pre>
 "FDttrteSFSD"-12
 'FDSFdsldksla'+2
</pre>


<p></p>
<br />




<A NAME="opers">
<u><tt><h2>Operators</h2></tt></u>

<pre>
<u>Binary operators:</u>

+   Addition
-   Subtraction
*   Multiplication
/   Division
%   Remainder
&   Bitwise and
|   Bitwise or
^   Bitwise xor
&lt;&lt;  Arithmetic shift left
&gt;&gt;  Arithmetic shift right
=   Equal
==  Equal (same as =)
&lt;&gt;  Not equal
!=  Not equal (same as <>)
&lt;   Less than
&gt;   Greater than
&lt;=  Less or equal
&gt;=  Greater or equal
&&  Logical and
||  Logical or


<u>Unary operators:</u>

+  Plus (does nothing)
-  Minus (changes sign)
~  Bitwise not (complements all bits)
!  Logical not (changes true to false and vice versa)
&lt;  Low (extracts low byte)
&gt;  High (extracts high byte)
^  High 24bit (extracts high byte)
=  Extracts memory bank
:  Extracts global variable value


<u>Operator precedence:</u>

first []              (brackets)
 + - ~ &lt; &gt;            (unary)
 * / % & &lt;&lt; &gt;&gt;        (binary)
 + - | ^              (binary)
 = == &lt;&gt; != &lt; &gt; &lt;= &gt;= (binary)
 !                    (unary)
 &&                   (binary)
last  ||              (binary)
</pre>
<br />



<A NAME="labels">
<p class="duzy">
LABELS
</p>


<p>
Labels may be defined in the program with local or global scope, depending
on the location where they are defined. Additionally, labels may be defined
as temporary, also with local or global scope.
</p>

<p>
<li><tt>A <b>global label</b></tt> is visible from anywhere in the program,
even within a macro (<tt><b>.MACRO</b></tt>), procedure (<tt><b>.PROC</b></tt>),
or local scope (<tt><b>.LOCAL</b></tt>).
</p>

<p>
<li>A <tt><b>local label</b></tt> is only visible within the <tt><b>.MACRO</b></tt>,
<tt><b>.PROC</b></tt>, or <tt><b>.LOCAL</b></tt> scope in which it is defined.
</p>

<li>Label names must begin with <tt>['A'..'Z','a'..'z','_','?','@']</tt>.
<li>The rest of the label name may contain: <tt>['A'..'Z','a'..'z','0'..'9','_','?','@']</tt>
<li>Labels are always at the beginning of a line.
<li>A label preceded by whitespace should end in a ':' to avoid misinterpretation as a macro.
<li>In addressing expressions, prefixing a label with ':' tells the assembler to refer to the
    label in the main program (global label).

<p>
<u>Examples of label definitions:</u>
</p>
<span style="color: #0000FF">
<pre>
?name    EQU  $A000      ; defining a temporary global label
name      =   *          ; defining a global label
name2=12                 ; defining a global label
@?name   EQU  'a'+32     ; defining a global label
  name: equ 12           ; defining a non-global label that does not start at the beginning of the line
         name: = 'v'     ; defining a non-global label that does not start at the beginning of the line
</pre>
</span>


<p>
Unlike QA/XASM, a question mark (<tt>'?'</tt>) and at-sign (<tt>'@'</tt>) can be used in label names.
</p>

Using a dot (<tt>'.'</tt>) in a label name is allowed but not recommended. The dot is reserved for
extended mnemonics, assembler directives, and addressing new MADS structures.

<p>
A dot (<tt>'.'</tt>) at the beginning of a label name suggests that it is an assembler
directive, and a question mark (<tt>'?'</tt>) at the beginning signifies a temporary
label that can be changed several times during assembly.
</p>
<br />


<A NAME="labels_anm">
<u><tt><h2>Anonymous labels</h2></tt></u>
<p>
To ensure clarity when using anonymous labels, their use is limited only to jumps
no more than 10 instances away.
</p>
<p>
The character '@' is reserved for anonymous labels, and there must be a sign
character indicating either forward direction ('+') or backwards direction ('-').
Additionally, you can specify the number of anonymous labels in the range [1..9].

<span style="color: #0000FF">
<pre>
 @+[1..9]     ; forward
 @-[1..9]     ; backward

@ dex   ---- -------
  bne @+   |  --   |
  stx $80  |   |   |
@ lda #0   |  --   |
  bne @- ---       |
  bne @-1  ---------
</pre>
</span>
<br />



<A NAME="labels_lok">
<u><tt><h2>Local labels</h2></tt></u>

<p>
Labels defined within a macro (<b><tt>.MACRO</tt></b>), procedure (<b><tt>.PROC</tt></b>),
or local scope (<b><tt>.LOCAL</tt></b>) are local labels by default and do not
need additional markup.
</p>

Local labels are defined using the following equivalent psuedo commands:
<span style="color: #0000FF">
<pre>
 EQU
  =
</pre>
</span>

To access global labels, i.e. those defined outside of a macro (<b><tt>.MACRO</tt></b>),
procedure (<b><tt>.PROC</tt></b>), or local scope (<b><tt>.LOCAL</tt></b>), use the
<tt>':'</tt> operator:
<span style="color: #0000FF">
<pre>
lp   ldx #0         ; define global label LP

     test
     test
 
test .macro

      lda :lp       ; the ':' prefix causes reference to the global label LP

      sta lp+1      ; reference to the local label LP in the macro
lp    lda #0        ; definition of local label LP in the macro

     .endm
</pre>
</span>

In this example, there are two definitions of labels with the same name (<tt>LP</tt>),
but each has a different value and a different scope.
<p></p>
<br />




<A NAME="labels_glo">
<u><tt><h2>Global labels</h2></tt></u>

<p>
Each definition outside of a macro (<b><tt>.MACRO</tt></b>), procedure (<b><tt>.PROC</tt></b>),
or local scope (<b><tt>.LOCAL</tt></b>) is global.
</p>

Global labels are defined using the following equivalent pseudo commands:
<span style="color: #0000FF">
<pre>
 EQU
  =
</pre>
</span>

Or with .DEF directive syntax:
<span style="color: #0000FF">
<pre>
 .DEF :label [= expression]
</pre>
</span>

<p>
The .DEF directive normally defines local labels, but the ':' at the beginning
of the label indicates a global label instead. Using the syntax <b>.DEF :label</b>
allows definition of global labels within a local scope.
</p>

<b>
The ':' at the beginning of the label has special meaning and indicates a global
label, or label at mainline level, disgarding any current local scopes.
</b>

<p></p>
For more information on use of the .DEF directive, see <a href="#_def">.DEF Directive</a>.

<p></p>


<u>An example of defining global labels:</u>
<span style="color: #0000FF">
<pre>
lab equ *
   lab2 equ $4000

	?tmp = 0
	?tmp += 40
 
.proc name

      .def :?nazwa   = $A000
           .def :nazwa=20

      .local lok1
        .def :@?nazw   = 'a'+32
      .endl

.endp
</pre>
</span>

Examples of defining a global temporary labels include the macro <b><tt>@CALL</tt></b>
(in <tt>..\EXAMPLES\MACROS\@CALL.MAC</tt>), which defines the temporary label
<b><tt>?@STACK_OFFSET</tt></b>. This is later used by other macros called
called by the macro <b><tt>@CALL</tt></b>, and is used to optimize access to
parameters on the stack.

<span style="color: #0000FF">
<pre>
@CALL .macro

  .def ?@stack_offset = 0    ; definition of temporary global lavel ?@stack_offset
 
  ...
  ...
 
 
@CALL_@ .macro

  sta @stack_address+?@stack_offset,x
  .def ?@stack_offset = ?@stack_offset + 1    ; modify ?@stack_offset label

 .endm 
</pre>
</span>
<br />



<A NAME="labels_set">
<u><tt><h2>Temporary labels</h2></tt></u>

<p>
A temporary label has the property that its value can be changed many times
during assembly. Normally, attempting to redefine a label results in a
<b><tt>Label declared twice</tt></b> error, which does not occur with a
temporary label.
</p>

<p>
The lifetime of a temporary label depends on the scope in which it is defined.
Temporary labels may have local scope (<A HREF="#labels_lok">Local labels</A>) or global scope
(<A HREF="#labels_glo">Global labels</A>).

</p>

A temporary label is created by placing a <tt>'?'</tt> at the beginning:
<span style="color: #0000FF">
<pre>
 ?label
</pre>
</span>

<b>
Temporary labels should not be used to name procedures (<tt>.PROC</tt>), macros
(<tt>.MACRO</tt>), local scopes (<tt>.LOCAL</tt>), structures (<tt>.STRUCT</tt>),
or arrays (<tt>.ARRAY</tt>).
</b>

<p></p>

A temporary label is defined using one of the following equivalent pseudo commands:
<span style="color: #0000FF">
<pre>
 EQU
  =
</pre>
</span>

Additionally, they can be modified using recognizable <tt>C</tt> operators:
<span style="color: #0000FF">
<pre>
 -= expression
 += expression
 --
 ++
</pre>
</span>

These assignment operators only work with temporary labels, and attempting to
use them for other types of labels results in a <tt><b>Improper syntax</b></tt>
error message.

<p></p>

<u>Examples of using temporary labels:</u>
<span style="color: #0000FF">
<pre>
?loc = $567
?loc2 = ?loc+$2000

	 lda ?loc
	 sta ?loc2

?loc = $123

	 lda ?loc
</pre>
</span>
<br />


<A NAME="labels_mae">
<u><tt><h2>MAE-style temporary labels</h2></tt></u>

<p>
Option <b>OPT ?+</b> tells MADS that labels starting with <b>'?'</b> should be interpreted
as local labels as MAE does. By default, labels starting with <b>'?'</b> are interpreted by
MADS as temporary labels (<a href="#labels_set">Temporary labels</a>).
</p>

<u>An example of using MAE-style temporary labels:</u>
<span style="color: #0000FF">
<pre>
       opt ?+
       org $2000

local1 ldx #7
?lop   sta $a000,x
       dex
       bpl ?lop

local2 ldx #7
?lop   sta $b000,x
       dex
       bpl ?lop
</pre>
</span>
<br />




<A NAME="sdx">
<p class="duzy">
SPARTADOS X
</p>


<A NAME="sdx_plik">
<u><tt><h2>SpartaDOS X and Atari DOS file formats</h2></tt></u>
<p>
Reproduced from Serious Magazine, author Qcyk/Dial.
</p>

<p>
A file itself is only a collection of bytes, lots of numbers that can mean
both everything and nothing at the same time if you do not know how to
interpret them. For this reason, most files are equipped with a variety of
headers which store information about what the file contains and are
necessary to read them. This includes binary executables loaded under DOS.
After all, DOS is a program and like everyone else has a right to expect
a certain structure in its data.
</p>

<p>
Traditional binary files, recognized by all <tt>DOSes</tt> for <tt>Atari XL/XEs</tt>, are built
of blocks where each block has its own header. There are two types of headers:
</p>
<pre>
 1. dta a($ffff),a(str_adr),a(end_adr)

 2. dta a(str_adr),a(end_adr)
</pre>

<p>
<tt><b>str_adr</b></tt> - address at which the first byte of data will be loaded
</p>

<p>
<tt><b>end_adr</b></tt> - address at which the last byte of data will be loaded
</p>
</pre>


<p>
The first block in the file header must be <tt>$ffff</tt>, followed by other blocks. Each block
header should of course be followed by this amount of data:
</p>

<pre>
   (end_adr-str_adr)+1
</pre>

<p>

That's enough of a refresher. The developers of SpartaDOS X have kept the above standard, while
adding several new types of headers. The file is still divided into blocks, except that now there
are a lot more types of blocks. Here they are:
</p>
<br />


<h4><u>1. Non-relocatable block (loaded at fixed address in memory):</u></h4>
<pre>
    dta a($fffa),a(str_adr),a(end_adr)
</pre>
<p>
This is the same as a <tt>$ffff</tt> block - it does not matter which you use. However, <tt>$fffa</tt>
will clearly indicate that the program is designed for <tt>SDX</tt> - another <tt>DOS</tt> cannot
read the file.
</p>
<br />


<h4><u>2. Relocatable block (loaded starting at <tt>MEMLO</tt>):</u></h4>
<pre>
    dta a($fffe),b(blk_num),b(blk_id)
    dta a(blk_off),a(blk_len)
</pre>
<p>
<tt><b>blk_num</b></tt> - block number in the file. Each relocatable block should have its own
number. Because the load addresses of blocks are not known, blocks are just identified by number.
They may be in the range 0-7, except that in practice they are usually numbered from 1 upwards.
</p>

<p>
<tt><b>blk_id</b></tt> - bits 1-5 are the memory type, indicating where the block is to be loaded.
I have encountered two values:
<pre>
 $00 - main memory
 $02 - extended memory
</pre>
Also, bit 7 indicates no data block if set. In this case, <tt>SDX</tt> loads nothing, but
still reserves memory.
</p>

<p>     
<tt><b>blk_off</b></tt> - block base address, which is simply the address at which the code was
assembled. Thsi is necessary when relocating addresses referring to the contents of the block.
</p>

<p> 
<tt><b>blk_len</b></tt> - the length of the block. There should be as much data following as indicated
by the header, unless the block is only a reserved area in which case there is no data.
</p>

When writing relocatable code, several limitations imposed by the idea of "relocatable code" must be
kept in mind. All addresses referring to program areas must be updated during load, so sequences
such as this cannot be used:

<pre>
       lda &lt;something
       ldx &gt;something
       ...
      something equ *
       ...
    Instead, use something like this, for example:
       lda _something
       ldx _something+1
       ...
      _something dta a(something)
       ...
      something equ *
</pre>
<br />


<h4><u>3. Update addresses in a block referring to a relocatable block:</u></h4>
<pre>
    dta a($fffd),b(blk_num),a(blk_len)
</pre>

<p>
<tt><b>blk_num</b></tt> - number of block containing the reference targets
</p>

<p>
<tt><b>blk_len</b></tt> - update block length (without the header). This is ignored.
</p>

<p>
Addresses are updated by adding the difference between the address at which the relocatable
block was loaded and the value of blk_off (where the block was originally assembled). This
can be illustrated as follows:
<pre>
       ADR=ADR+(blk_adr-blk_off)
</pre>
</p>

<p>
The payload of an update block contains pointers to addresses and special commands. Numbers
between <tt>$00-$fb</tt> are offsets from the last updated location. This location is stored
as an address in an update pointer. This pointer can be updated through special functions
invoked by values greater than <tt>$fb</tt>:

<p>
<u><tt><b>$fc</b></tt></u>
marks the end of the update block,
</p>

<p>
<u><tt><b>$fd,a(ADDR)</b></tt></u>
directly updates the address <tt>ADDR</tt>. Thus, the update pointer is set to <tt>ADDR</tt>,
which is used as the base for the next offset,
</p>

<p>
<u><tt><b>$fe,b(blk_num)</b></tt></u>
sets the update pointer to the base address of the block specified by <tt>blk_num</tt>, which is
then used for the next offset,
</p>

<p>
<u><tt><b>$ff</b></tt></u>
increases the update pointer by <tt>$fa</tt> (without updating an address).
</p>
<br />


<h4><u>4. Update addresses in blocks targeting procedures with defined symbols:</u></h4>
<pre>
    dta a($fffb),c'SMB_NAME',a(blk_len)
</pre>

<p>
<tt><b>SMB_NAME</b></tt> - procedure symbol name (or array, system registry, etc.) Eight characters in <tt>ATASCII</tt> code,
</p>

<p>
<tt><b>blk_len</b></tt> - as in a <tt>$fffd</tt> block.
<p>

<p>
After the header, there is a sequence of offsets to locations of addresses to update - the same as
in a <tt>$fffd</tt> block. Addresses are updated by adding the address of the procedure denoted
by the symbol to the existing address. This allows use in programs of procedures whose addresses
are unknown, such as procedures added by other applications running in the <tt>SDX</tt> environment. Also,
system procedures must be used this way, as they have different addresses in different versions
of Sparta.
</p>
<br />


<h4><u>5. Symbol definition block:</u></h4>
<pre>
    dta a($fffc),b(blk_num),a(smb_off)
    dta c'SMB_NAME'
</pre>

<p>
<tt><b>blk_num</b></tt> - number of the block in which the procedure is defined. This means that the procedure must be defined in a relocatable block.
</p>

<p>
<tt><b>smb_off</b></tt> - procedure offset in the block, which is an offset from the start of the block (the first byte is 0) plus the value
of <tt>blk_off</tt> of the block. Basically, the address at which the procedure was assembled.
</p>

<p>
<tt>SMB_NAME</tt> - symbol name being defined for the procedure.
</p>

<p>
Block types <tt>$fffb</tt>, <tt>$fffc</tt>, and <tt>$fffd</tt> are not kept in memory. The system uses them only during program load.
</p>
<br />



<A NAME="sparta">
<u><tt><h2>Programming SpartaDOS X (SDX)</h2></tt></u>
<p>
The syntax for handling <tt>SpartaDOS X</tt> programs, was taken from <tt>FastAssemblera</tt>
by the author <tt>Marka Goderskiego</tt>. Below is a quote from the manual that came with <tt>FA</tt>.
<tt>MADS</tt> can now assemble source files in <tt>*.FAS</tt> format without any major problems.
Relocatable commands always have two-byte arguments; it is impossible to relocate 3-byte arguments
<tt>(65816)</tt>.
</p>

<p>
The most important innovation in <tt>SDX</tt> is the ability for developers to write relocatable
code. Since the <tt>MOS 6502</tt> does not have relative addressing (except for short branches),
the <tt>ICD</tt> developers created a way to do so using special program blocks. The process is
based on loading blocks and then updating addresses within the blcok using special update blocks.
It is enough to add the value of <tt>memlo</tt> to correct addresses, but what addresses to
correct, and which ones to leave? That's the point of a special block that contains (specially
coded) offsets to those addresses. Therefore, an <tt><b>UPDATE ADDRESS</b></tt> operation must
be applied to each <tt><b>RELOC</b></tt> block before running the program. <tt><b>UPDATE ADDRESS</b></tt>
must also be performed on any block which refers to <tt><b>SPARTA</b></tt> commands or vectors.
</p>

<p>
Another innovation is the introduction of symbols. Some of the <tt>SDX</tt> service
procedures are defined by name! These names always have 8 letters (like filenames).
Instead of using arrays of vectors or jumps (like in the OS), use symbols defined
with <b><tt>SMB</tt></b>. After loading a block or blocks, <tt>SDX</tt> loads symbol
blocks and updates symbol addresses the same way as with relocatable addresses in
the program. Symbols can refer to items in either <tt><b>RELOC</b></tt> or
<tt><b>SPARTA</b></tt> blocks.
</p>

<p>
Programmers can define custom symbols to replace the ones in <tt>SDX</tt> or completely new ones
for use by other programs. This is done by the <tt><b>UPDATE NEW</b></tt> block. It should
be kept in mind that new symbols must be stored in a <tt><b>RELOC</b></tt> block.
</p>

<p>
The number of <tt><b>RELOC</b></tt> and <tt><b>EMPTY</b></tt> blocks is limited to 7 by <tt>SDX</tt>.
</p>

<p>
Such blocks can be combined into chains:
<pre>
       blk sparta $600
       ...

       blk reloc main
       ...

       blk empty $100 main
       ...

       blk reloc extended
       ...

       blk empty $200 extended
</pre>
This means that commands for these blocks can refer to all blocks in the chain.
</p>

<p>
The chain is not interrupted by updating addreses or symbols, but is ended by the definition
of a new symbol and by other block types, e.g. DOS.
</p>

<p>
<tt><b>Note:</b></tt> The chain only makes sense if all blocks are loaded into the same memory,
or when a program switches to the appropriate memory references.
</p>

<p>
<tt><b>Note:</b></tt> Commands and vectors in <tt><b>RELOC</b></tt> and <tt><b>EMPTY</b></tt>
blocks should not refer to <tt><b>SPARTA</b> blocks!</tt> This may cause an error when the user
loads the program using the <tt><b>LOAD</b></tt> command and uses it after a long time. While
<tt><b>RELOC</b></tt> and <tt><b>EMPTY</b></tt> are safe, you never know what is in memory
where a <tt><b>SPARTA</b> block was last loaded!</tt>
</p>

<p>
Equally dangerous is the references to <tt><b>RELOC</b></tt> and <tt><b>EMPTY</b></tt> blocks by <tt><b>SPARTA</b></tt> blocks
(for the same reason as above), but during the installation of overlays (*.sys) using
<tt><b>INSTALL</b></tt> this is sometimes necessary and therefore acceptable. You can also
invoke a <tt><b>SPARTA</b></tt> block (through <tt>$2E2</tt>) to run immediate, then
discard it.
</p>

<p>
<tt><b>Note:</b></tt> Addresses can collide between <tt><b>SPARTA</b></tt> blocks and
<tt><b>RELOC</b></tt>/<tt><b>EMPTY</b></tt> addresses! <tt>FA</tt> recognizes references to
other blocks by address, assuming a <tt>PC</tt> for <tt><b>RELOC</b></tt> and <tt><b>EMPTY</b></tt>
blocks of <tt>$1000</tt>, so for mixed programs <tt><b>SPARTA</b></tt> blocks should be below
<tt>$1000</tt> (e.g. <tt>$600</tt>) or above the last relocatable block,
<tt>$4000</tt> using being enough. This error is not detected by the compiler!
</p>
<p></p>
<br />



<A NAME="_relok">
<p class="duzy">
RELOCATABLE CODE
</p>
Relocatable code is code without a fixed address, such that when loaded into
a computer it has to work regardless of the load address. SpartaDOS X (SDX)
provides a relocation facility for Atari XL/XE code, of which more than be
read in the section <a href="#sparta">Programming SpartaDOS X</a>.
<p>
A basic limitation of SDX relocatable code is that only WORD addresses are relocated
and there is no support for 65816 code. MADS provides the ability to generate code
both in SDX format and in a non-SDX format that removes the aforementioned limitations.
</p>

<p>
The MADS relocatable code format is similar to that of SDX, as there are main blocks
and then blocks with additional address relocation information. MADS uses a simpler
update block format, without the "compression" used by SDX.
</p>

<A NAME="_relok_zal">
<p>
<u>Advantages of MADS relocatable code:</u>
<li>supports operand sizes for both 6502 and 65816 CPUs
<li>can use all CPU instructions without restriction
<li>supports relocation of both high and low address bytes
</p>

<A NAME="_relok_ogr">
<p>
<u>Limitations of MADS relocatable code:</u>
<li>labels defined by EQU must precede .RELOC blocks
<li>new labels defined in .RELOC blocks must have its name preceded by a space or tab (global label)=
<li>you cannot use the ORG, RMB, LMB, or NMB pseudo instructions, or the .DS directive
<li>cannot relocate the highest byte of 24-bit words, i.e. lda ^$121416
</p>

An example of how easy it is to create relocatable code is in the file ..\EXAMPLES\TETRIS_RELOC.ASM,
which uses the CPU instruction set and data definition pseudo-instructions no differently than
the non-relocatable version in ..\EXAMPLES\TETRIS.ASM.

<p></p>
<br />


<A NAME="_reloc">
<u><tt><h2>Reloctable blocks (.RELOC)</h2></tt></u>

<p>
A MADS relocatable block is created using the directive:
<span style="color: #0000FF">
<pre>
 .RELOC [.BYTE|.WORD]
</pre>
</span>

A block for updating a relocatable MADS block is created using the BLK pseudo-command:
<span style="color: #0000FF">
<pre>
 BLK UPDATE ADDRESS
</pre>
</span>

After the .RELOC directive, it is possible to specify a relocation block type (.BYTE, .WORD),
with the default being .WORD type. Type .BYTE is for blocks that must be placed
in zero page (instructions will use zero page), which MADS will assemble to address <b>$0000</b>.
Type .WORD means that MADS will assemble the block starting at address <b>$0100</b> and that it
can be placed anywhere in memory (except for zero page).

<p>
The .RELOC block produces a header like the famous DOS header, further expanded by 10 bytes
to a total of 16 bytes:
</p>

<span style="color: #0000FF">
<pre>
HEADER            .WORD = $FFFF
START_ADDRESS     .WORD = $0000
END_ADDRESS       .WORD = FILE_LENGTH-1
MADS_RELOC_HEADER .WORD = $524D
UNUSED            .BYTE = $00
CONFIG            .BYTE (bit0)
@STACK_POINTER    .WORD
@STACK_ADDRESS    .WORD    
@PROC_VARS_ADR    .WORD
</pre>
</span>


<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><tt><b>MADS_RELOC_HEADER</b> </td>
	<td><tt>always $524D, corresponding to the characters 'MR' (M-ADS R-ELOC)</td>
</tr>
<tr>
	<td><tt><b>FILE_LENGTH</b></td>
	<td><tt>the length of the relocatable file without the 16-byte header</td>
</tr>
<tr>
	<td><tt><b>CONFIG</b></td>
	<td><tt>currently only bit 0 is used, where bit0=0 means relocatable blocks are assembled starting at <b>$0000</b>, and bit0=1 means blocks are assembled at <b>$0100</b>.</td>
</tr>
</table>

<p>
The last 6 bytes contain information about the values of labels needed for
the operation of the software stack, <b>@STACK_POINTER, @STACK_ADDRESS, and @PROC_VARS_ADR</b>,
if used in relocatable blocks. If the individual .RELOC blocks were assembled with
different values of these labels, linking them together will produce an <b>Incompatible stack parameters</b>
warning. If the software stack labels are not used, the values
are zero.
</p>

<p>
The pseudo-command .RELOC switches MADS to relocatable code generation mode, taking into
account the operand sizes of 6502 and 65816 instructions. In this mode, it is impossible
to use the <b>ORG, LMB, NMB, and RMB</b> psuedo-instructions or the 
<b>.DS</b> directive. It is impossible to exit MADS relocatable code generation mode,
but it is possible to have more than one .RELOC block.
</p>

<p>
Using the .RELOC directive will also increase the MADS virtual bank counter, and thus
create a local scope not visible to other blocks. For more information on virtual banks,
see the section <a href="#banks_wir">Virtual memory banks (OPT B-)</a>.
</p>


<p>
At the end of a .RELOC block it is necessary to generate an update block, using the
same BLK syntax for SDX relocatable blocks ("BLK UPDATE ADDRESS"). The
encoding format for this block is different than for SDX and is as follows:
</p>

<span style="color: #0000FF">
<pre>
HEADER       WORD ($FFEF)
TYPE         CHAR (B-YTE, W-ORD, L-ONG, D-WORD, &lt;, &gt;)
DATA_LENGTH  WORD
DATA         WORD [BYTE]
</pre>
</span>


<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><tt><b>HEADER</b></td>
	<td><tt>always set to $FFEF</td>
</tr>
<tr>
	<td><tt><b>TYPE</b></td>
	<td><tt>data type is stored in bits 0..6 and specifies the type of addresses to update,
	where "&lt;" means the lower address byte and "&gt;" means the upper address byte.</td>
</tr>
<tr>
	<td><tt><b>DATA_LENGTH</b></td>
	<td><tt>number of 2-byte data items (addresses) to modify</td>
</tr>
<tr>
	<td><tt><b>DATA</b></td>
	<td><tt>offsets for updating the relocatable block, where at each address a value of type TYPE is read and then updated to the final address</td>
</tr>
</table>

<p>
The exception is an update block for address high bytes "&gt;", where for such a block
an extra BYTE is stored for each address (low byte of address being modified). To
adjust the high bytes, the high byte has to be read from the WORD address in the DATA,
added to the current relocation address, and then added to the low byte in the BYTE field of the DATA.
The newly calculated byte is then store back at the WORD address in the DATA.
</p>
<br />



<A NAME="labels_ext">
<u><tt><h2>External symbols</h2></tt></u>

<p>
External symbols indicate that the represented variables and procedures are stored
somewhere outside, beyond the current program. The location need not be specified, only
the names and the types. Since the translation of instructions to appropriate machine code
depends on the type of data represented by a symbol, the assembler needs to know the
size of the data used.
</p>

<b>Currently there is no support for manipulating external symbols of type '^' (highest byte).</b>


<p>
External symbosl may be used in both relocatable .RELOC blocks as well as usual DOS ones.
</p>

External symbols are declared using the pseudo-instruction EXT or the .EXTRN directive:
<span style="color: #0000FF">
<pre>
label EXT type
label .EXTRN type
.EXTRN label1,label2,label3... type
</pre>
</span>

An update block for referencing external symbols is produced using the BLK psuedo-instruction:
<span style="color: #0000FF">
<pre>
 BLK UPDATE EXTERNAL
</pre>
</span>

<b>NOTE:</b> <u>This will write symbol names used by the program.</u>.

<p>
External symbols of value type can also be defined (<tt>.BYTE, .WORD, .LONG , .DWORD</tt>):

<span style="color: #0000FF">
<pre>
name EXT .BYTE

label_name EXT .WORD

 .EXTRN label_name .WORD

wait EXT .PROC (.BYTE delay)
</pre>
</span>

External symbol declarations of procedure (.PROC) type default to .WORD, and attempts to
reference the label will be interpreted by MADS as an attempt to call the procedure.
For more about procedure calls, see <a href="#procs">Procedures</a>.
</p>

During the assembly process, references to external symbols are replaced with the value zero.

<p>
External symbols can be useful when assembling part of a program separately from the rest of it.
In this case, there are often references to other procedures and variables are defined
elsewhere, and only the type and not value are known. With the help of external symbols, such
a program can be assembled without the full procedure and variable definitions.
</p>

<p>
Another use for external symbols is for "plugins", or external programs connected to the
main program to add additional functionality. These are types of libraries, using the
procedures of the main program and expanding its capabilities. Creating such a plugin
requires determining what procedures the main program provides (their name + parameters
and type), and a procedure to read the file from the external symbols, which then
attaches the plugins to the main program.
</p>

<p>
The following is the format of the file header produced by BLK UPDATE EXTERNAL
for external symbols of type B-YTE, W-ORD, L-ONG, and D-WORD:
</p>

<span style="color: #0000FF">
<pre>
HEADER        WORD ($FFEE)
TYPE          CHAR (B-YTE, W-ORD, L-ONG, D-WORD, &lt;, &gt;)
DATA_LENGTH   WORD
LABEL_LENGTH  WORD
LABEL_NAME    ATASCII
DATA          WORD .. .. ..
</pre>
</span>


<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><tt><b>HEADER</b> </td>
	<td><tt>always set to $FFEE</td>
</tr>
<tr>
	<td><tt><b>TYPE</b></td>
	<td><tt>bits 0..6 contain the type of data to modify</td>
</tr>
<tr>
	<td><tt><b>DATA_LENGTH</b> </td>
	<td><tt>number of 2-byte data items (addresses) to modify</td>
</tr>
<tr>
	<td><tt><b>LABEL_LENGTH</b> </td>
	<td><tt>symbol name length in bytes</td>
</tr>
<tr>
	<td><tt><b>LABEL_NAME</b></td>
	<td><tt>the symbol name, coded in ATASCII</td>
</tr>
<tr>
	<td><tt><b>DATA</b> </td>
	<td><tt>offset data for the relocation process. At each indicated address here, the value of type TYPE is read and then based on the actual value of the symbol.</td>
</tr>
</table>


<p>
<A NAME="_prz_str">
An applied example of external symbols and .STRUCT structures is the graphical
primitives library in the directory ..\EXAMPLES\LIBRARIES\GRAPHICS\LIB. Individual
modules use a fairly large number of zero page variables, and if we want to place these
in relocatable code each individual variable would have to be declared as an external
symbol by EXT (or .EXTRN). We can simplify this by using only one symbol and external
data of structure (.STRUCT) type. These structures define a "map" of variables called
ZP and one ZPAGE external symbol, of type .BYTE because we want it to be in zero page.
Now, when referring to the variable, we need to do it in a way that forces relocation
such as ZPAGE + ZP.DX. The result is a fully relocatable module with relocated variables
in zero page.
</p>
<br />



<A NAME="labels_pub">
<u><tt><h2>Public symbols</h2></tt></u>

<p>
Public symbols make variables and procedures available to other blocks in the rest
of the relocatable assembly program. With public symbols, you can refer to variables
and procedures from libraries.
</p>

<p>
Public symbols can be used in relocatable .RELOC blocks as well as usual DOS blocks.
</p>


<p>
MADS automatically detects whether a public label is a variable, constant, or
procedure defined by .PROC, and does not need any additional information as for
external symbols.
</p>

Public symbols are declared using the following directives:
<span style="color: #0000FF">
<pre>
 .PUBLIC label [,label2,...]
 .GLOBAL label [,label2,...]
 .GLOBL label [,label2,...]
</pre>
</span>

The directives .GLOBAL and .GLOBL have been added for compatibility with other
assemblers. They are identical in meaning to .PUBLIC directive.
    <p></p>

Update blocks for public symbols are created using the BLK pseudo-command:
<span style="color: #0000FF">
<pre>
 BLK UPDATE PUBLIC
</pre>
</span>

<p>
Below is the header format produced by BLK UPDATE PUBLIC:
</p>

<span style="color: #0000FF">
<pre>
HEADER        WORD ($FFED)
LENGTH        WORD
TYPE          BYTE (B-YTE, W-ORD, L-ONG, D-WORD)
LABEL_TYPE    CHAR (C-ONSTANT, V-ARIABLE, P-ROCEDURE, A-RRAY, S-TRUCT)
LABEL_LENGTH  WORD
LABEL_NAME    ATASCII
ADDRESS       WORD
</pre>
</span>

MADS automatically selects the appropriate type for public labels:
<pre>
<span style="color: #0000FF"><li>C-ONSTANT</li></span>  label is not subject to relocation
<span style="color: #0000FF"><li>V-ARIABLE</li></span>  label is subject to relocation
<span style="color: #0000FF"><li>P-ROCEDURE</li></span> procedura defined by .PROC, subject to relocation
<span style="color: #0000FF"><li>A-RRAY</li></span>     array defined by .ARRAY, subject to relocation
<span style="color: #0000FF"><li>S-TRUCT</li></span>    structure defined by .STRUCT, not subject to relocation
</pre>

If the symbol is of structure (.STRUCT) type, this additional information is saved
(the type of the structure, name of the structure, and number of elements of
the structure):
<span style="color: #0000FF">
<pre>
STRUCT_LABEL_TYPE    CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
STRUCT_LABEL_LENGTH  WORD
STRUCT_LABEL_NAME    ATASCII
STRUCT_LABEL_REPEAT  WORD
</pre>
</span>

If the symbol is of array (.ARRAY) type, this additional information is saved
(maximum element index, declared element type):
<span style="color: #0000FF">
<pre>
ARRAY_MAX_INDEX  WORD
ARRAY_TYPE       CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
</pre>
</span>

If the symbol is of procedure (.PROC) type, this additional information is saved,
regardless of whether the procedure does or does not declare parameters:
<span style="color: #0000FF">
<pre>
PROC_CPU_REG  BYTE (bits 00 - regA, 01 - regX, 10 - regY)
PROC_TYPE     BYTE (D-EFAULT, R-EGISTRY, V-ARIABLE)
PARAM_COUNT   WORD
</pre>
</span>

<p>
.REG symbols of the procedure are then included, of PARAM_COUNT count:
</p>

<span style="color: #0000FF">
<pre>
PARAM_TYPE    CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
...
...
</pre>
</span>


<p>
.VAR symbols of the procedure are included next along with their names, where
PARAM_COUNT specifies the total length of the data:
</p>


<span style="color: #0000FF">
<pre>
PARAM_TYPE    CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
PARAM_LENGTH  WORD
PARAM_NAME    ATASCII
...
...
</pre>
</span>




<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><tt><b>HEADER</b></td>
	<td><tt>always set to $FFED</td>
</tr>
<tr>
	<td><tt><b>LENGTH</b> </td>
	<td><tt>number of symbols stored in the update block</td>
</tr>
<tr>
	<td><tt><b>TYPE</b></td>
	<td><tt>type of symbol data: B-YTE, W-ORD, L-ONG, D-WORD</td>
</tr>
<tr>
	<td><tt><b>LABEL_TYPE</b></td>
	<td><tt>symbol type: V-ARIABLE, C-ONSTANT, P-ROCEDURE, A-RRAY, S-TRUCT
	<br />
	For type P, additional stored information: PROC_CPU_REG, PROC_TYPE, PARAM_COUNT, PARAM_TYPE
	<br />
   For type A, additional stored information: ARRAY_MAX_INDEX, ARRAY_TYPE
   <br />
   For type S, additional stored information: STRUCT_LABEL_TYPE, STRUCT_LABEL_LENGTH, STRUCT_LABEL_NAME, STRUCT_LABEL_REPEAT 
	</td>
</tr>
<tr>
	<td><tt><b>LABEL_LENGTH</b> </td>
	<td><tt>public symbol name length in bytes</td>
</tr>
<tr>
	<td><tt><b>LABEL_NAME</b> </td>
	<td><tt>public symbol name stored as ATASCII</td>
</tr>
<tr>
	<td><tt><b>ADDRESS</b></td>
	<td><tt>address assigned to the symbol in the relocatable .RELOC block. This value is relocated by adding its current assembly address.</td>
</tr>
<tr>
	<td><tt><b>PROC_CPU_REG</b></td>
	<td><tt>information about the .REG CPU register usage records for a procedure</td>
</tr>
<tr>
	<td><tt><b>PROC_TYPE</b></td>
	<td><tt>type of procedure:<br />
<li>D-EFAULT default type: parameters passed using MADS software stack
<br />
<li>R-EGISTRY: procedure parameters passed using CPU registers (.REG)
<br />
<li>V-ARIABLE: procedure parameters passed by variables (.VAR)</td>
</tr>
<tr>
	<td><tt><b>PARAM_COUNT</b></td>
	<td><tt>information about the number of register-passed parameters (.REGs) or total length of type and name data for variable-passed parameters (.VARs)</td>
</tr>
<tr>
	<td><tt><b>PARAM_TYPE</b></td>
	<td><tt>parameter types, recorded using the characters 'B', 'W', 'L', 'D'</td>
</tr>
<tr>
	<td><tt><b>PARAM_LENGTH</b></td>
	<td><tt>parameter name length (.VAR)</td>
</tr>
<tr>
	<td><tt><b>PARAM_NAME</b></td>
	<td><tt>parameter name coded as ATASCII (.VAR)</td>
</tr>
</table>

<p></p>
<br />




<A NAME="_link">
<u><tt><h2>Linking (.LINK)</h2></tt></u>

<span style="color: #0000FF">
<pre>
 .LINK 'filename'
</pre>
</span>

The directive .LINK requires as a parameter the filename of the file to link. Only Atari DOS files
are accepted, not SDX files.

<p>
If the file load address is different than <b>$0000</b>, it means that the file does not contain
relocatable code, but may include update blocks for external and public symbols. The .LINK directive
accepts files at any address, but only those starting at <b>$0000</b> are subject to relocation.
More information on how to construct such a file is included in the section <A HREF="#_reloc">Relocatable blocks (.RELOC)</A>. 
</p>

<p>
The .LINK directive allows linking of relocatable and non-relocatable code. MADS automatically
relocates the file based on all three types of update blocks (ADDRESS, EXTERNAL, PUBLIC).
</p>

There is no limit to the address at which a file can be relocated.

<p>
If a block being relocated requires the MADS software stack, the labels @STACK_POINTER,
@STACK_ADDRESS, and @PROC_VARS_ADR are automatically updated based on the .RELOC block header.
It is necessary that the main program and the .RELOC blocks operate on the same software stack.
</p>

<br />




<A NAME="mnemo">
<p class="duzy">
MNEMONICS
</p>


<A NAME="8bit">
<u><tt><h2>Available 6502 opcodes</h2></tt></u>

<span style="color: #0000FF">
<pre>
   LDA   LDX   LDY   STA   STX   STY   ADC   AND  
   ASL   SBC   JSR   JMP   LSR   ORA   CMP   CPY  
   CPX   DEC   INC   EOR   ROL   ROR   BRK   CLC  
   CLI   CLV   CLD   PHP   PLP   PHA   PLA   RTI  
   RTS   SEC   SEI   SED   INY   INX   DEY   DEX  
   TXA   TYA   TXS   TAY   TAX   TSX   NOP   BPL  
   BMI   BNE   BCC   BCS   BEQ   BVC   BVS   BIT  
</pre>
</span>

A mnemonic extension can be placed after a dot <tt>'.'</tt> for LDA, LDX, LDY, STA, STX, and STY:
<pre>
   <b>.b</b> or <b>.z</b>                BYTE
   <b>.a</b> or <b>.w</b> or <b>.q</b>   WORD

e.g.:
   lda.w $80   ; AD 80 00
   lda   $80   ; A5 80
</pre>
<br />


<A NAME="8bit_ill">
<u><tt><h2>Available illegal 6502 opcodes</h2></tt></u>

<span style="color: #0000FF">
<pre>
   ASO   RLN   LSE   RRD   SAX   LAX   DCP   ISB
   ANC   ALR   ARR   ANE   ANX   SBX   LAS   SHA
   SHS   SHX   SHY   NPO   CIM
</pre>
</span>
<br />



<A NAME="16bit">
<p>
<u><tt><h2>Available 65816 opcodes</h2></tt></u>
</p>

Of course, all <tt>6502</tt> opcodes are available, as well as:

<span style="color: #0000FF">
<pre>
   STZ   SEP   REP   TRB   TSB   BRA   COP   MVN  
   MVP   PEA   PHB   PHD   PHK   PHX   PHY   PLB  
   PLD   PLX   PLY   RTL   STP   TCD   TCS   TDC  
   TSC   TXY   TYX   WAI   WDM   XBA   XCE   INA
   DEA   BRL   JSL   JML
</pre>
</span>

It is possible to use XASM-style a:, z:, and r: mnemonic extensions:
<pre>
 XASM        MADS
 lda a:0     lda.a 0
 ldx z:0     lda.z 0

 org r:$40   org $40,*
</pre>

Mnemonic extensions can be placed after a dot (<tt>'.'</tt>) for LDA, LDX, LDY, STA, STX, and STY:
<pre>
   <b>.b</b> or <b>.z</b>                BYTE
   <b>.a</b> or <b>.w</b> or <b>.q</b>   WORD
   <b>.t</b> or <b>.l</b>                TRIPLE, LONG (24bit)

e.g.:
   lda.w #$00   ; A9 00 00
   lda   #$80   ; A9 80
</pre>

<p>
The following commands cannot have their operand given in absolute addressing form (some assemblers
do not require the <tt>'#'</tt> character, but <tt>MADS</tt> requires it):
</p>

<tt><h3>#$xx</h3></tt>
<pre>
   SEP   REP   COP
</pre>

<tt><h3>#$xxxx</h3></tt>
<pre>
   PEA
</pre>

<p>
Another exception is long indirect addressing mode, which is represented by square brackets <tt>[ ]</tt>.
These brackets are used to group subexpressions, but if the assembler encounters the character
<tt>'['</tt> first it is interpreted as the start of long indirect addressing, and if <tt>65816</tt> mode
is not enabled a <b><tt>Illegal adressing mode</tt></b> results. To "trick" the assembler, place
the character <tt>'+'</tt> before the <tt>'['</tt>.
</p>

<span style="color: #0000FF">
<pre>
 lda [2+4]     ; lda [6]
 lda +[2+4]    ; lda 6
</pre>
</span>
<br />




<A NAME="det_cpu">
<p class="duzy">
CPU DETECTION
</p>


<u><tt><h2>Detecting the 6502 and 65816 CPUs</h2></tt></u>

This example is taken from <A HREF="http://www.s-direktnet.de/homepages/k_nadj/cputest.html"> http://www.s-direktnet.de/homepages/k_nadj/cputest.html</A>.
The program is able to detect the presence of the following microprocessors: <tt>6502</tt>, <tt>65C02</tt>, and <tt>65816</tt>.

<span style="color: #0000FF">
<pre>
/*

How to detect on which CPU the assembler code is running

(This information is from Draco, the author of SYSINFO 2.0)

You can test on plain 6502-Code if there is a 65c816 CPU, the 16-Bit processor avaible
in some XLs as a turbo-board, avaible. Draco told me how to do this:

First we make sure, whether we are running on NMOS-CPU (6502) or CMOS (65c02,65c816).
I will just show the "official" way which doesn`t uses "illegal opcodes":

*/

 org $2000

 opt c+

DetectCPU

 lda #$99
 clc
 sed
 adc #$01
 cld
 beq DetectCPU_CMOS

DetectCPU_02

 ldx #<_6502
 ldy #>_6502
 jsr $c642

 lda #0
 rts

DetectCPU_CMOS

 lda #0
 rep #%00000010		;reset Z bit
 bne DetectCPU_C816

DetectCPU_C02

 ldx #<_65c02
 ldy #>_65c02
 jsr $c642

 lda #1
 rts

DetectCPU_C816

 ldx <_65816
 ldy >_65816
 jsr $c642

 lda #$80
 rts

_6502   dta c'6502',$9b
_65c02  dta c'65c02',$9b
_65816  dta c'65816',$9b
</pre>
</span>

<br />

The next CPU detection example is limited to distinguishing a <tt>6502</tt> from a <tt>65816</tt>
microprocessor. The program instructions are read differently by a <tt>6502</tt> than by a <tt>65816</tt>.
A <tt>6502</tt> executes <tt>'inc @'</tt> and a <tt>'nop'</tt> instead of <tt>'xba'</tt> followed by <tt>'sbc #'</tt>.
With this "transparency" we can be assured that the program does not perform illegal operations and
correctly recognizes the correct CPU. The idea for this concise and very clever test comes from
Ullrich von Bassewitz.

<span style="color: #0000FF">
<pre>
 org $2000

 opt c+                 ; 65816 enabled

 lda #0
 
 inc @                  ; increment accumulator
 
 cmp #1
 bcc cpu6502

; ultimate test for 65816 presence

 xba           ; put $01 in B accu
 dec @         ; A=$00 if 65C02
 xba           ; get $01 back if 65816
 inc @         ; make $01/$02
 
 cmp #2
 bne cpu6502

cpu65816

 ldx &lt;text65816
 ldy &gt;text65816
 jsr $c642
 rts
 
cpu6502

 ldx &lt;text6502
 ldy &gt;text6502
 jsr $c642
 rts

text6502  dta c'6502',$9b
text65816 dta c'65816',$9b
</pre>
</span>
<br />



<A NAME="banks">
<p class="duzy">
MEMORY BANKS
</p>

For probably anyone who has ever worked with the 8-bit Atari architecture, the term "memory bank"
is associated with extended memory, divided into 16KB size banks, and switched in the address
range <tt>&lt;$4000..$7FFF&gt;</tt>.
<p></p>

<tt>MADS</tt> can interpret banks this way (option <b><tt>OPT B+</tt></b>, <A HREF="#banks_spr">Hardware memory banks</A>),
but by default they are interpreted as virtual banks (option <b><tt>OPT B-</tt></b>, <A HREF="#banks_wir">Virtual memory banks</A>).

<p></p>

The following pseudo commands apply to banks:
<span style="color: #0000FF">
<pre>
 LMB #value
 NMB
 RMB
</pre>
</span>


<A NAME="_lmb">
<p></p>
<tt><h3>LMB # (Load Memory Bank)</h3></tt>
Sets the <tt>MADS</tt> bank counter to a value in the range <tt>&lt;$00..$FF&gt;</tt> (BANK = value):
<span style="color: #0000FF">
<pre>
 lmb #0
 lmb #bank
 lmb #5 , $6500      ; only with OPT B+
</pre>
</span>

<A NAME="_nmb">
<p></p>
<tt><h3>NMB (Next Memory Bank)</h3></tt>
Increments the <tt>MADS</tt> bank counter (BANK = BANK + 1).
<span style="color: #0000FF">
<pre>
 nmb
 nmb  $6500          ; only with OPT B+
</pre>
</span>

<A NAME="_rmb">
<p></p>
<tt><h3>RMB (Reset Memory Bank)</h3></tt>
Resets the <tt>MADS</tt> bank counter (BANK = 0).
<span style="color: #0000FF">
<pre>
 rmb
 rmb $3500           ; only with OPT B+
 rmb $8500           ; only with OPT B+
</pre>
</span>

<br />


During assembly, <tt>MADS</tt> assigns the current bank counter value to each newly defined
label. The programmer can affect the value of the bank counter through pseudo commands.

<p>
<li>Labels assigned with the <tt>MADS</tt> bank counter <b>=0</b> are <tt><b>global</b></tt>.
<li>Labels assigned with the <tt>MADS</tt> bank counter <b>&gt;0</b> are <tt><b>local</b></tt>.
</p>

<br />



<A NAME="banks_wir">
<u><tt><h2>Virtual memory banks (OPT B-)</h2></tt></u>

<p>
In <tt>MADS</tt>, the term "virtual memory bank" refers to any area designated by a newly defined
label set to the current value of the bank counter (the default bank counter is zero). That is,
a virtual memory bank is not necessary a memory area in the range <tt>&lt;$4000..$7FFF&gt;</tt>,
but each label presents a code area of the program which has been assigned a code (bank counter value)
in the range <b><tt>&lt;$00..$FF&gt;</tt></b> with appropriate pseudo-commands for use by the programmer
(<tt>NMB, RMB, LMB</tt>).
</p>

<p>
The exceptions are .RELOC blocks, where the bank counter cannot be changed manually and is
automatically updated by MADS, incrementing it for each instance of the .RELOC directive.
Bank counter values are in the range <b>&lt;$0001..$FFF7&gt;</b>.
</p>

The programmer can read the bank counter value associated with a label using the equal operator <tt>'='</tt>:
<span style="color: #0000FF">
<pre>
label

 ldx #=label
</pre>
</span>

In this example, the <tt><b>X</b></tt> CPU register is set to the bank counter value associated
by <tt>MADS</tt> with the label <tt>LABEL</tt>.

<p></p>

Another useful operator is the colon (<tt>':'</tt>) placed at the beginning of the label name,
which causes <tt>MADS</tt> to allow references to labels outside of the area specified by the
current <tt>MADS</tt> bank counter. Sometimes this may cause problems, such as if
there is more than one label with the same name in different local scopes or in areas with
a different virtual bank number.

<span style="color: #0000FF">
<pre>
 lmb #5

label5
 nop

 lmb #6

label6
 nop

 lda :label5
</pre>
</span>

In this example, without the operator <tt>':'</tt> at the beginning of the label name in the instruction
<tt>'lda :label5'</tt> the error <tt><b>ERROR: Undeclared label LABEL5 (BANK=6)</b></tt> would result.

<p></p>
Virtual memory banks can be used to index an array containing values for the <tt>PORTB</tt> register.
This is the main use of the option <b><tt>OPT B+</tt></b>.
<p></p>
<br />



<A NAME="banks_spr">
<u><tt><h2>Hardware memory banks (OPT B+)</h2></tt></u>

This mode of operation can be called "bank sensitive".

<p></p>

Hardware banks are an extension of virtual memory banks and are understood by <tt>MADS</tt>
as expanded memory banks in the range <tt>&lt;$4000..$7FFF&gt;</tt>. The pseudo commands <tt>NMB, RMB, and LMB</tt>
are extended to call the macro <tt>@BANK_ADD</tt>, which can be found in <tt>..\EXAMPLES\MACROS\</tt>.

<p></p>
In this mode of operation, <tt>MADS</tt> requires the definitions for the following macros:
<span style="color: #0000FF">
<pre>
 @BANK_ADD
 @BANK_JMP
</pre>
</span>

and requires label definitions with the names:

<span style="color: #0000FF">
<pre>
@TAB_MEM_BANKS
@PROC_ADD_BANK
</pre>
</span>

The <tt><b>@TAB_MEM_BANKS</b></tt> label specifies the address of an array with values to
write to the PORTB register for switching extended memory banks. You can take advantage
of pre-written expanded memory bank detection routines included with <tt>MADS</tt>, in <tt>..\EXAMPLES\PROCEDURES\@MEM_DETECT.ASM</tt>.

<p></p>
The label <tt><b>@PROC_ADD_BANK</b></tt> is used by the macro <tt>@BANK_ADD</tt> and defines
the address of the code for switching extended memory banks.

<p></p>

The programmer can read the bank counter value associated with a label using the <tt>'='</tt> operator:
<span style="color: #0000FF">
<pre>
label

 ldy #=label
</pre>
</span>

In this example, the <tt>Y</tt> register is set to the memory bank value associated with the
label <tt>LABEL</tt> by <tt>MADS</tt>.


<p></p>
<u>If the <tt>MADS</tt> bank counter = 0:</u>
<li>program code must be placed outside of <b>&lt;$4000..$7FFF&gt;</b>
<li>newly defined labels in this area are global
<li>all defined labels can be accessed without limitation, regardless of bank number
<li>jumping into a bank is possible using the macro <b>@BANK_JMP</b> (..\EXAMPLES\MACROS\@BANK_JMP.MAC); the parameter
for this macro does not have to be preceded by the ':' operator


<p></p>
<u>If the <tt>MADS</tt> bank counter &gt; 0:</u>
<li>program code must be within <b>&lt;$4000..$7FFF&gt;</b>
<li>newly defined labels in this area are local
<li>only global labels and labels within the current bank can be accessed
<li>the pseudo-commands LMB and NMB will call the macro <b>@BANK_ADD</b>, which creates a new
bank with the MADS extended memory bank counter and sets a new assembly address (defaults to <b>$4000</b>)
<li>the pseudo-command RMB resets the MADS memory bank counter and sets a new assembly address outside of the bank (defaults to <b>$8000</b>)
<li>jumping to another bank is possible using the macro <b>@BANK_JMP</b> (..\EXAMPLES\MACROS\@BANK_JMP); the parameter
for this macro does not have to be preceded by the ':' operator

<p>
An example of the use of MADS bank sensitive mode can be found in the file <tt>..\EXAMPLES\XMS_BANKS.ASM</tt>.
In this example, the program code is located in two different extended memory banks and runs as if it
were a single program.
</p>

<p></p>
<br />


</div>

</tt>


<A NAME="zmiany">
</tt><h2>HISTORY</h2></tt>

<p class="tekst-wiekszy">
v1.9.5
<p class="tekst">
- added pseudo-command SET to redefine labels, with a similar effect as temporary labels that begin with '?', e.g.:
<pre>
temp set 12

     lda #temp

temp set 23

     lda #temp
</pre>
<p class="tekst">
- added ability to force addressing mode in XASM-style ('a:', 'z:'):
<pre>
 XASM        MADS
 lda a:0     lda.a 0
 ldx z:0     lda.z 0
</pre>
<p class="tekst">
- added ability to specify a new code relocation address in XASM-style ('r:'):
<pre>
 XASM        MADS
 org r:$40   org $40,*
</pre>
<p class="tekst">
- improved performance of '-x Exclude unreferenced procedures' switch; .VAR variables are not allocated for unused procedures<br>
- extended single-line syntax for :rept loops so that the loop counter can now be used as a parameter :1 (%%1):
<pre>
line0
line1
line2
line3

ladr :4 dta l(line:1)
hadr :4 dta h(line:1)
</pre>
<p class="tekst">
- added a warning message when unstable illegal 6502 opcodes are used, i.e. CIM<br>
- added new functionality to pseudo-opcodes RUN and INI to retain the previous assembly address when assembling to $2E0 (RUN), $2E2 (INI)<br>
- added support for anonymous labels @, @+[1..9] (forward), @-[1..9] (backward); for clarity, their use is limited only to conditional branches no more than 10 instances away:
<pre>
@ dex   ---- -------
  bne @+   |  --   |
  stx $80  |   |   |
@ lda #0   |  --   |
  bne @- ---       |
  bne @-1  ---------
</pre>
<p class="tekst">
- extended directives #IF and #WHILE to allow arguments declared by .VAR, whereas previously only a variable was allowed:
<pre>
 .var temp .word

 #if temp>#2100
 #end

 #if .word temp>#2100
 #end
</pre>


<p class="tekst-wiekszy">
v1.9.4
<p class="tekst">
- dodana normalizacja ¶cie¿ek dla plików, tak aby dzia³a³y pod Unixami, znaki '\' zamieniane s± na '/'<br>
- poprawione przekazywanie dyrektyw jako parametrów do procedur i makr, dyrektywy nie by³y rozpoznawane przy w³±czonym prze³±czniku -c (case sensitive)<br>
- poprawione dzia³anie .USE [.USING]<br>
- dodana informacja w postaci ostrze¿enia (WARNING) o etykiecie powoduj±cej nieskoñczon± ilo¶æ przebiegów asemblacji (INFINITE LOOP)<br>
- dodany zapis dwóch bajtów nag³ówka FF FF dla pliku zawieraj±cego blok o adresie ³adowania $FFFF<br>
- komentarze po mnemonikach nie wymagaj±cych argumentu zostan± potraktowane jako b³±d, wyj±tkiem jest ³±czenie rozkazów w stylu xasm poprzez znak ':', np.:
<pre>
 pla $00          ->  ERROR: Extra characters on line
 pha:pla $00      ->  OK
</pre>
<p class="tekst">
- rozszerzona sk³adnia makr o mo¿liwo¶æ u¿ywania parametrów w postaci nazw a nie tylko warto¶ci numerycznych-decymalnych, np.:
<pre>
.macro SetColor val,reg
 lda :val
 sta :reg
.endm

.macro SetColor2 (arg1, arg2)
 lda #:arg1
 sta :arg2
.endm
</pre>
<p class="tekst">
- naprawione definiowanie etykiet dla n/w sytuacji, pierwsza etykieta nie zostanie zignorowana
<pre>
temp  label = 100
</pre>


<p class="tekst-wiekszy">
v1.9.3
<p class="tekst">
- poprawione przetwarzanie bloków .PROC, które w pewnych okoliczno¶ciach mog³y zostaæ pominiête podczas asemblacji<br>
- poprawiony zapis BLK EMPTY dla plików SDX je¶li zastosowali¶my deklaracjê takiego bloku przez .DS<br>
- poprawki dotycz±ce testowania koñca linii<br>
- dodane dyrektywy .FILESIZE, .SIZEOF jako odpowiednik dotychczasowej dyrektywy .LEN<br>
- rozszerzona sk³adnia dla pól struktury .STRUCT, np.:
<pre>
.struct name
 .byte label0
 .byte :5 label1
 label2 .byte
 label3 :2 .word
.ends
</pre>


<p class="tekst-wiekszy">
v1.9.2
<p class="tekst">
- mo¿liwo¶æ okre¶lenia adresu dla .ZPVAR = $XX<br>
- usprawnione odwo³ania do etykiet wyliczeniowych .ENUM, np. enum_label(field0, field1)<br>
- dodana mo¿liwo¶æ generowania bloku dla symboli zewnêtrznych BLK UPDATE EXTRN dla plików DOS-a, poprzednio tylko dla plików .RELOC, np.:
<pre>
  .extrn vbase .word
  org $2000
  lda #$80
  sta vbase+$5d

  blk update extrn
</pre>
<p class="tekst">
- dodany komunikat b³êdu "Could not use NAME in this context" w przypadku rozkazów odwo³añ do bloków .MACRO, .ENUM, .STRUCT<br>
- poprawiony b³±d który uniemo¿liwia³ u¿ycie 'EQU' w nazwie etykiety<br>
- dodana dyrektywa .CB +byte,....., ostatni bajt ci±gu znakowego zapisywany jest w inwersie<br>
- dodana obs³uga segmentów poprzez dyrektywy .SEGDEF, .SEGMENT, .ENDSEG<br>
- dodana nowa dyrektywa #CYCLE #N generuj±ca kod 6502 o zadanej liczbie cykli N<br>
- dodana obs³uga nielegalnych rozkazów CPU 6502, przyk³ad w pliku ..\examples\test6502_illegal.asm<br>
- uaktualnione pliki konfiguracyjne dla Notepad++ '..\syntax\Notepad++'<br>
- poprawiony zapis pliku LST<br>
- naprawiona alokacja pamiêci dla zmiennych strukturalnych, rozszerzona sk³adnia dla .STRUCT
<pre>
.struct LABEL
 x,y,z .word     // wiele zmiennych tego samego typu w jednej linii
 .byte a,b
.ends

.enum type
  a=1,b=2
.ende

.struct label2
  x type
  type y
.ends
</pre>


<p class="tekst-wiekszy">
v1.9.0
<p class="tekst">
- naprawiony zapis linii z komentarzem  /* */ do pliku listingu *.LST, poprzednio takie linie nie by³y zapisywane<br>
- poprawka dla etykiet deklarowanych z linii komend -d:label, poprzednio takie etykiety widziane by³y tylko w pierwszym przebiegu<br>
- w przypadku addytywno¶ci bloków .LOCAL tylko pierwszy adres z takich bloków jest zapisywany<br>
- poprawki dotycz±ce parsowania makr, poprzednio etykiety zaczynaj±ce siê od END mog³y zostaæ zinterpretowane jako pseudo rozkaz END<br>
- poprawka odczytu dla pustego pliku relokowalnego, poprzednio wystêpowa³ b³±d 'Value out of range'<br>
- poprawki dla .USING (.USE)


<p class="tekst-wiekszy">
v1.8.8 - 1.8.9
<p class="tekst">
- uaktualniony silnik duchów programowych ..\EXAMPLES\SPRITES\CHARS o duchy 8x24<br>
- w przypadku braku podania rozszerzenia pliku i braku istnienia takiego pliku dla ICL 'filename' zostanie domy¶lnie przyjête rozszerzenie *.ASM ICL 'filename.asm'<br>
- poprawione dzia³anie komentarzy /* */ w blokach .MACRO i .REPT<br>
- usuniêty b³±d uniemo¿liwiaj±cy poprawn± asemblacjê bloku #IF, #WHILE dla wyra¿eñ ³±czonych przez .OR, .AND<br>
- prze³±czniki w linii komend mog± byæ poprzedzone tylko znakiem '-', poprzednio tak¿e '/' jednak by³y problemy z dzia³aniem tego znaku na MacOSX<br>
- poprawiony zakres dzia³ania dyrektywy .USING, dla aktualnej przestrzeni nazw i kolejnych zawieraj±cych siê w tej przestrzeni nazw

<p class="tekst-wiekszy">
v1.8.6 - 1.8.7
<p class="tekst">
- usprawnione rozpoznawanie komentarzy /* */ w wyra¿eniach<br>
- domy¶lny adres dla .ZPVAR ustawiony na $0080, poprzednio $0000<br>
- dodana nowa dyrektywa .ELIF jako krótszy odpowiednik dyrektywy .ELSEIF<br>
- rozszerzone dzia³anie dyrektywy .LEN o mo¿liwo¶æ podania jako parametru nazwy pliku, zwracana jest wówczas d³ugo¶æ takiego pliku<br>
- usprawnione dzia³anie dyrektywy .DEF w wyra¿eniach warunku .IF (.IFDEF, .IFNDEF)

<p class="tekst-wiekszy">
v1.8.5
<p class="tekst">
- dodane makro relokuj±ce modu³y RMT ...\EXAMPLES\MSX\RMT_PLAYER_RELOCATOR\<br>
- dodany test sk³adni dla nie asemblowanych procedur .PROC gdy aktywny jest prze³±cznik -x "Exclude unreferenced procedures"<br>
- poprawione dzia³anie prze³±cznika "-d:label[=value]", podanie warto¶ci dla etykiety jest teraz opcjonalne, domy¶lnie mads przypisze warto¶æ 1<br>
- dyrektywy .DS i .ALIGN nie spowoduj± alokacji zmiennych zdefiniowanych przez .VAR<br>
- alokacja zmiennych .VAR przed nowym blokiem ORG nie nast±pi je¶li blok ORG znajduje siê w bloku .LOCAL lub .PROC<br>
- poprawione ³amanie wierszy znakiem '\' w ci±gach ograniczonych nawiasami ()<br>
- usuniêty b³±d powoduj±cy relokowanie adresu dla wyra¿enia dyrektywy .ERROR (ERT)<br>
- usuniête zauwa¿one b³êdy przy parsowaniu parametrów linii komend<br>
- usuniête zauwa¿one b³êdy dotycz±ce optymalizacji d³ugo¶ci kodu makro rozkazów MVA, MWA itp.<br>
- poprawiony kod realizuj±cy zagnie¿d¿anie bloków .PROC<br>
- poprawiony kod realizuj±cy dzia³anie pseudo rozkazów warunku IFT ELI ELS EIF<br>
- dodany komunikat "'#' is allowed only in repeated lines" dla przypadków u¿ycia licznika pêtli # (.R) poza pêtl±<br>
- usuniêty b³±d powoduj±cy b³êdne alokowanie zmiennych zadeklarowanych przez dyrektywê .VAR podczas wykonywania makra<br>
- w celu ujednolicenia sk³adni odwo³ania do etykiet typów wyliczeniowych mo¿liwe s± tylko poprzez znak kropki '.', poprzednio tak¿e przez '::'<br>
- mo¿liwe krótsze odwo³ania do typów wyliczeniowych enum_label(fields), np. :
<pre>
.enum typ
 val0 = 1
 val1 = 5
 val2 = 9
.ende

 lda #typ(val0|val2)  ; == "lda #typ.val0|typ.val2"
</pre>
<p class="tekst">
- rozszerzona sk³adnia dyrektywy .SAV, np.:
<pre>
 .sav 'filename',offset,length
 .sav 'filenema',length
 .sav [offset] 'filename',offset2,length
 .sav length
 .sav offset,length
</pre>
<p class="tekst">
- rozszerzona sk³adnia dyrektywy .ARRAY, w przypadku braku podania maksymalnego indeksu tablicy zostanie
  on obliczony na podstawie ilo¶ci wprowadzonych elementów, elementy mo¿na wprowadzaæ bez konieczno¶ci
  poprzedzenia ich indeksem [expression], np.:
<pre>
.array temp .byte
 1,4,6                  ; [0..2]   = 1,4,6
 [12] = 9,3             ; [12..13] = 9,3
 [5]:[8] = 10,16        ; [5..6]   = 10,16 ; [8..9] = 10,16
 0,0,\                  ; [14..17] = 0,0,1,1
 1,1
.enda                   ; 18 elementów, TEMP [0..17]
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ alokacji zmiennej typu strukturalnego przy pomocy dyrektyw .VAR i .ZPVAR, np.:
<pre>
.struct Point
 x .byte
 y .byte
.ends

 .var a,b,c Point
 .zpvar Point f,g,i
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ alokacji zmiennej typu wyliczeniowego przy pomocy dyrektyw .VAR i .ZPVAR, np.:
<pre>
.enum Boolean
 false = 0
 true = 1
.ende

 .var test Boolean
 .zpvar Boolean test
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ deklaracji pól struktury przy pomocy typów wyliczeniowych, np.:
<pre>
.enum EState
  DONE, DIRECTORY_SEARCH, INIT_LOADING, LOADING
.ende
 
.struct SLoader
    m_file_start .word
    m_file_length .word
 
    m_state EState
.ends
</pre>
<p class="tekst">


<p class="tekst-wiekszy">
v1.8.3 - 1.8.4
<p class="tekst">
- nowy silnik duchów programowych z minimalnymi wymaganiami pamiêci, bez dodatkowych buforów pamiêci obrazu ...EXAMPLES\SPRITES\CHARS_NG<br>
- nowa wersja pakera Huffmana (kompatybilna z Free Pascal Compiler-em, "fpc -MDelphi sqz15.pas") i dekompresora Huffmana SQZ15 ...EXAMPLES\COMPRESSION\SQUASH<br>
- poprawiony kod generowany dla rozkazów MVP, MVN, PEA, BRA (CPU 65816)<br>
- dodane nowe rozkazy BRL, JSL, JML (CPU 65816), jako odpowiedniki rozkazów d³ugich skoków BRA, JSR, JMP<br>
- blok aktualizacji etykiet zewnêtrznych (external) zosta³ rozszerzony o zapis m³odszego i starszego bajtu adresu takiej etykiety<br>
- poprawione dzia³anie dyrektywy .USE (.USING), dzia³a niezale¿nie od przestrzeni nazw w której zostanie u¿yta<br>
- usuniêty b³±d, który powodowa³ w pewnych sytuacjach pomijanie asemblacji bloku #IF, #WHILE<br>
- dodana mo¿liwo¶æ definiowania zmiennych poprzez dyrektywê .DS lub pseudo rozkaz ORG przed blokiem .RELOC<br>
- dodana dodatkowa forma sk³adni dla dyrektywy .VAR, z tym ¿e dla takiego przypadku nie ma mo¿liwo¶ci okre¶lenia adresu umiejscowienia zmiennych w pamiêci
<pre>
 .VAR .TYPE lab1 lab2 lab3 .TYPE lab4 .TYPE lab5 lab6 ...

 .var .byte a,b,c .dword i j
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ definicji pojedyñczych zmiennych typu strukturalnego w krótszy sposób ani¿eli dot±d przez DTA
<pre>
.struct @point
 x .byte
 y .byte
.ends

pointA	@point		; pointA dta @point [0] <=> pointA dta @point
pointB	@point		; pointB dta @point [0] <=> pointB dta @point

points	dta @point [100]
</pre>
<p class="tekst">
- dodana nowa dyrektywa .ZPVAR umo¿liwiaj±ca automatyczne przydzielenie miejsca zmiennym na stronie zerowej
<pre>
 .ZPVAR TYPE label1, label2 label3 = $80	; LABEL1=$80, LABEL2=LABEL1+TYPE, LABEL3=LABEL2+TYPE
 .ZPVAR label4, label5 TYPE			; LABEL4=LABEL3+TYPE, LABEL5=LABEL4+TYPE

 .print .zpvar
</pre>
<p class="tekst">
- poprawione dzia³anie dyrektywy .ERROR i pseudo rozkazu ERT, mo¿liwe jest umieszczenie dodatkowych informacji w wierszu podobnie jak dla .PRINT (.ECHO) np.:
<pre>
  ERT *>$6000 , 'BUUU przekroczyli¶my zakres pamiêci o ' , *-$6000 , ' bajtów'
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ zagnie¿d¿ania bloków procedur .PROC, ten sam kod mo¿e byæ wywo³ywany z ró¿nymi parametrami np.:
<pre>
.proc copySrc (.word src+1) .var

 .proc ToDst (.word src+1, dst+1) .var
 .endp

	ldy #0
src	lda $ffff,y
dst	sta $ffff,y
	iny
	bne src

	rts
.endp

	copySrc.ToDst #$a080 #$b000

	copySrc #$a360
</pre>
<p class="tekst">
- dodane nowe dyrektywy .ENUM i .ENDE (.EEND)
<pre>
.enum	dni_tygodnia

	poniedzialek = 1
	wtorek, sroda = 5, czwartek = 7
	piatek
	sobota
	niedziela

.ende

	ift dzien==dni_tygodnia::wtorek
	.print 'wtorek'
	eif
</pre>
<p class="tekst">
- rozszerzona funkcjonalno¶æ komentarzy wieloliniowych /* */ o mo¿liwo¶æ umieszczania ich gdziekolwiek
<pre>
 lda #12+ /* komentarz */ 23
</pre>
<p class="tekst">
- umo¿liwiona relokacja adresów definiowanych dyrektyw± .DEF
<pre>
 .reloc 
 .def label=*
 lda label
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ u¿ycia znaków { } do oznaczenia bloku (z wyj±tkiem bloków .MACRO), znak '{','}' zostaje rozpoznany na pocz±tku nowego wiersza, np.:
<pre>
#while .word ad+1<=#$bc40+39
{
ad	sta $bc40

	inw ad+1
}

.proc lab
{
	.local temp2
	{
	}

	.array tab [255] .long
	{}
}
</pre>


<p class="tekst-wiekszy">
v1.8.2
<p class="tekst">
- zniesione ograniczenie d³ugo¶ci pliku dla pseudo rozkazu INS (poprzednio d³ugo¶æ wczytywanego pliku ograniczona by³a do 65536 bajtów)<br>
- dodany komunikat b³êdu 'The referenced label ... has not previously been defined properly' w przypadku etykiet, które nie zosta³y zdefiniowane do koñca, np. tylko w pierwszym przebiegu warto¶ci± nieokre¶lon±<br>
- dodana nowa dyrektywa .ECHO jako odpowiednik dyrektywy .PRINT, dodatkowo informacje generowane przez .PRINT (.ECHO) zapisywane s± teraz tak¿e w listingu *.LST<br>
- dodana nowa dyrektywa .ALIGN pozwalaj±ca na wyrównanie do zadanego zakresu pamiêci, dodatkowo mo¿na okre¶liæ warto¶æ jak± wype³niæ pamiêæ
<pre>
  [label] .ALIGN N[,fill]
</pre>
<p class="tekst">
- dodany nowy prze³±cznik -U (Warn of unused labels)<br>


<p class="tekst-wiekszy">
1.8.1
<p class="tekst">
- rozszerzone dzia³anie znaku backslash '\', umieszczenie go na koñcu wiersza oznacza kontynuacjê aktualnego wiersza od nowego wiersza, np.:
<pre>
  macro_temp \
  _____________________________________parametr1_________________________________________________\
  _____________________________________parametr2_________________________________________________\
  _____________________________________parametr3_________________________________________________

  lda\
  #____________________________________label________________________________________\
  +__________________________________expression___________________________________
</pre>
<p class="tekst">
- zmienione testowanie niekoñcz±cego wywo³ywania siê makr po którym wyst±pi b³±d 'Infinite loop'<br>
- naprawiony zapis etykiet do pliku *.LAB, b³±d powsta³ po dodaniu addytywno¶ci obszarów LOCAL<br>
- poprawione dzia³anie pseudo rozkazu SIN (kod zapo¿yczony z XASM)<br>
- poprawione rozpoznawanie dyrektyw przy w³±czonym prze³±czniku -C (Case sensitive)<br>
- usprawniony odczyt bloków .REPT (wskazanie prawid³owej linii z b³êdem) i .MACRO<br>
- zablokowane u¿ycie .VAR w bloku .REPT<br>
- umo¿liwione zagnie¿d¿anie oraz wielokrotne uruchamianie (poprzez makra) pêtli .REPT i :repeat (poprzednio wystêpowa³ komunikat 'Use .REPT directive')<br>
- umo¿liwione przekazywanie parametrów do bloku .REPT, np.
<pre>
.REPT 10, #
label:1           ; LABEL0, LABEL1, LABEL2 ... LABEL9
.ENDR

.REPT 5, $12,$33,$44,$55,$66
 dta :1,:2,:3,:4,:5            ; $12,$33,$44,$55,$66
 dta :5,:4,:3,:2,:1            ; $66,$55,$44,$33,$12
.ENDR
</pre>


<p class="tekst-wiekszy">
1.7.9 - 1.8.0
<p class="tekst">
- poprawiony b³±d w opisie prze³±cznika -F, poprzednio 'Label at first column', prawid³owy opis to 'CPU command at first column'<br>
- przepisana od nowa obs³uga dyrektywy .DS i opcji OPT F+ (dodana mo¿liwo¶æ u¿ycia bloków RUN i INI)<br>
- przepisana od nowa obs³uga opcji OPT ?+ (etykiety lokalne w standardzie MAE)<br>
- dodana mo¿liwo¶æ upublicznienia w blokach PUBLIC tablic zadeklarowanych przez .ARRAY oraz deklaracji struktur .STRUCT<br>
- dyrektywa generuj±ca kod 6502 dla decyzji .TEST zast±piona zosta³a przez dyrektywê #IF, dyrektywa .ENDT przez #END, dodatkowo mo¿liwe jest u¿ycie dyrektywy #ELSE np.:
<pre>
 # if .byte i>#8 .and .byte i<#200
 # else
       #if .word j = #12
       #end
 # end
</pre>
<p class="tekst">
- dyrektywa generuj±ca kod 6502 dla iteracji .WHILE zast±piona zosta³a przez dyrektywê #WHILE, dyrektywa .ENDW przez #END, np.:
<pre>
 lda 20               ->       lda 20
 # while .byte @=20   ->  wait cmp 20
 # end                ->       sne
                      ->       jmp wait
</pre>
<p class="tekst">
- dyrektywy #IF i #WHILE akceptuj± dwa dodatkowe operatory '==' i '!='<br>
- dodana dyrektywa .EXITM jako odpowiednik .EXIT<br>
- dodana dyrektywa .FI jako odpowiednik .ENDIF<br>
- dodana dyrektywa .IFDEF jako krótszy odpowiednik dyrektyw .IF .DEF<br>
- dodana dyrektywa .IFNDEF jako krótszy odpowiednik dyrektyw .IF .NOT .DEF<br>
- umo¿liwione zosta³o definiowanie makr w obszarze procedury .PROC, podsumowuj±c aktualnie dopuszczalne jest zdefiniowanie makra w obszarze .LOCAL i .PROC<br>
- wyst±pienie jakiegokolwiek ostrze¿enia podczas asemblacji nie zmieni kodu wyj¶cia (exit_code=0), zmiana podyktowana potrzeb± kompatybilno¶ci z linuxowym makefile<br>
- ujednolicony sposób deklaracji etykiet lokalnych i globalnych, "bia³e znaki" przed nazw± etykiety nie wymusz± zdefiniowania takiej etykiety jako globalnej, umo¿liwi to tylko dyrektywa .DEF :LABEL<br>
- poprawione makra @CALL.MAC i @CALL_2.MAC, zmienna tymczasowa globalna ?@stack_offset modyfikowana jest teraz przez dyrektywê .DEF<br>
- rezygnacja z opcji -E (Eat White spaces), aktualnie jest ta opcja zawsze w³±czona<br>
- poprawione wy¶wietlanie numeru linii z b³êdem w aktualnie wykonywanym makrze<br>
- skrócone nazwy etykiet tworzonych podczas wykonywania makr (³atwiejsza ich identyfikacja w pliku *.LAB)<br>
- poprawione dzia³anie opcji OPT H-<br>
- dodane nowe makro rozkazy INL (increse LONG), IND (increse DWORD), DEL (decrese LONG), DED (decrese DWORD)<br>
- dodane nowe makro rozkazy CPB (compare BYTE), CPW (compare WORD), CPL (compare LONG), CPD (compare DWORD)<br>
- usprawnione i rozszerzone dzia³anie dyrektyw #TEST i #WHILE w oparciu o kod generowany przez makro rozkazy CPB, CPW, CPL, CPD, dyrektywy #TEST i #WHILE dla wyra¿eñ '=#0' i '<>#0' generuj± najkrótszy kod wynikowy<br>
- dodana optymalizacja d³ugo¶ci generowanego kodu dla makro rozkazów MWA, MWX, MWY<br>
- dodana nowa opcja OPT R optymalizuj±ca kod makro rozkazów MWA, MWX, MWY, MVA, MVX, MVY ze wzglêdu na zawarto¶æ rejestrów, np.:
<pre>
                    opt r-        opt r+
    mva #0 $80  ->  lda #$00  ->  lda #0 
    mva #0 $81  ->  sta $80   ->  sta $80
                    lda #$00  ->  sta $81
                    sta $81   ->
</pre>
<p class="tekst">
- rozszerzona funkcjonalno¶æ dyrektywy .DEF o mo¿liwo¶æ przypisania warto¶ci nowo deklarowanej etykiecie, np.:
<pre>
 .def label = 1
</pre>
<p class="tekst">
- rozszerzona funkcjonalno¶æ dyrektywy .DEF o mo¿liwo¶æ zdefiniowania etykiety globalnej niezale¿nie od aktulnego obszaru lokalnego, np.:
<pre>
 .def :label
</pre>
<p class="tekst">
- umo¿liwiona zosta³a addytywno¶æ obszarów .LOCAL, tzn. mo¿e istnieæ wiele obszarów lokalnych o tej samej nazwie, symbole zawarte w takich obszarach nale¿eæ bêd± do wspólnej przestrzeni nazw, np.:
<pre>
.local namespace

 .proc proc1
 .endp

.endl

.local namespace

 .proc proc2
 .endp

.endl
</pre>


<p class="tekst-wiekszy">
1.7.8
<p class="tekst">
- dodane dyrektywy .MEND, .PGEND, .REND jako odpowiedniki .ENDM, .ENDPG, .ENDR<br>
- obecnie deklaracja makra musi koñczyæ siê dyrektyw± .ENDM lub .MEND (poprzednio dopuszczalne by³o u¿ycie dyrektywy .END)<br>
- poprawiony sposób wykonywania makr dziêki czemu umo¿liwione zosta³o wykonanie dyrektywy .ENDL z poziomu  wykonywanego makra<br>
- poprawione zauwa¿one b³êdy dotycz±ce starszych bajtów relokowanego adresu oraz bloku aktualizacji symboli publicznych<br>
- dodana nowa dyrektywa .USING (.USE) pozwalaj±ca okre¶liæ ¶cie¿kê poszukiwañ dla nazw etykiet<br>
- poprawione dzia³anie dyrektyw .LOCAL, .DEF, których b³êdne dzia³anie objawia³o siê w szczególnych przypadkach<br>
- poprawione dzia³anie makro rozkazów skoków (SNE, RNE itp.), których b³êdne dzia³anie objawia³o siê w szczególnych przypadkach<br>
- rozszerzona sk³adnia dyrektywy .TEST (kod 6502 dla warunku) o dowoln± ilo¶æ wyra¿eñ po³±czonych przez .OR lub .AND (brak mo¿liwo¶ci zmiany piorytetu warto¶ciowania przy pomocy nawiasów), np.:
<pre>
 .test .byte k>#10+1 .or .word j>#100 .and .word j<#105 .or .byte k<=#5
 ...
 ...
 .endt
</pre>

<p class="tekst">
- rozszerzona sk³adnia dyrektywy .WHILE (kod 6502 dla pêtli) o dowoln± ilo¶æ wyra¿eñ po³±czonych przez .OR lub .AND (brak mo¿liwo¶ci zmiany piorytetu warto¶ciowania przy pomocy nawiasów), np.:
<pre>
 .while .byte k>#4 .and .byte k<#39
 ...
 ...
 .endw
</pre>


<p class="tekst-wiekszy">
1.7.6 - 1.7.7
<p class="tekst">
- dodany nowy prze³±cznik -B:ADDRESS umo¿liwiaj±cy asemblacje od zadanego adresu<br>
- dodany nowa opcja OPT F+- pozwalaj±ca tworzyæ bloki ci±g³ej pamiêci (przydatne dla cartów)<br>
- dodana obs³uga parametrów typu .LONG i .DWORD przekazywanych do procedur .PROC typu .VAR (poprzednio akceptowanymi typami parametrów by³ tylko .BYTE i .WORD)<br>
- dodana nowa dyrektywa .FL realizuj±ca zapis liczb rzeczywistych REAL w formacie FP Atari, np.:
<pre>
pi .fl 3.1415926535897932384626433832795  ; 40 03 14 15 92 65
tb .fl 0.5 12.34 -2.30 0.00002
tb .fl 0.5, 12.34, -2.30, 0.00002
</pre>
<p class="tekst">
- umo¿liwiony zosta³ zapis warto¶ci innych typów ni¿ tylko .BYTE w bloku .ARRAY<br>
- dodana obs³uga typów wielokrotnych dla .STRUCT, poprzednio takie typy by³y akceptowane jednak pamiêæ nie by³a w³a¶ciwie dla nich rezerwowana, np.:
<pre>
  .struct test
   x :200 .byte
   y :999 .long
  .ends

buf dta test [0]
</pre>
<p class="tekst">
- poprawione b³êdy dotycz±ce generowania kodu relokowalnego zauwa¿one przez Laoo, np.:
<pre>
  .reloc

   lda temp
temp .long $aabbcc
</pre>
<p class="tekst">
- b³±d 'Addres relocation overload' wyst±pi teraz tylko gdy wyra¿enie bêdzie dotyczyæ wiêcej ni¿ jednej etykiety relokowalnej, poprzednio ka¿de wyra¿enie z udzia³em etykiety relokowalnej powodowa³o wy¶wietlenie tego komunikatu b³êdu<br>
- blok aktualizacji symboli plublicznych rozszerzony zosta³ o mo¿liwo¶æ przekazywania sta³ych ró¿nych typów B-YTE, W-ORD, L-ONG, D-WORD, poprzednio przekazywanym typem by³ tylko W-ORD<br>
- zmienione dzia³anie dyrektywy .VAR w blokach .LOCAL znajduj±cych siê w bloku .PROC, zmienne takie zawsze odk³adane s± na koñcu bloku przed dyrektyw± .ENDP, w pozosta³ych przypadkach na koñcu bloku .LOCAL przed dyrektyw± .ENDL<br>
- umo¿liwiona zosta³a relokowalno¶æ kodu generowanego przez dyrektywy .WHILE i .TEST<br>
- poprawione dzia³anie testowania warto¶ci typu .WORD w kodzie generowanym przez dyrektywy .WHILE i .TEST<br>
- dodana nowa dyrektywa .ADR zwracaj±ca adres etykiety przed zmian± adresu asemblacji<br>
- dodana nowa dyrektywa .LEN zwracaj±ca d³ugo¶æ bloków zdefiniowanych przez .PROC i .ARRAY<br>
- poprawione dzia³anie operacji dzielenia, mno¿enia i modulo, poprzednio b³êdnie by³ interpretowany piorytet dla tych operacji<br>
- komentarze z koñca linii nie poprzedzone znakiem komentarza bêd± powodowaæ wyst±pienie b³êdu 'Unexpected end of line'<br>
- dodana mo¿liwo¶æ przypisania zmiennej pól zdefiniowanych przez strukture, np.:
<pre>
@point .struct
       x .byte
       y .byte
       .ends

a @point
b @point
c @point
</pre>
<p class="tekst">
- rozszerzona sk³adnia .STRUCT o mo¿liwo¶æ dodania nowych pól bez definiowania nazwy pola, np.:
<pre>
 .struct @id
  id .word
 .ends

 .struct @mem
  @id
  adr .word
 .ends
</pre>
<p class="tekst">
- rozszerzona sk³adnia makro rozkazu MWA o mo¿liwo¶æ u¿ycia adresowania po¶redniego strony zerowej  postindeksowanego Y, np.:
<pre>
  mwa ($80),y $a000,x
  mwa $bc40,y ($f0),y
  mwa ($80),y ($82),y
</pre>
<p class="tekst">
- rozszerzona sk³adnia dyrektywy .EXTRN, obecnie mo¿liwe jest zapowiedzenie wiêkszej ilo¶ci etykiet ró¿nych typów w jednym wierszu, zapowiedzenie procedury .PROC w takim wierszu musi znajdowaæ siê na jego koñcu, np.:
<pre>
  .extrn a,b,c,d .byte  x y z .word  line .proc(.byte x,y) .reg
</pre>
<p class="tekst">
- rozszerzona sk³adnia dyrektywy .VAR, obecnie mo¿liwe jest zadeklarowanie wiêkszej ilo¶ci etykiet ró¿nych typów w jednym wierszu oraz przypisanie im adresu od którego zostan± od³o¿one w pamiêci, np.:
<pre>
  .var x y z .byte bit :2 .dword = $80
</pre>
<p class="tekst">
- rozszerzona sk³adnia dla parametrów procedur przekazywanych przez zmienne .VAR, mo¿liwe jest podanie przesuniêcia np.:
<pre>
move .proc (.word src+1,dst+1) .var

src lda $ffff
dst sta $ffff

     .endp
</pre>
<p class="tekst">
- dodana nowa dyrektywa .NOWARN wy³±czaj±ca wy¶wietlenie ostrze¿enia dla aktualnie asemblowanego wiersza, np.:
<pre>
 .nowarn PROCNAME
</pre>
<p class="tekst">
- dodane nowe makro rozkazy PHR, PLR, realizuj±ce odk³adanie i zdejmowanie warto¶ci rejestrów z udzia³em stosu sprzêtowego, np.:
<pre>
  PHR -> PHA         PLR -> PLA
         TXA                TAY
         PHA                PLA
         TYA                TAX
         PHA                PLA
</pre>
<p class="tekst">
- dodane nowe makro rozkazy ADB, SBB realizuj±ce dodawanie i odejmowanie warto¶ci typu .BYTE, np.:
<pre>
 ADB $80 #12 $b000  ->  lda $80
                        clc
                        adc #12
                        sta $b000

 SBB #200 $a000     ->  lda #200
                        sec
                        sbc $a000
                        sta $a000
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ u¿ycia sk³adni C dla liczb szestnastkowych, np.:
<pre>
 lda 0x2000
 ldx #0x12

temp = 0x8000
</pre>


<p class="tekst-wiekszy">
1.7.5
<p class="tekst">
- dyrektywa .DS w blokach relokowalnych SDX RELOC i MADS RELOC deklaruje od teraz pusty blok<br>
- dodany nowy prze³±cznik -F, który umo¿liwia umieszczanie rozkazów CPU i pseudo rozkazów od pierwszej kolumny w wierszu<br>
- przepisane od nowa procedury odczytu bloków .MACRO, .REPT oraz procedura realizuj±ca dzielenie wiersza przy pomocy znaku '\'<br>
- dodane nowe pseudo rozkazy ADW, SBW realizuj±ce dodawanie i odejmowanie warto¶ci typu WORD dla CPU6502, np.:
<pre>
  adw hlp #40        ; hlp=hlp+40
  adw hlp #20 pom    ; pom=hlp+20
</pre>
<p class="tekst">
- rozszerzone dzia³anie dyrektywy .DEF o mo¿liwo¶æ zdefiniowania etykiety, np.: .DEF label<br>
- zwiêkszona liczba przebiegów dla deklaracji etykiet przez EQU dla pewnych szczególnych przypadków<br>


<p class="tekst-wiekszy">
1.7.4
<p class="tekst">
- naprawione dzia³anie dyrektywy .PRINT, dot±d mog³a nie wy¶wietliæ warto¶ci etykiet zaczynaj±cej siê na literê 'A','B','C','D','E','F','G','H','L','T','V'<br>
- zablokowane dzia³anie dyrektywy .DS w blokach .RELOC i SDX oraz naprawione jej dzia³anie z instrukcj± warunkow± .IF (IFT)<br>
- usprawnione przeszukiwanie ¶cie¿ek dostêpu -i:path (mo¿na odwo³ywaæ siê do podkatalogów tam zawartych)<br>
- w przypadku wyst±pienia b³êdów podczas asemblacji wy¶wietlane s± one wszystkie a nie tylko pierwszy z b³êdów<br>
- poprawione zauwa¿one b³êdy, m.in. u¿ycie makra w pliku .RELOC mog³o spowodowaæ w pewnych sytuacjach zapis b³êdnej informacji o relokownych adresach<br>
- uproszczony zosta³ sposób koñczenia procedur wykorzystuj±cych stos programowy MADS-a, nie ma potrzeby u¿ywania dyrektywy .EXIT, a dyrektywa .ENDP nie powoduje ju¿ dodatkowych dzia³añ na stosie programowym<br>
- dodana nowa dyrektywa .SYMBOL jako odpowiednik bloku aktualizacji BLK UPDATE NEW SYMBOL 'SYMBOL', dyrektywê .SYMBOL mo¿na u¿yæ w dowolnym miejscu programu<br>
- dodane automatyczne wywo³ywanie bloków aktualizacji (ADDRESS, EXTERNAL, PUBLIC, SYMBOL) dla .RELOC i SDX<br>
- dodane nowe dyrektywy .BY, .WO, .HE, .EN, .SB (zapo¿yczone z MAE)<br>
- dodany nowy prze³±cznik OPT ?- (domy¶lnie) etykiety ze znakiem zapytania (?labels) traktowane s± jako etykiety tymczasowe, OPT ?+ etykiety ze znakiem zapytania (?labels) traktowane s± jako lokalne i tymczasowe, nazw± obszaru lokalnego jest ostatnio u¿yta etykieta bez znaku zapytania<br>
- dodane dyrektywy .LEND, .PEND, .AEND, .WEND, .TEND, .SEND jako odpowiedniki dyrektyw .ENDL, .ENDP, .ENDW, ENDW, .ENDT, .ENDS<br>
- dodane nowe dyrektywy .GLOBAL i .GLOBL jako odpowiednik (zamiennik) dyrektywy .PUBLIC<br>
- dodana optymalizacja skoków warunkowych JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS, je¶li jest taka mo¿liwo¶æ wybierany jest skok krótki typu BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS<br>
- dodany nowy domy¶lny separator znak spacji dla przekazywanych parametrów do .PROC, .MACRO, dot±d by³ to tylko znak przecinka<br>
- usprawnienia dotycz±ce przekazywania parametrów do makr i procedur, np. paramatrem makra mo¿e byæ dyrektywa zwracaj±ca warto¶æ wyra¿enia lub symbol licznika pêtli '#'
<pre>
  :12 makro #
</pre><p class="tekst">
- dodana mo¿liwo¶æ u¿ycia znaku spacji jako separatora dla .VAR, .EXTRN, np.
<pre>
  .EXTRN a b c d .word
  .VAR i = 1  j = 2 .byte
  .VAR a b c d .byte
</pre><p class="tekst">
- rozszerzona sk³adnia dla .VAR umo¿liwiaj±ca zaincjowanie zmiennych sta³±, np.:
<pre>
 .var i = 10  j = 12 .byte
 .var a , b = 2 .byte
</pre><p class="tekst">
- dodane nowe dyrektywy .WHILE, .ENDW pozwalaj±ce na automatyczne wygenerowanie kodu dla pêtli WHILE, np.:
<pre>
         ldx #$ff
 .while .word adr < #$bc40+40*24
         stx $bc40
    adr: equ *-2
         inw adr
 .endw
</pre><p class="tekst">
- dodane nowe dyrektywy .TEST, .ENDT pozwalaj±ce na automatyczne wygenerowanie kodu dla warunku, np.:
<pre>
 .test .byte (@>=#'a')
  .test .byte (@<=#'z')
      
  .endt
 .endt
</pre>
 

<p class="tekst-wiekszy">
1.7.3
<p class="tekst">
- dodana mo¿liwo¶æ zmiany adresu asemblacji .PROC lub .LOCAL bez zmiany adresu ³adowania<br>
- usuniêto optymalizacjê kodu dla makro rozkazów MWA itp., która mog³a powodowaæ w szczególnych przypadkach zapêtlenie siê MADS-a<br>
- dodane dyrektywy .REG, .VAR pozwalaj±ce okre¶liæ sposób przekazywania parametrów do procedur (.REG przez rejestry CPU, .VAR przez zmienne)<br>
- dodana dyrektywa .VAR pozwalaj±ca na deklaracjê zmiennych w blokach .PROC, .LOCAL, zadeklarowane zmiennne s± fizycznie odk³adane na koñcu takiego bloku<br>
- rozszerzona sk³adnia dla dyrektywy .EXTRN, np. EXTRN label1,label2,label3... TYPE<br>
- jesli brak deklaracji etykiet dla stosu programowego MADS-a, przyjmowane s± domy¶lne warto¶ci @PROC_VARS_ADR=$0500, @STACK_ADDRESS=$0600, @STACK_POINTER=$FE<br>
- dodany repeat_counter #, który mo¿na u¿ywaæ zamiennie z dyrektyw± .R<br>
- wystapi b³±d '^ not relocatable' przy próbie relokacji rozkazu 'lda ^label'<br>
- dodana obs³uga symboli publicznych dla sta³ych (C-ONSTANT) w blokach PUBLIC<br>
- poprawiona relokowalnosc dla tablic .ARRAY, danych stworzonych przez .STRUCT, parametrów przekazywanych do procedur przez sta³a #
</p>


<p class="tekst-wiekszy">
v1.7.2
<p class="tekst">
- przepisana na nowo obs³uga pseudo rozkazów REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS, SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS<br>
- poprawione dzia³anie dyrektywy .LINK dla bloków o sta³ych adresach<br>
- poprawione testowanie s³ów zarezerwowanych (mo¿na u¿ywaæ nazw zarezerwowanych dla 65816 gdy u¿ywamy tylko 6502)<br>
- zmiany w listingu, wy¶wietla informacje o numerze banku tylko gdy bank &gt; 0<br>
- dodana obs³uga makro rozkazów MWA, MWX, MWY, MVA, MVX, MVY, ADD, SUB, INW, DEW (do ich obs³ugi nie s± ju¿ potrzebne makra)
</p>


<p class="tekst-wiekszy">
v1.7.1
<p class="tekst">
- dodana mo¿liwo¶æ u¿ywania nazw mnemoników 65816 w trybie pracy 6502, w trybie 65816 wyst±pi ju¿ b³±d <b>Reserved word</b><br>
- poprawione dzia³anie pseudo rozkazów skoków SCC, RNE itp. w makrach<br>
- usprawnione wykonywanie wielu makr rozdzielonych znakiem dwukropka ':'
</p>


<p class="tekst-wiekszy">
v1.7.0
<p class="tekst">
- usuniêty b³±d, który powodowa³ zbyt ma³a liczbê przebiegów asemblacji<br>
- dodana obs³uga pseudo rozkazów JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS (makra nie s± ju¿ potrzebne do ich obs³ugi)
</p>


<p class="tekst-wiekszy">
v1.6.9
<p class="tekst">
- rozszerzona sk³adnia dla .ARRAY, .PUT<br>
- dodany pseudo rozkaz EXT pozwalaj±cy na deklaracje etykiety external<br>
- dodane makra JEQ, JNE, JPL, JMI, JCC, JCS<br>
- dodane dyrektywy .PAGES i .ENDPG<br>
- dodana dyrektywa .END zastepujaca inne dyrektywy .END?<br>
- prze³±cznik -H zast±piony zosta³ przez -HC (generuje plik nag³ówkowy dla CC65)<br>
- dodany nowy prze³±cznik -HM generuj±cy plik nag³ówkowy dla MADS-a z sortowaniem na etykiety typu CONSTANTS, VARIABLES, PROCEDURES<br>
- dodana nowa dyrektywa .RELOC generuj±ca kod relokowalny w formacie MADS-a
</p>


<p class="tekst-wiekszy">
v1.6.8
<p class="tekst">
- dodana nowa dyrektywa .PUT oraz rozszerzona sk³adnia dla dyrektywy .GET (../EXAMPLES/MSX/MPT_PLAYER/MPT_RELOCATOR.MAC , ../EXAMPLES/MSX/TMC_PLAYER/TMC_RELOCATOR.MAC)<br>
- dodana obs³uga pseudo rozkazów XASM-a REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS, SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS<br>
- dodana mo¿liwo¶æ ³±czenia dowolnej liczby znanych MADS-owi mnemoników przy pomocy znaku ':' (styl XASM-a), np.: 
<pre>
  lda:cmp:req 20
  ldx:ldy:lda:iny label
</pre>

<p class="tekst-wiekszy">
v1.6.6 - 1.6.7
<p class="tekst">
- ¼ród³o MADS-a kompatybilne z Free Pascal Compiler, po kompilacji mo¿liwe jest jego u¿ywanie na innych platformach systemowych, jak np. Linux, Mac OS, OS/2 itp.<br>
- od teraz MADS sam dobiera odpowiedni± liczbê przebiegów asemblacji, prze³±cznik '/3' nie jest ju¿ potrzebny<br>
- poprawiony i rozbudowany zosta³ mechanizm przekazywania parametrów do MADS-a (rozdzia³ 'Prze³±czniki assemblera')<br>
- poprawione zosta³o wywo³anie makra w linii rozdzielanej znakiem '\' oraz usprawnione rozpoznawanie i wykonywanie linii rozdzielanych znakami '\'<br>
- poprawiony b³±d, w którym MADS myli³ dyrektywê .ENDM z pseudorozkazem IFT<br>
- poprawione dzia³anie instrukcji warunkowych .ELSEIF, .ELSE<br>
- poprawione testowanie poprawno¶ci instrukcji warunkowych w makrach<br>
- obs³uga procedur .PROC zosta³a rozbudowana o nowe makra i mechanizmy, dziêki którym podobna jest w dzia³aniu jak i ³atwo¶ci u¿ycia do procedur z jêzyków wy¿szego poziomu<br>
- dla procedur .PROC z zadeklarowanymi parametrami potrzebna jest teraz dodatkowa deklaracja @PROC_VARS_ADR<br>
- brak ograniczeñ w liczbie parametrów przekazywanych do procedur, jedynym ograniczeniem jest dostêpna pamiêæ<br>
- dodany nowy prze³±cznik /d:label=value pozwalaj±cy zdefiniowaæ now± etykietê MADS-a z poziomu linii poleceñ<br>
- dodany nowy prze³±cznik /x "Exclude unreferenced procedures" pozwalaj±cy pomin±æ podczas asemblacji nie u¿ywane w programie procedury zadeklarowane dyrektyw± .PROC<br>
- nowa opcja OPT T+ (track sep, rep) ¶ledz±ca zmiany rozmiaru rejestrów A,X,Y dokonywane przez rozkazy SEP, REP (CPU 65816)<br>
- nowe biblioteki w katalogu ..\EXAMPLES\LIBRARIES<br>
- w deklaracji obszaru lokalnego .LOCAL nie jest wymagane podanie nazwy obszaru<br>
- nowe operatory '-=', '+=', '++', '--' pozwalaj±ce zmniejszyæ/zwiêkszyæ warto¶æ etykiety tymczasowej, np.:
<pre>
  ?label --      ->   ?label=?label-1
  ?lab ++        ->   ?lab=?lab+1
  ?temp += 3     ->   ?temp=?temp+3
  ?ofset -= 5    ->   ?ofset=?ofset-5
</pre>
<p class="tekst">
- rozszerzona o znak przecinka sk³adnia deklaracji parametrów procedur, np.:
<pre>
 .proc nazwa (.byte a,b,c .word d,e)
 .endp
</pre>

</html>