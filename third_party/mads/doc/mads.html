<html>
<head>

<title>MAD-ASSEMBLER INSTRUKCJA</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">

<BODY BACKGROUND="6502proc.gif">

<style type="text/css">
.duzy {
	font-family: Tahoma, Verdana, Arial;
	font-size: 24px;
	color: #000000;
	background-position: left;
	font-weight: bold;
}

.tekst {
	font-family: Tahoma, Verdana, Arial;
	font-size: 11px;
	color: #000000;
	background-position: left;
}

.tekst-wiekszy {
	font-family: Tahoma, Verdana, Arial;
	font-size: 14px;
	color: #000000;
	background-position: left;
	font-weight: bold;
	border-bottom-width: 1px;
	border-bottom-style: solid;
	border-bottom-color: #666666;
}

.stopka {
	font-family: Tahoma, Verdana, Arial;
	font-size: 9px;
	color: #666666;
	text-decoration: none;
	background-position: center;}
 
</style>


</head>

<CENTER>
<p class="duzy"><u>MAD-ASSEMBLER 2.1.0</u></p>
<p class="stopka">Tebe/Madteam (11.11.2019)

<HR>

<TABLE>
<TR><TD VALIGN=top>
<UL>

<tt>
<b><LI><A HREF="#wprow">WPROWADZENIE</A></b>
<UL>

<LI><A HREF="#mads">Wstêp</A>
<LI><A HREF="#komp">Kompilacja</A>
<LI><A HREF="#roznice">Ró¿nice i podobieñstwa pomiêdzy XASM i MADS</A>
<UL>
<LI><A HREF="#podob">Podobieñstwa</A>
<LI><A HREF="#rozni">Ró¿nice i nowe mo¿liwo¶ci</A>
</UL>
</UL>

<br />

<b><LI><A HREF="#sposob">SPOSÓB U¯YCIA</A></b>
<UL>
<LI><A HREF="#switches">Prze³±czniki assemblera</A>
<LI><A HREF="#err">Kody wyj¶cia</A>
<LI><A HREF="#lst">Struktura pliku .LST</A>
<LI><A HREF="#lab">Struktura pliku .LAB</A>
<LI><A HREF="#plikh">Struktura pliku .H</A>
</UL>

<br />

<b><LI><A HREF="#sdx">SPARTA DOS X</A></b>
<UL>
<LI><A HREF="#sdx_plik">Budowa plików Sparta DOS X, Atari DOS</A>
<LI><A HREF="#sparta">Programowanie Sparta DOS X</A>
</UL>

<br />

<b><LI><A HREF="#mnemo">MNEMONIKI</A></b>
<UL>
<LI><A HREF="#8bit">6502</A>
<LI><A HREF="#8bit_ill">6502 nielegalne</A>
<LI><A HREF="#16bit">65816</A>
</UL>

<br />


<b><LI><A HREF="#det_cpu">DETEKCJA CPU</A></b>

<br />
<br />

<b><LI><A HREF="#banks">BANKI PAMIÊCI</A></b>
<UL>
<LI><A HREF="#banks_wir">Wirtualne</A>
<LI><A HREF="#banks_spr">Sprzêtowe</A>
</UL>

<br />


<b><LI><A HREF="#_relok">KOD RELOKOWALNY</A></b>
<UL>
<LI><A HREF="#_reloc">Blok relokowalny</A>
<LI><A HREF="#labels_ext">Symbole zewnêtrzne</A>
<LI><A HREF="#labels_pub">Symbole publiczne</A>
<LI><A HREF="#_link">Linkowanie</A>
</UL>

<b><LI><A HREF="#types">TYPY</A></b>
<UL>
<b><LI><A HREF="#structs">Strukturalne</A></b>
<UL>
<LI><A HREF="#struct">Deklaracja typu strukturalnego</A>
<LI><A HREF="#struct_wy">Definiowanie danych strukturalnych</A>
</UL>
<b><LI><A HREF="#enums">Wyliczeniowe</A></b>
<UL>
<LI><A HREF="#enums">Deklaracja typu wyliczeniowego</A>
<LI><A HREF="#enums">Definiowanie danych wyliczeniowych</A>
</UL>
</UL>

<br />


<b><LI><A HREF="#zmiany">HISTORIA</A></b>
</UL>
</tt>

</TD>


<TD VALIGN=top>
<UL>
<tt>
<b><LI><A HREF="#syntax">SK£ADNIA</A></b>
<UL>
<LI><A HREF="#kom">Komentarze</A>
<LI><A HREF="#znak_p">£±czenie wielu wierszy w jeden wiersz</A>
<LI><A HREF="#znak_d">£±czenie wielu mnemoników</A>

<b><LI><A HREF="#expres">Wyra¿enia</A></b>
<UL>
<LI><A HREF="#numbers">Liczby</A>
<LI><A HREF="#opers">Operatory</A>
</UL>

<b><LI><A HREF="#labels">Etykiety</A></b>
<UL>
<li><a HREF="#labels_anm">Anonimowe</a>
<LI><A HREF="#labels_lok">Lokalne</A>
<LI><A HREF="#labels_glo">Globalne</A>
<LI><A HREF="#labels_set">Tymczasowe</A>
<LI><A HREF="#labels_mae">Lokalne w stylu MAE</A>
</UL>

<b><LI><A HREF="#_opt">Kontrola asemblacji</A></b>
<UL>
<LI><A HREF="#_opt">Zmiana opcji asemblacji</A>
<LI><A HREF="#warun">Asemblacja warunkowa</A>
<LI><A HREF="#_error">Przerwanie asemblacji</A>
<LI><A HREF="#zpage">Asemblacja na stronie zerowej</A>
</UL>

<b><LI><A HREF="#makrorozkazy">Makro rozkazy</A></b>
<UL>

</UL>

<b><LI><A HREF="#pseudo">Pseudo rozkazy</A></b>
<UL>
<LI><A HREF="#_blk">Definiowanie bloku SDX</A><br>
<LI><A HREF="#_smb">Definiowanie symbolu SDX</A><br>
<LI><A HREF="#_dta">Definiowanie danych</A><br>
</UL>

<b><LI><A HREF="#dyrekt">Dyrektywy</A></b>
<UL>
<LI><A HREF="#_rept">Definiowanie powtórzeñ (.REPT)</A><br>
<LI><A HREF="#_symbol">Definiowanie symbolu SDX (.SYMBOL)</A><br>
<LI><A HREF="#arrays">Definiowanie tablic (.ARRAY)</A><br>
<LI><A HREF="#_segment">Definiowanie segmentów (.SEGDEF)</A><br>
</UL>

<b><LI><A HREF="#dyrekt6502">Dyrektywy generuj±ce kod 6502</A></b>
<UL>
<LI><A HREF="#_while6502">Definiowanie iteracji (#WHILE)</A><br>
<LI><A HREF="#_test6502">Definiowanie decyzji (#IF)</A><br>
<LI><A HREF="#_cycle6502">#CYCLE</A><br>
</UL>

<b><LI><A HREF="#arrays">Tablice</A></b>
<UL>
<LI><A HREF="#array">Deklaracja tablicy</A>
</UL>


<b><LI><A HREF="#macros">Makra</A></b>
<UL>
<LI><A HREF="#makra">Deklaracja makra</A>
<LI><A HREF="#makra_wy">Wywo³anie makra</A>
<LI><A HREF="#_defi">Definiowanie makra</A>

</UL>

<b><LI><A HREF="#procs">Procedury</A></b>
<UL>
<LI><A HREF="#proc">Deklaracja procedury</A>
<LI><A HREF="#proc_wy">Wywo³anie procedury</A>
<LI><A HREF="#para_od">Parametry procedury</A>
</UL>

<b><LI><A HREF="#locals">Obszar lokalny</A></b>
<UL>
<LI><A HREF="#obszar_lok">Deklaracja obszaru lokalnego</A>
</UL>

</UL>
</UL>
</TD></TR>
</TABLE>

</CENTER>

</tt>
<HR>


<tt>

<div align="justify">


<A NAME="wprow">
<p class="duzy">
WPROWADZENIE
</p>


<A NAME="mads">
<u><tt><h2>Wstêp</h2></tt></u>
<p>
<tt>Mad-Assembler (MADS)</tt> jest aplikacj± <tt>32</tt> bitow±, napisan± w <tt>Delphi</tt>. Wiêkszo¶æ asemblerów napisano w <tt>C</tt>, wiêc ¿eby siê nie powtarzaæ u¿y³em <tt>Delphi 7.0 ;)</tt>.
</p>

<p>
W za³o¿eniu <tt>MADS</tt> skierowany jest do u¿ytkowników <tt>QA</tt>, <tt>XASM</tt>, <tt>FA</tt>. Z <tt>QA</tt> zapo¿yczona zosta³a sk³adnia, z <tt>XASM</tt> niektóre makro rozkazy i zmiany sk³adni, z <tt>FA</tt> obs³uga sk³adni <tt>Sparta DOS X (SDX)</tt>. Umo¿liwione zosta³o u¿ycie dodatkowych znaków w nazwach etykiet. Poza tym dodana zosta³a obs³uga <tt>CPU 65816</tt>, makr, procedur, podzia³u pamiêci na wirtualne banki, wielowymiarowych nazw etykiet.
</p>

<p>
Maksymalna liczba etykiet i makr ograniczona jest ilo¶ci± pamiêci komputera <tt>PC</tt>. Konkretnie mo¿na dokonaæ <tt>2147483647</tt> <tt>(INTEGER)</tt> wpisów do tablic dynamicznych. Jestem pewien ¿e taka ilo¶æ jest wystarczaj±ca :)
</p>

Operacje arytmetyczne dokonywane s± na warto¶ciach typu <tt>INT64</tt> (signed 64 bit), wynik reprezentowany jest na warto¶ciach typu <tt>CARDINAL</tt> (unsigned 32 bit).

<p>
Jeden wiersz mo¿e mieæ d³ugo¶æ <tt>65535</tt> bajtów, takiej d³ugo¶ci mo¿e byæ te¿ nazwa etykiety. Nie mia³em jednak okazji sprawdziæ tak d³ugich etykiet i wierszy :)
</p>

<p>
Dziêki darmowemu kompilatorowi <b><tt>Free Pascal Compiler</tt></b> mo¿liwa jest kompilacja <tt>MADS-a</tt> dla innych platform systemowych, np. <tt>Linux, Mac, OS/2</tt> itp. Wiêcej informacji na temat kompilacji w rodziale <A HREF="#komp">Kompilacja</A>.
</p>

Je¶li dla Twojego systemu istnieje odpowiednia wersja <tt>Free Pascala</tt>, tzn. ¿e mo¿esz u¿ywaæ <tt>MADS-a.</tt>
<p></p>

<li>Strona domowa <tt>XASM-a</tt>: <a href="http://atariarea.histeria.pl/x-asm/">http://atariarea.krap.pl/x-asm/</a>


<li>W±tki dotycz±ce <tt>MADS-a</tt>:
<ul>
<li><a href="http://www.atari.org.pl/forum/viewtopic.php?id=8450">http://www.atari.org.pl/</a>
<li><a href="http://atariage.com/forums/topic/114443-mad-assembler-mads/">http://atariage.com/</a>
<li><a href="http://www.atari.org.pl/forum/viewtopic.php?id=13407">Kolorowanie sk³adni MADS, XASM</a></li>
</ul>

<p></p>
<br />


<A NAME="komp">
<u><tt><h2>Kompilacja</h2></tt></u>
<p>
Aby skompilowaæ ¼ród³o <tt>MADS-a</tt>, mo¿na u¿yæ kompilatora z <tt>Delphi</tt>, je¶li kto¶ ma akurat zainstalowane ¶rodowisko <tt>Delphi 7.0</tt> lub nowsze.
</p>

<p>
Innym sposobem, bardziej multi platformowym jest u¿ycie kompilatora z pakietu <tt><b>Free Pascal Compiler (FPC)</b></tt>, który mo¿na pobraæ ze strony <a href="http://www.freepascal.org/">http://www.freepascal.org/</a> 
</p>

Uruchamiamy instalator, wybieramy katalog w którym zostanie zainstalowany <tt>FP</tt>. Wa¿ne jest aby nie u¿ywaæ w nazwie katalogu znaku wykrzyknika <tt>'!'</tt> czy innych nie standardowych znaków. Je¶li nie uda nam siê skompilowaæ ¿adnego pliku, najpewniej winna jest nie standardowa nazwa ¶cie¿ki. Linia komend uruchamiaj±ca kompilacjê mo¿e wygl±daæ nastêpuj±co (wielko¶æ liter w nazwach parametrów ma znaczenie):

<pre>
fpc -Mdelphi -v mads.pas

<li>-Mdelphi     pozwala kompilowaæ plik w formacie <tt>Delphi</tt>
<li>-v           wy¶wietla wszystkie komunikaty b³êdów i ostrze¿eñ
<li>-O3          dokonuje optymalizacji kodu
</pre>

W porównaniu z kompilatorem <tt>Delphi</tt>, kod wygenerowany przez <tt>FPC</tt> jest d³u¿szy, za to prêdko¶æ dzia³ania skompilowanego nim <tt>MADS-a</tt> znacznie wiêksza, nawet o kilka sekund. Za³±czony plik <tt>MADS.EXE</tt> jest kompilowany przy u¿yciu <tt>FPC</tt>.

<p></p>
<br />



<A NAME="roznice">
<p class="duzy">
RÓ¯NICE I PODOBIEÑSTWA POMIÊDZY XASM I MADS
</p>


<A NAME="podob">
<u><tt><h2>Podobieñstwa</h2></tt></u>

<li>ta sama sk³adnia
<li>te same kody wyj¶cia
<li>te same makro rozkazy

<p></p>
<br />



<A NAME="rozni">
<u><tt><h2>Ró¿nice i nowe mo¿liwo¶ci</h2></tt></u>

<li>ma³a ró¿nica w <tt>ORG</tt>, np. <tt>'ORG [[expression]]adres[,adres2]'</tt>
<li><tt>XASM</tt> nie lubi "bia³ych spacji", <tt>MADS</tt> toleruje je i akceptuje dla wyra¿eñ logicznych, arytmetycznych, definicji sta³ych i zmiennych
<li><tt>MADS</tt> pozwala na umieszczanie wyra¿eñ pomiêdzy nawiasami <tt>(), []</tt>, <tt>XASM</tt> tylko pomiêdzy <tt>[]</tt>
<li><tt>MADS</tt> udostêpnia definicje sta³ych i zmiennych lokalne, globalne, tymczasowe, <tt>XASM</tt> tylko globalne
<li><tt>MADS</tt> nie akceptuje <tt>ORG a:adres</tt> i <tt>ORG f:adres</tt>
<li><tt>MADS</tt> udostêpnia zapis liczb rzeczywistych poprzez dyrektywê <b>.FL</b> .FL real, XASM poprzez pseudo rozkaz <b>DTA R</b> <tt>DTA R(real)</tt>
<li><tt>MADS</tt> oferuje bardziej rozbudowan± obs³ugê pseudo rozkazu <tt>INS</tt>
<li><tt>MADS</tt> nie akceptuje sk³adni typu 'lda (203),0'
<li><tt>MADS</tt> umo¿liwia pisanie programów dla Sparta DOS X
<li><tt>MADS</tt> umo¿liwia generowanie kodu relokowalnego w swoim w³asnym formacie
<li>je¶li u¿yjemy podczas adresowania warto¶ci znakowej, np.
<pre>
  lda #' '
  lda #" "
</pre>
</p>

<p>
<tt>MADS</tt> bêdzie rozró¿nia³ apostrof pojedyñczy (kod <tt>ATASCII</tt>) i apostrof podwójny (kod <tt>INTERNAL</tt>), <tt>XASM</tt> oba rodzaje apostrofów potraktuje jednakowo (kod <tt>ATASCII</tt>). Oczywi¶cie dla danych <tt>DTA</tt> apostrofy nie s± rozró¿niane przez <tt>MADS</tt>.
</p>

<li>w trybach indeksowych znak <tt>'+'</tt> lub <tt>'-'</tt> zwiêksza lub zmniejsza rejestr, np.
<pre>
 lda $2000,x+    -&gt    lda $2000,x
                       inx
</pre>

<li>je¶li jednak umie¶cimy warto¶æ za znakiem <tt>'+'</tt> lub <tt>'-'</tt> wówczas zmienimy o t± warto¶æ g³ówny argument (dzia³a tylko w trybie absolutnym indeksowym), np.:
<pre>
 lda $2000,x+2   -&gt    lda $2002,x
</pre>
<br />



<A NAME="sposob">
<p class="duzy">
SPOSÓB U¯YCIA
</p>

<A NAME="switches">
<u><tt><h2>Prze³±czniki assemblera</h2></tt></u>

<span style="color: #0000FF">
<pre>
Syntax: mads source [switches]

-b:address      Generate binary file at specific address
-c              Label case sensitivity
-d:label=value  Define a label
-f              CPU command at first column
-fv:value       Set raw binary fill byte to [value]
-hc[:filename]  Header file for CC65
-hm[:filename]  Header file for MADS
-i:path         Additional include directories
-l[:filename]   Generate listing
-m:filename     File with macro definition
-ml:value       margin-left property
-o:filename     Set object file name
-p              Print fully qualified file names in listing and error messages
-s              Silent mode
-t[:filename]   List label table
-u              Warn of unused labels
-vu             Verify code inside unreferenced procedures
-x              Exclude unreferenced procedures
</pre>
</span>

<p>
Domy¶lne nazwy plików to:
</p>

<span style="color: #0000FF">
<tt>
<li>source.lst
<li>source.obx
<li>source.lab
<li>source.h
<li>source.hea
<li>source.mac
</tt>
</span>

<p>
Je¶li nie podamy rozszerzenia dla pliku <tt><b>source</b></tt>, wówczas <tt>MADS</tt> domy¶lnie przyjmie rozszerzenie <tt>.ASM</tt>.
</p>

Parametry mo¿emy podawaæ w dowolnej kolejno¶ci uprzednio poprzedzaj±c je znakiem <tt>'/'</tt> lub <tt>'-'</tt>, wielko¶æ liter nie ma znaczenia. Parametry mo¿emy ³±czyæ ze sob±, np.:

<span style="color: #0000FF">
<pre>
mads -lptd:label=value -d:label2=value source.asm
mads -l  -p  -t  source
mads source.asm  -lpt
mads.exe "%1" -ltpi:"d:\!atari\macro\"
mads -i:"c:\atari\macros\" -c source.asm  -lpt
</pre>
</span>

Domy¶lnie <tt>MADS</tt> po asemblacji zapisze plik z rozszerzeniem '.OBX', mo¿emy to zmieniæ z poziomu BAT-a:
<span style="color: #0000FF">
<pre>
mads "%1" -o:%~n1.xex
</pre>
</span>

Wiêcej na temat operatorów mo¿emy dowiedzieæ siê wykonuj±c "CALL /?" z poziomu Microsoft DOS-a.

</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-b:address</div>
<div align="justify">
U¿ycie prze³±cznika <b><tt>-b</tt></b> pozwala nadaæ nowy adres asemblacji dla pliku w którym nie okre¶lono adresu asemblacji (adres asemblacji okre¶lamy przy pomocy pseudo rozkazu <A HREF="#_org">ORG</A>).
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-c</div>
<div align="justify">
U¿ycie prze³±cznika <b><tt>-c</tt></b> spowoduje rozró¿nianie wielko¶ci liter w nazwach etykiet, zmiennych, sta³ych. Dyrektywy assemblera i rozkazy <tt>CPU 6502, 65816</tt> s± zawsze rozpoznawane bez wzglêdu na wielko¶æ liter.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-d:label=value</div>
<div align="justify">
U¿ycie prze³±cznika <b><tt>-d</tt></b> pozwala na wprowadzenie nowej etykiety do pamiêci <tt>MADS-a</tt> z poziomu linii 
poleceñ. Prze³±cznika mo¿na u¿yæ wielokrotnie podczas jednego wywo³ania <tt>MADS-a</tt>, mo¿e byæ przydatny gdy asemblujemy z u¿yciem plików wsadowych (<tt>BAT</tt>).
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-f</div>
<div align="justify">
U¿ycie prze³±cznika <b><tt>-f</tt></b> umo¿liwia umieszczanie rozkazów CPU od pierwszej kolumny wiersza i ich poprawne rozpoznawanie przez asembler jako rozkazy a nie tylko jako etykiety.
</p>


<p>
<div style="font-weight: bold"  style="font-size: 18px">-f</div>
<div align="justify">
U¿ycie prze³±cznika <b><tt>-fv:value</tt></b> pozwala ustaliæ warto¶æ wype³nienia pamiêci gdy u¿yjemy 'OPT F+'
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-hc[:filename]</div>
<div align="justify">
Prze³±cznik <b><tt>-hc</tt></b> w³±cza zapis pliku z nag³ówkami dla kompilatora <tt>CC65</tt>. Pozwala tak¿e okre¶liæ now± nazwê dla takiego pliku. Domy¶lna nazwa pliku nag³ówkowego dla <tt>CC65</tt> to <tt>*.H</tt>
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-hm[:filename]</div>
<div align="justify">
Prze³±cznik <b><tt>-hm</tt></b> w³±cza zapis pliku z nag³ówkami dla <tt>MADS-a</tt>. Pozwala tak¿e okre¶liæ now± nazwê dla takiego pliku. Domy¶lna nazwa pliku nag³ówkowego dla <tt>MADS-a</tt> to <tt>*.HEA</tt>. Plik taki zawiera informacje o bankach przypisanych etykietom i ich warto¶ci. Dodatkowo etykiety posortowane zostaj± wg typu <tt>CONSTANS, VARIABLES, PROCEDURES</tt>.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-i:path</div>
<div align="justify">
Prze³±cznik <b><tt>-i</tt></b> s³u¿y do okre¶lenia ¶cie¿ek poszukiwañ dla operacji <tt>ICL</tt> oraz <tt>INS</tt>.
 Prze³±cznika mo¿na u¿yæ wielokrotnie podczas jednego wywo³ania <tt>MADS-a</tt>, np.:
<span style="color: #0000FF">
<pre>
 -i:"c:\program files" -i:c:\temp -i:"d:\atari project"
</pre>
</span>
<p></p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-l:filename</div>
<div align="justify">
Prze³±cznik <b><tt>-l</tt></b> w³±cza zapis pliku z listingiem. Pozwala tak¿e okre¶liæ now± nazwê dla takiego pliku.
</p>



</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-m:filename</div>
<div align="justify">
Prze³±cznik <b><tt>-m</tt></b> s³u¿y do okre¶lenia pliku z deklaracjami makr. W przypadku jego u¿ycia <tt>MADS</tt> asembluje taki plik przed g³ównym plikiem <tt>.ASM</tt>
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-o:filename</div>
<div align="justify">
Prze³±cznik <b><tt>-o</tt></b> pozwala okre¶liæ now± nazwê pliku wykonywalnego <tt>Atari DOS</tt> lub <tt>Atari Sparta DOS X</tt>, który powstanie po procesie asemblacji.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-p</div>
<div align="justify">
Prze³±cznik <b><tt>-p</tt></b> pomocny jest w po³±czeniu z Code Genie. Gdy wyst±pi b³±d podczas asemblacji, w oknie Output Bar edytora Code Genie pojawi siê stosowny komunikat wygenerowany przez <tt>MADS</tt>, np.:
<span style="color: #0000FF">
<pre>
D:\!Delphi\Masm\test.asm (29) ERROR: Missing .PROC
</pre>
</span>
Teraz wystarczy klikn±æ dwukrotnie liniê z tym komunikatem, a kursor edytora ustawi siê w linii z b³êdem.
<p></p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-s</div>
<div align="justify">
U¿ycie prze³±cznika <b><tt>-s</tt></b> spowoduje uaktywnienie tzw. trybu pracy <tt>'Silent mode'</tt>, czyli ¿adne komunikaty nie zostan± wy¶wietlone, co najwy¿ej komunikaty b³êdów <tt>(ERROR)</tt> i ostrze¿enia <tt>(WARNING)</tt>.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-t[:filename]</div>
<div align="justify">
Prze³±cznik <b><tt>-t</tt></b> w³±cza zapis pliku z u¿ytymi definicjami etykiet. Pozwala tak¿e okre¶liæ now± nazwê dla takiego pliku.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-x</div>
<div align="justify">
Prze³±cznik <b><tt>-x</tt></b> pozwala na pominiêcie w procesie asemblacji procedur zadeklarowanych dyrektyw± <b>.PROC</b>, do których nie nast±pi³o odwo³anie w programie.
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-vu</div>
<div align="justify">
Prze³±cznik <b><tt>-vu</tt></b> wymusza dodatkowy test kodu w blokach .PROC mimo tego ¿e taki blok .PROC nie zostanie zapisany do pliku wynikowego, najczê¶ciej przydaje siê gdy u¿ywamy prze³±cznika <b>-x</b>
</p>


</div>
<p>
<div style="font-weight: bold"  style="font-size: 18px">-u</div>
<div align="justify">
Prze³±cznik <b><tt>-u</tt></b> wy¶wietli etykiety które nie zosta³y u¿yte w programie.
</p>

<br />




<A NAME="err">
<u><tt><h2>Kody wyj¶cia</h2></tt></u>

<span style="color: #0000FF">
<pre>
3 = bad parameters, assembling not started
2 = error occured
0 = no errors
</pre>
</span>

Komunikaty ostrze¿enia nie powoduj± zmiany warto¶ci kodu wyj¶cia.
<p></p>
<br />



<A NAME="lst">
<u><tt><h2>Struktura pliku LST</h2></tt></u>

<p>
Format listingu nie odbiega od tego znanego z <tt>XASM</tt>, jedyn± zmian± jest
dodanie przed adresem, numeru wirtualnego banku pamiêci (pod warunkiem ¿e numer banku <>0). Wiêcej o wirtualnych bankach w rozdziale <A HREF="#banks">Banki pamiêci</A>.
</p>

<span style="color: #0000FF">
<pre>
     3
     4 = 01,9033		obraz equ $9033
     5 = 01,00A0		scr1 equ $a0
     6
     7
     8 01,2000 EA		main nop
</pre>
</span>
<br />


<A NAME="lab">
<u><tt><h2>Struktura pliku LAB</h2></tt></u>

<p>
Podobnie jak w przypadku <tt>XASM</tt>, w pliku <tt>*.LAB</tt> przechowywane s± informacje
na temat etykiet które wyst±pi³y w programie.
</p>

<u>W sumie s± to trzy kolumny:</u>
<p>
<li>Pierwsza kolumna to numer wirtualnego banku przypisany do etykiety (je¶li bank <>0)
<li>Druga kolumna to warto¶æ etykiety.
<li>Trzecia kolumna to nazwa etykiety.
</p>

Numery wirtualnych banków przypisane do etykiety o warto¶ciach &gt= $FFF9 maj± specjalne znaczenie:
<pre>
 $FFF9   etykieta parametru procedury zdefiniowanej przez dyrektywê .PROC
 $FFFA   etykieta tablicy zdefiniowanej przez dyrektywê .ARRAY
 $FFFB   etykieta danych strukturalnych zdefiniowanej przez pseudo rozkaz DTA STRUCT_LABEL
 $FFFC   etykieta symbolu Sparta DOS X - SMB
 $FFFD   etykieta makra zdefiniowanego przez dyrektywê .MACRO
 $FFFE   etykieta struktury zdefiniowanej przez dyrektywê .STRUCT
 $FFFF   etykieta procedury zdefiniowanej przez dyrektywê .PROC
</pre>

<p>
<u>Specjalne znaczenie w nazwach etykiet maj± znaki:</u>
</p>
<p>
<li>etykieta zdefiniowana w makrze (dwa dwukropki) <tt>::</tt>
<li>znak kropki <tt>'.'</tt> rozdziela nazwê struktury (<tt>.MACRO, .PROC, .LOCAL, .STRUCT</tt>) od nazwy pola w strukturze
</p>

<p>
Warto¶æ liczbowa, która wystêpuje po <tt>::</tt> oznacza numer wywo³ania makra.
</p>

<span style="color: #0000FF">
<pre>
Mad-Assembler v1.4.2beta by TeBe/Madteam
Label table:
00	0400	@STACK_ADDRESS
00	00FF	@STACK_POINTER
00	2000	MAIN
00	2019	LOOP
00	201C	LOOP::1
00	201C	LHEX
00	0080	LHEX.HLP
00	204C	LHEX.THEX
00	205C	HEX
00	205C	HEX.@GETPAR0.LOOP
00	2079	HEX.@GETPAR1.LOOP
</pre>
</span>
<br />


<A NAME="plikh">
<u><tt><h2>Struktura pliku H</h2></tt></u>

<p>
Nie jestem pewien czy wszystko z tym plikiem jest OK, ale Eru chcia³ ¿eby co¶ takiego by³o wiêc jest :)
Ma on byæ pomocny przy ³±czeniu <tt>ASM-a</tt> z <tt>CC65</tt>, czyli portem <tt>C</tt> dla ma³ego Atari. Jego zawarto¶æ mo¿e wygl±daæ tak (przyk³adowy plik <tt>TEST.ASM</tt>):
</p>

<span style="color: #0000FF">
<pre>
#ifndef _TEST_ASM_H_
#define _TEST_ASM_H_

#define TEST_CPU65816 0x200F
#define TEST_CPU6502 0x2017
#define TEST_TEXT6502 0x201F
#define TEST_TEXT65816 0x2024

#endif
</pre>
</span>
<br />


<A NAME="makrorozkazy">
<p class="duzy">
MAKRO ROZKAZY
</p>


<span style="color: #0000FF">
<pre>
 <A HREF="#_req">REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS</A>

 <A HREF="#_seq">SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS</A>

 <A HREF="#_jeq">JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS</A>

 <A HREF="#_add">ADD, SUB</A>

 <A HREF="#_adb">ADB, SBB</A>

 <A HREF="#_adw">ADW, SBW</A>

 <A HREF="#_phr">PHR, PLR</A>

 <A HREF="#_inw">INW, INL, IND, DEW, DEL, DED</A>

 <A HREF="#_mv">MVA, MVX, MVY</A>

 <A HREF="#_mw">MWA, MWX, MWY</A>

 <A HREF="#_cp">CPB, CPW, CPL, CPD</A>
</pre>
</span>

Zadaniem makro rozkazów jest skrócenie czasu pisania programu i samego listingu. Makro rozkazy zastêpuj± grupy czêsto powtarzaj±cych siê mnemoników.

<p></p>


<A NAME="_req">
<p>
<u><tt><h3>REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS</h3></tt></u>
<p>
W/w makro rozkazy swoimi nazwami nawi±zuj± do odpowiednich mnemoników <tt>6502</tt>, odpowiednio <tt>BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS</tt>. Posiadaj± dodatkow± w³a¶ciwo¶æ jak± jest skok do poprzednio asemblowanej instrukcji, np.:
</p>
<span style="color: #0000FF">
<pre>
   lda:cmp:req 20           ->      lda 20
                            -> wait cmp 20
                            ->      beq wait

   ldx #0                   ->      ldx #0 
   mva:rne $500,x $600,x+   -> loop lda $500,x
                            ->      sta $600,x
                            ->      inx
                            ->      bne loop
</pre> 
</span>
<br />


<A NAME="_seq">
<p>
<u><tt><h3>SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS</h3></tt></u>
<p>
W/w makro rozkazy swoimi nazwami nawi±zuj± do odpowiednich mnemoników <tt>6502</tt>, odpowiednio <tt>BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS</tt>. Posiadaj± dodatkow± w³a¶ciwo¶æ jak± jest skok do nastêpnej asemblowanej instrukcji, np.:
</p>
<span style="color: #0000FF">
<pre>
   lda #40         ->       lda #40
   add:sta  $80    ->       clc
   scc:inc  $81    ->       adc $80
                   ->       sta $80
                   ->       bcc skip
                   ->       inc $81
                   ->  skip
</pre> 
</span>
<br />


<A NAME="_jeq">
<p>
<u><tt><h3>JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS</h3></tt></u>
<p>
W/w makro rozkazy swoimi nazwami nawi±zuj± do odpowiednich mnemoników <tt>6502</tt>, odpowiednio <tt>BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS</tt>. Posiadaj± dodatkow± w³a¶ciwo¶æ jak± jest skok warunkowy pod wskazany adres, z ich pomoc± mo¿emy skakaæ nie tylko w zakresie -128..+127 bajtów ale w ca³ym zakresie 64kB np.:
</p>

<span style="color: #0000FF">
<pre>
 jne dest   ->  beq *+4
            ->  jmp dest
</pre> 
</span>

Je¶li skok jest krótki (zakres -128..+127) wówczas MADS u¿yje krótkiego skoku, odpowiednio BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS.
<p></p>
<br />


<A NAME="_add">
<p>
<u><tt><h3>ADD, SUB</h3></tt></u>
<p>
W/w makro rozkazy realizuj± odpowiednio zwiêkszenie/zmniejszenie bajtu pamiêci bez zapisywania wyniku (wynik w akumulatorze CPU).
<span style="color: #0000FF">
<pre>
  ADD -> CLC         SUB -> SEC
      -> ADC ...         -> SBC ...
</pre>
</span>
<p></p>
<br />


<A NAME="_adb">
<p>
<u><tt><h3>ADB, SBB</h3></tt></u>
<p>
W/w makro rozkazy realizuj± odpowiednio zwiêkszenie/zmniejszenie bajtu pamiêci z zapisaniem wyniku.
<span style="color: #0000FF">
<pre>
  ADB SRC #$40 -> LDA SRC       ADB A B C  -> LDA A
               -> CLC                      -> CLC
               -> ADC #$40                 -> ADC B
               -> STA SRC                  -> STA C

  SBB SRC #$80 -> LDA SRC       SBB A B C  -> LDA A
               -> SEC                      -> SEC
               -> SBC #$80                 -> SBC B
               -> STA SRC                  -> STA C
</pre>
</span>
<p></p>
<br />


<A NAME="_adw">
<p>
<u><tt><h3>ADW, SBW</h3></tt></u>
<p>
W/w makro rozkazy realizuj± odpowiednio zwiêkszenie/zmniejszenie s³owa pamiêci z zapisaniem wyniku. 
<span style="color: #0000FF">
<pre>
  ADW SRC #$40 -> CLC             ADW A B C  -> CLC
               -> LDA SRC                    -> LDA A
               -> ADC #$40                   -> ADC B
               -> STA SRC                    -> STA C
               -> SCC                        -> LDA A+1
               -> INC SRC+1                  -> ADC B+1
                                             -> STA C+1

  ADW SRC #$40 SRC -> CLC
                   -> LDA SRC
                   -> ADC #$40
                   -> STA SRC
                   -> LDA SRC+1
                   -> ADC #$00
                   -> STA SRC+1
                                             
  SBW SRC #$4080 -> SEC           SBW A B C  -> SEC
                 -> LDA SRC                  -> LDA A
                 -> SBC &lt$4080               -> SBC B
                 -> STA SRC                  -> STA C
                 -> LDA SRC+1                -> LDA A+1
                 -> SBC &gt$4080               -> SBC B+1
                 -> STA SRC+1                -> STA C+1 
</pre>
</span>
<p></p>
<br />


<A NAME="_phr">
<p>
<u><tt><h3>PHR, PLR</h3></tt></u>
<p>
W/w makro rozkazy swoimi nazwami nawi±zuj± do odpowiednich mnemoników <tt>6502</tt>, odpowiednio <tt>PHA, PLA</tt>, realizuj± odk³adanie na stosie i zdejmowanie ze stosu rejestrów A,X,Y.
<span style="color: #0000FF">
<pre>
  PHR  -> PHA         PLR  -> PLA
       -> TXA              -> TAY
       -> PHA              -> PLA
       -> TYA              -> TAX
       -> PHA              -> PLA
</pre>
</span>
<p></p>
<br />


<A NAME="_inw">
<p>
<u><tt><h3>INW, INL, IND, DEW, DEL, DED</h3></tt></u>
<p>
Makro rozkazy <b>INW</b>, <b>INL</b>, <b>IND</b> realizuj± zwiêkszenie odpowiednio s³owa pamiêci (.WORD), d³ugiego s³owa pamiêci (.LONG), podwójnego s³owa pamiêci (.DWORD).
<p></p>
Makro rozkazy <b>DEW</b>, <b>DEL</b>, <b>DED</b> realizuj± zmniejszenie odpowiednio s³owa pamiêci (.WORD), d³ugiego s³owa pamiêci (.LONG), podwójnego s³owa pamiêci (.DWORD) i wykorzystuj± w tym celu akumulator CPU (zawarto¶æ akumulatora ulega zmianie po wykonaniu makro rozkazów DEW, DEL, DED).
<span style="color: #0000FF">
<pre>
    inw dest  ->       inc dest    ->   inc dest
              ->       bne skip    ->   sne
              ->       inc dest+1  ->   inc dest+1
              ->  skip             ->

    dew dest  ->       lda dest    ->   lda dest
              ->       bne skip    ->   sne
              ->       dec dest+1  ->   dec dest+1
              ->  skip dec dest    ->   dec dest   
</pre>
</span>
<p></p>
<br />



<A NAME="_mv">
<p>
<u><tt><h3>MVA, MVX, MVY</h3></tt></u>
<p>
Makro rozkazy <b>MVA</b>, <b>MVX</b>, <b>MVY</b> s³u¿± do przenoszenia bajtów (.BYTE) pamiêci przy pomocy rejestrów CPU odpowiednio A, X, Y. U¿ycie opcji <b>OPT R+</b> pozwala na potencjalne skrócenie kodu wynikowego dla nastêpuj±cych po sobie makro rozkazów MVA, MVX, MVY.
<span style="color: #0000FF">
<pre>
    lda src    ->  mva src dst
    sta dst    ->

    ldy $10,x  ->  mvy $10,x $a0,x
    sty $a0,x  ->

    ldx #$10   ->  mvx #$10 dst
    stx dst    ->
</pre>
</span>
<p></p>
<br />


<A NAME="_mw">
<p>
<u><tt><h3>MWA, MWX, MWY</h3></tt></u>
<p>
Makro rozkazy <b>MWA</b>, <b>MWX</b>, <b>MWY</b> s³u¿± do przenoszenia s³ów (.WORD) pamiêci przy pomocy rejestrów CPU odpowiednio A, X, Y. U¿ycie opcji <b>OPT R+</b> pozwala na potencjalne skrócenie kodu wynikowego dla nastêpuj±cych po sobie makro rozkazów MWA, MWX, MWY.
<span style="color: #0000FF">
<pre>
    ldx &ltadr    ->  mwx #adr dst
    stx dst     ->
    ldx &gtadr    ->
    stx dst+1   ->

    mwa #0 $80  ->  lda #0           mwy #$3040 $80  ->  ldy <$3040
                ->  sta $80                          ->  sty $80
                ->  sta $81                          ->  ldy >$3040
                                                     ->  sty $81

    mwa ($80),y $a000,x  ->  lda ($80),y
                         ->  sta $a000,x
                         ->  iny
                         ->  lda ($80),y
                         ->  sta $a001,x
</pre>
</span>
<p></p>
<br />


<A NAME="_cp">
<p>
<u><tt><h3>CPB, CPW, CPL, CPD</h3></tt></u>
<p>
Makro rozkazy <b>CPB</b>, <b>CPW</b>, <b>CPL</b>, <b>CPD</b> realizuj± porównanie warto¶ci odpowiednich typów, odpowiednio .BYTE, .WORD, .LONG, .DWORD.
<span style="color: #0000FF">
<pre>
 cpw temp #$4080
 bcc skip

 cpd v0 v1
 beq skip
</pre>
</span>
<p></p>
<br />




<A NAME="pseudo">
<p class="duzy">
PSEUDO ROZKAZY
</p>


<span style="color: #0000FF">
<pre>
 <A HREF="#_ift">IFT</A> [.IF] expression
 <A HREF="#_ift">ELS</A> [.ELSE]
 <A HREF="#_ift">ELI</A> [.ELSEIF] expression
 <A HREF="#_ift">EIF</A> [.ENDIF]
 
 <A HREF="#_error">ERT</A> ERT 'string'["string"] | ERT expression

 label EQU expression
 label  =  expression

 label <A HREF="#_set">SET</A> expression
 
 label <A HREF="#labels_ext">EXT</A> type

 <A HREF="#_opt">OPT</A> [bcfhlmorst][+-]
 <A HREF="#_org">ORG</A> [[expression]]address[,address2]
 <A HREF="#_ins">INS</A> 'filename'["filename"][*][+-value][,+-ofset[,length]]
 <A HREF="#_icl">ICL</A> 'filename'["filename"]
 <A HREF="#_dta">DTA</A> [abfghltvmer](value1,value2...)[(value1,value2...)]
 
 DTA [cd]'string'["string"]
 RUN expression
 INI expression
 <A HREF="#_en">END</A> [.EN]

 <A HREF="#_sin">SIN</A> (centre,amp,size[,first,last])
 <A HREF="#_cos">COS</A> (centre,amp,size[,first,last])
 
 <A HREF="#_rnd">RND</A> (min,max,length)

 <A HREF="#_repeat">:repeat</A>

 <A HREF="#_blk">BLK</A> N[one] X
 <A HREF="#_blk">BLK</A> D[os] X
 <A HREF="#_blk">BLK</A> S[parta] X
 <A HREF="#_blk">BLK</A> R[eloc] M[ain]|E[xtended]
 <A HREF="#_blk">BLK</A> E[mpty] X M[ain]|E[xtended]
 <A HREF="#_blk">BLK</A> U[pdate] S[ymbols]
 <A HREF="#_blk">BLK</A> U[pdate] E[xternal]
 <A HREF="#_blk">BLK</A> U[pdate] A[dress]
 <A HREF="#_blk">BLK</A> U[pdate] N[ew] X 'string'

 label <A HREF="#_smb">SMB</A> 'string'

 <A HREF="#_nmb">NMB</A>
 <A HREF="#_rmb">RMB</A>
 <A HREF="#_lmb">LMB</A> #expression
</pre>
</span>


<p>
Czyli w wiêkszo¶ci po staremu, chocia¿ parê zmian zasz³o. W przypadku cudzys³owów mo¿na u¿ywaæ <tt>' '</tt> lub <tt>" "</tt>. Oba rodzaje cudzys³owów traktowane s± jednakowo z wyj±tkiem adresowania (dla <tt>''</tt> zostanie wyliczona warto¶æ ATASCII znaku, dla <tt>""</tt> zostanie wyliczona warto¶æ INTERNAL znaku).
</p>
<br />


<A NAME="_blk">
<p>
<u><tt><h3>BLK</h3></tt></u>
<pre>
 BLK N[one] X                    - blok bez nag³ówków, licznik programu ustawiany na X

 BLK D[os] X                     - blok DOS-a z nag³ówkiem $FFFF lub bez nag³ówka gdy
                                   poprzedni taki sam, licznik programu ustawiany na X

 BLK S[parta] X                  - blok o sta³ych adresach ³adowania z nag³ówkiem $FFFA,
                                   licznik programu ustawiany na X

 BLK R[eloc] M[ain]|E[xtended]   - blok relokowalny umieszczany w pamiêci MAIN lub EXTENDED

 BLK E[mpty] X M[ain]|E[xtended] - blok relokowalny rezerwuj±cy X bajtów w pamiêci MAIN lub EXTENDED
                                   <b>UWAGA:</b> licznik programu jest natychmiastowo zwiêkszany o X bajtów

 BLK U[pdate] S[ymbols]          - blok aktualizuj±cy w poprzednich blokach SPARTA lub
                                   RELOC adresy symboli SDX

 BLK U[pdate] E[xternal]         - blok aktualizuj±cy adresy etykiet external (nag³ówek $FFEE)
                                   <b>UWAGA:</b> nie dotyczy Sparta DOS X, jest to rozszerzenie MADS-a

 BLK U[pdate] A[dress]           - blok aktualizacji adresów w blokach RELOC

 BLK U[pdate] N[ew] X 'string'   - blok deklaruj±cy nowy symbol 'string' w bloku RELOC
                                   o adresie X. Gdy nazwa symbolu poprzedzona jest znakiem @,
                                   a adres jest z pamiêci podstawowej to taki symbol mo¿e byæ
                                   wywo³ywany z command.com
</pre>
Wiêcej informacji na temat bloków w plikach <tt>Sparta DOS X</tt> w rozdziale <A HREF="#sdx">Budowa plików SPARTA DOS X</A> oraz <A HREF="#sdx">Programowanie SPARTA DOS X</A>.
<p></p>
<br />


<A NAME="_set">
<u><tt><h3>label SET expression</h3></tt></u>
<p>
Pseudorozkaz SET pozwala redefiniowaæ etykietê, ma podobne dzia³anie jak etykiety tymczasowe zaczynaj±ce siê znakiem '?', np.:

<span style="color: #0000FF">
<pre>
temp set 12

     lda #temp

temp set 23

     lda #temp
</pre>
</span>
<br />



<A NAME="_smb">
<u><tt><h3>label SMB 'string'</h3></tt></u>
<p>
Deklaracja etykiety jako symbolu <tt>SDX</tt>. Symbol mo¿e mieæ maksymalnie d³ugo¶æ 8-iu znaków. Dziêki temu po u¿yciu <b><tt>BLK UPDATE SYMBOLS</tt></b> asembler wygeneruje poprawny blok aktualizacji symboli. Np:
<span style="color: #0000FF">
<pre>
       pf  smb 'PRINTF'
           jsr pf
           ...
</pre>
</span>

sprawi ¿e po instrukcji <b><tt>JSR</tt></b> system <tt>SDX</tt> wstawi adres symbolu.
</p>

<b><tt>Uwaga:</tt></b> deklaracja ta nie jest przechodnia, to znaczy ¿e poni¿szy przyk³ad spowoduje b³êdy w czasie kompilacji:
<span style="color: #0000FF">
<pre>
       cm  smb 'COMTAB'
       wp  equ cm-1       (b³±d !)

           sta wp
</pre>
</span>

Zamiast tego nale¿y u¿yæ:
<span style="color: #0000FF">
<pre>
       cm  smb 'COMTAB'

           sta cm-1       (ok !)
</pre>
</span>
<p>
<b><tt>Uwaga:</tt></b> wszystkie deklaracje symboli nale¿y u¿yæ przed deklaracjami etykiet, jak i programem w³a¶ciwym !
</p>
<br />



<A NAME="_repeat">
<p>
<u><tt><h3>:repeat</h3></tt></u>
<span style="color: #0000FF">
<pre>
Example: 
           :4 asl @
           :2 dta a(*)
           :256 dta #/8

ladr :4 dta l(line:1)
hadr :4 dta h(line:1)           
</pre>
</span>
Znak <tt>':'</tt> okre¶la liczbê powtórzeñ linii <i>(w przypadku makr okre¶la numer parametru pod warunkiem ¿e warto¶æ liczbowa zapisana zosta³a w systemie decymalnym)</i>. Liczba powtórzeñ powinna byæ z zakresu <tt>&lt0..2147483647&gt</tt>. W powtarzanej linii ':repeat' mo¿liwe jest skorzystanie z licznika pêtli - znaku hash '#' lub z parametru :1.
</p>

Je¶li u¿yjemy znaku <tt>':'</tt> w makrze w znaczeniu liczby powtórzeñ linii, np.:
<span style="color: #0000FF">
<pre>
.macro test
 :2 lsr @
.endm
</pre>
</span>
Wówczas dla w/w przyk³adu znak <tt>':'</tt> zostanie zinterpretowany jako <b>drugi parametr makra</b>. Aby zapobiec takiej interpretacji przez <tt>MADS</tt>, nale¿y po znaku dwukropka <tt>':'</tt> umie¶ciæ znak który nic nie robi, np. znak plusa <tt>'+'</tt>.

<span style="color: #0000FF">
<pre>
.macro test
 :+2 lsr @
.endm
</pre>
</span>

<p>
Teraz znak dwukropka <tt>':'</tt> zostanie prawid³owo zinterpretowany jako <b>:repeat</b>
</p>
<br />


<A NAME="_opt">
<u><tt><h3>OPT</h3></tt></u>
Pseudo rozkaz <tt><b>OPT</b></tt> pozwala w³±czaæ/wy³±czaæ dodatkowe opcje podczas asemblacji.
<pre>
 b+  bank sensitive on
 b-  bank sensitive off                                               (default)
 c+  w³±cza obs³ugê CPU 65816 (16bit)
 c-  w³±cza obs³ugê CPU 6502 (8bit)                                   (default)
 f+  plik wynikowy w postaci jednego bloku (przydatne dla carta)
 f-  plik wynikowy w postaci blokowej                                 (default)
 h+  zapisuje nag³ówek pliku dla DOS                                  (default)
 h-  nie zapisuje nag³ówka pliku dla DOS
 l+  zapisuje listing do pliku (LST)
 l-  nie zapisuje listingu (LST)                                      (default)
 m+  zapisuje ca³e makra w listingu
 m-  zapisuje w listingu tylko t± czê¶æ makra która zostaje wykonana  (default)
 o+  zapisuje wynik asemblacji do pliku wynikowego (OBX)              (default)
 o-  nie zapisuje wyniku asemblacji do pliku wynikowego (OBX)
 r+  optymalizacja d³ugo¶ci kodu dla MVA, MVX, MVY, MWA, MWX, MWY
 r-  bez optymalizacji d³ugo¶ci kodu dla MVA, MVX, MVY, MWA, MWX, MWY (default)
 s+  drukuje listing na ekranie
 s-  nie drukuje listingu na ekranie                                  (default)
 t+  track SEP REP on (CPU 65816)
 t-  track SEP REP off (CPU 65816)                                    (default)
 ?+  etykiety ze znakiem '?' na pocz±tku s± lokalne (styl MAE)
 ?-  etykiety ze znakiem '?' na pocz±tku s± tymczasowe                (default)
<span style="color: #0000FF">
Example:
 
 OPT c+ c  - l  + s +
 OPT h-
 OPT o +
</pre>
</span>

<p>
Wszystkie opcje <b><tt>OPT</tt></b> mo¿emy u¿ywaæ w dowolnym miejscu listingu, czyli np. mo¿emy w³±czyæ zapis listingu w linii 12, a w linii 20 wy³±czyæ itd., wówczas plik z listingiem bêdzie zawiera³ tylko linie 12..20.
</p>
Je¶li chcemy u¿yæ trybów adresowania <tt>65816</tt>, musimy o tym poinformowaæ asembler przez <b><tt>'OPT C+'</tt></b>.

<p>
Je¶li u¿ywamy CodeGenie mo¿emy u¿yæ <b><tt>'OPT S+'</tt></b>, dziêki temu nie musimy przechodziæ do pliku z listingiem, bo listing wydrukowany zosta³ w dolnym okienku (Output Bar).
</p>
<br />



<A NAME="_org">
<u><tt><h3>ORG</h3></tt></u>
Pseudo rozkaz <tt><b>ORG</b></tt> ustawia nowy adres asemblacji, a wiêc i lokalizacjê zasemblowanych danych w pamiêci <tt>RAM</tt>.
<pre>
 adr                 asembluj od adresu ADR, ustaw adres w nag³ówku pliku na ADR
 adr,adr2            asembluj od adresu ADR, ustaw adres w nag³ówku pliku na ADR2
 [b($ff,$fe)]        zmieñ nag³ówek na $FFFE (zostan± wygenerowane 2 bajty)
 [$ff,$fe],adr       zmieñ nag³ówek na $FFFE, ustaw adres w nag³ówku pliku na ADR
 [$d0,$fe],adr,adr2  zmieñ nag³ówek na $D0FE, asembluj od adresu ADR, ustaw adres w nag³ówku pliku na ADR2
 [a($FFFA)],adr      nag³ówek SpartaDOS $FAFF, ustaw adres w nag³ówku pliku na ADR
<span style="color: #0000FF">
Example:

 opt h-
 ORG [a($ffff),d'atari',c'ble',20,30,40],adr,adr2
</pre>
</span>

<p>
Nawiasy kwadratowe <b><tt>[ ]</tt></b> s³u¿± okre¶leniu nowego nag³ówka, który mo¿e byæ dowolnej d³ugo¶ci. Pozosta³e warto¶ci za zamykaj±cym nawiasem kwadratowym <tt>']'</tt>, rozdzielone znakiem przecinka <tt>','</tt> oznaczaj± odpowiednio: adres asemblacji, adres w nag³ówku pliku.
</p>
Przyk³ad nag³ówka dla pliku w postaci jednego bloku, asemblowanego od adresu $2000, w nag³ówku podany adres pocz±tkowy i adres koñcowy bloku.

<span style="color: #0000FF">
<pre>
Example:

 opt h-f+
 ORG [a(start), a(over-1)],$2000

start
 nop
 .ds 128
 nop
over
</pre>
</span>

<br />



<A NAME="_ins">
<u><tt><h3>INS 'filename'["filename"][*][+-value][,+-ofset[,length]]</h3></tt></u>
<p>
Pseudo rozkaz <tt><b>INS</b></tt> pozwala na do³±czenie dodatkowego pliku binarnego. Do³±czany plik nie musi znajdowaæ siê w tym samym katalogu co g³ówny asemblowany plik. Wystarczy, ¿e odpowiednio wskazali¶my <tt>MADS-owi</tt> ¶cie¿ki poszukiwañ za pomoc± prze³±cznika <tt><b>/i</b></tt> (patrz <A HREF="#switches">Prze³±czniki assemblera</A>).
</p>
Dodatkowo mo¿na przeprowadziæ na do³±czanym pliku binarnym operacje:
<pre>
*          invers bajtów pliku binarnego
+-VALUE    zwiêkszenie/zmniejszenie warto¶ci bajtów pliku binarnego o warto¶æ wyra¿enia VALUE

+OFSET     ominiêcie OFSET bajtów z pocz±tku pliku binarnego (SEEK OFSET)
-OFSET     odczyt pliku binarnego od jego koñca              (SEEK FileLength-OFSET)

LENGTH     odczyt LENGTH bajtów pliku binarnego
</pre>

Je¶li warto¶æ <tt>LENGTH</tt> nie zosta³a okre¶lona, domy¶lnie plik binarny zostanie odczytany a¿ do koñca.
<p></p>
<br />



<A NAME="_icl">
<u><tt><h3>ICL 'filename'["filename"]</h3></tt></u>
<p>
Pseudo rozkaz <tt><b>ICL</b></tt> pozwala na do³±czenie dodatkowego pliku ¼ród³owego i jego asemblacjê. Do³±czany plik nie musi znajdowaæ siê w tym samym katalogu co g³ówny asemblowany plik. Wystarczy, ¿e odpowiednio wskazali¶my <tt>MADS-owi</tt> ¶cie¿ki poszukiwañ za pomoc± prze³±cznika <tt><b>/i</b></tt> (patrz <A HREF="#switches">Prze³±czniki assemblera</A>).
</p> 
<br />



<A NAME="_dta">
<u><tt><h3>DTA</h3></tt></u>
Pseudo rozkaz <tt><b>DTA</b></tt> s³u¿y do definicji danych okre¶lonego typu. Je¶li typ nie zosta³ okre¶lony wówczas domy¶lnie zostanie ustawiony typ BYTE (b).
<pre>
   b   warto¶æ typu BYTE
   a   warto¶æ typu WORD
   v   warto¶æ typu WORD, relokowalna
   l   m³odszy bajt warto¶ci (BYTE)
   h   starszy bajt warto¶ci (BYTE)
   m   najstarszy bajt warto¶ci LONG (24bit)
   g   najstarszy bajt warto¶ci DWORD (32bit)     
   t   warto¶æ typu LONG (24bit)
   e   warto¶æ typu LONG (24bit)
   f   warto¶æ typu DWORD (32bit)
   r   warto¶æ typu DWORD w odróconej kolejno¶ci (32 bit)
   c   ci±g znaków ATASCII ograniczony apostrofami '' lub "", znak <b>*</b> na koñcu spowoduje
       invers warto¶ci ci±gu, np. dta c'abecadlo'*
   d   ci±g znaków INTERNAL ograniczony apostrofami '' lub "", znak <b>*</b> na koñcu spowoduje
       invers warto¶ci ci±gu, np. dta d'abecadlo'*
<span style="color: #0000FF">
Example:

  dta 1 , 2, 4
  dta a ($2320 ,$4444)
  dta d'sasasa', 4,a ( 200 ), h($4000)
  dta  c  'file' , $9b
  dta c'invers'*
</pre>
</span>
<p></p>
<br />


<A NAME="_sin">
<u><tt><h3>SIN(centre,amp,size[,first,last])</h3></tt></u>
<pre>
where: 

centre     is a number which is added to every sine value 
amp        is the sine amplitude 
size       is the sine period 
first,last define range of values in the table. They are optional.
           Default are 0,size-1. 
<span style="color: #0000FF">
Example: dta a(sin(0,1000,256,0,63))
         defines table of 64 words representing a quarter of sine with
         amplitude of 1000.
</pre>
</span>
<br />


<A NAME="_cos">
<u><tt><h3>COS(centre,amp,size[,first,last])</h3></tt></u>
<pre>
where: 

centre     is a number which is added to every cosine value 
amp        is the cosine amplitude 
size       is the cosine period 
first,last define range of values in the table. They are optional.
           Default are 0,size-1. 
<span style="color: #0000FF">
Example: dta a(cos(0,1000,256,0,63))
         defines table of 64 words representing a quarter of cosine with
         amplitude of 1000.
</pre>
</span>
<br />


<A NAME="_rnd">
<p>
<u><tt><h3>RND(min,max,length)</h3></tt></u>
Ten pseudo rozkaz umo¿liwia wygenerowanie <tt>LENGTH</tt> losowych warto¶ci z przedzia³u <tt>&ltMIN..MAX&gt</tt>.
<span style="color: #0000FF">
<pre>
Example: dta b(rnd(0,33,256))
</pre>
</span>
<br />


<A NAME="_ift">
<u><tt><h3>IFT, ELS, ELI, EIF</h3></tt></u>
<span style="color: #0000FF">
<pre>
 IFT [.IF] expression
 ELS [.ELSE]
 ELI [.ELSEIF] expression
 EIF [.ENDIF]
</pre>
</span>
<p>
W/w pseudo rozkazy i dyrektywy wp³ywaj± na przebieg asemblacji (mo¿na ich u¿ywaæ zamiennie).
</p>
<br />



<A NAME="dyrekt">
<p class="duzy">
DYREKTYWY
</p>

<span style="color: #0000FF">
<pre>

 <A HREF="#_ai">.A8, .A16, .AI8, .AI16</a>
 <A HREF="#_ia">.I8, .I16, .IA8, .IA16</a>

 <A HREF="#_asize">.ASIZE</a>
 <A HREF="#_isize">.ISIZE</a>
  
 <A HREF="#_align">.ALIGN</a> N[,fill]
 
 <A HREF="#arrays">.ARRAY</A> label [elements0][elements1][...] .type [= init_value]
 <A HREF="#arrays">.ENDA, [.AEND]</A>

 <A HREF="#_def">.DEF</A> label [= expression]
 
 <A HREF="#_defi">.DEFINE</A> macro_name expression
 <A HREF="#_udef">.UNDEF</A> macro_name

 <A HREF="#enums">.ENUM</A> label
 <A HREF="#enums">.ENDE, [.EEND]</A>

 <A HREF="#_error">.ERROR</A> [ERT] 'string'["string"] lub .ERROR [ERT] expression

 <A HREF="#labels_ext">.EXTRN</A> label [,label2,...] type

 <A HREF="#warun">.IF</A> [IFT] expression
 <A HREF="#warun">.ELSE</A> [ELS]
 <A HREF="#warun">.ELSEIF</A> [ELI] expression
 <A HREF="#warun">.ENDIF</A> [EIF]

 <A HREF="#_ifdef">.IFDEF</A> label
 <A HREF="#_ifndef">.IFNDEF</A> label

 <A HREF="#locals">.LOCAL</A> label
 <A HREF="#locals">.ENDL, [.LEND]</A>
 
 <A HREF="#_longa">.LONGA ON|OFF</A>
 <A HREF="#_longi">.LONGI ON|OFF</A>

 <A HREF="#_link">.LINK</A> 'filename'
 
 <A HREF="#macros">.MACRO</A> label
 <A HREF="#macros">.ENDM, [.MEND]</A>
 <A HREF="#macros">:[%%]parameter</A>
 <A HREF="#macros">.EXITM</A> [.EXIT]

 <A HREF="#_nowarn">.NOWARN</A>

 <A HREF="#_print">.PRINT</A> [.ECHO] 'string1','string2'...,value1,value2,...

 <A HREF="#_pages">.PAGES</A> [expression]
 <A HREF="#_pages">.ENDPG, [.PGEND]</A> 

 <A HREF="#labels_pub">.PUBLIC, [.GLOBAL], [.GLOBL]</A> label [,label2,...]

 <A HREF="#procs">.PROC</A> label
 <A HREF="#procs">.ENDP, [.PEND]</A>
 <A HREF="#procs">.REG, .VAR</A>

 <A HREF="#_rept">.REPT</A> expression [,parameter1, parameter2, ...]
 <A HREF="#_rept">.ENDR, [.REND]</A>
 <A HREF="#_rept">.R</A>

 <A HREF="#_reloc">.RELOC</A> [.BYTE|.WORD]

 <A HREF="#structs">.STRUCT</A> label
 <A HREF="#structs">.ENDS, [.SEND]</A>

 <A HREF="#_symbol">.SYMBOL</a> label
 
 <A HREF="#_segment">.SEGDEF</a> label address length [bank]
 <A HREF="#_segment">.SEGMENT</a> label
 <A HREF="#_segment">.ENDSEG</a>
 
 <A HREF="#_using">.USING, [.USE]</A> proc_name, local_name

 <A HREF="#__var">.VAR</A> var1[=value],var2[=value]... (.BYTE|.WORD|.LONG|.DWORD)
 <A HREF="#__zpvar">.ZPVAR</A> var1, var2... (.BYTE|.WORD|.LONG|.DWORD)

 <A HREF="#__end">.END</A>

 <A HREF="#_en">.EN</A>

 <A HREF="#_byte">.BYTE</A>
 <A HREF="#_byte">.WORD</A>
 <A HREF="#_byte">.LONG</A>
 <A HREF="#_byte">.DWORD</A>

 <A HREF="#_or">.OR</A>
 <A HREF="#_or">.AND</A>
 <A HREF="#_or">.XOR</A>
 <A HREF="#_or">.NOT</A>

 <A HREF="#_lohi">.LO</A> (expression)
 <A HREF="#_lohi">.HI</A> (expression)

 <A HREF="#_dbyte">.DBYTE</A> words
 <A HREF="#_ds">.DS</A> expression

 <A HREF="#_by">.BY</A> [+byte] bytes and/or ASCII
 <A HREF="#_wo">.WO</A> words
 <A HREF="#_he">.HE</A> hex bytes
 <A HREF="#_sb">.SB</A> [+byte] bytes and/or ASCII
 <A HREF="#_cb">.CB</A> [+byte] bytes and/or ASCII
 <A HREF="#_fl">.FL</A> floating point numbers

 <A HREF="#_adr">.ADR</A> label
 <A HREF="#_len">.LEN</A> label ['filename']
 
 <A HREF="#_len">.SIZEOF</A> label
 <A HREF="#_len">.FILESIZE</A> 'filename' 
 <A HREF="#_fex">.FILEEXISTS</A> 'filename' 

 <A HREF="#_get">.GET</A> [index] 'filename'["filename"][*][+-value][,+-ofset[,length]]
 <A HREF="#_get">.WGET</A> [index] 
 <A HREF="#_get">.LGET</A> [index] 
 <A HREF="#_get">.DGET</A> [index] 
 <A HREF="#_put">.PUT</A> [index] = value
 <A HREF="#_sav">.SAV</A> [index] ['filename',] length
</pre>
</span>
<br />


<A NAME="_symbol">
<u><tt><h3>.SYMBOL label</h3></tt></u>
<p>
Dyrektywa .SYMBOL to odpowiednik pseudo rozkazu SMB z t± ró¿nic± ¿e nie trzeba podawaæ symbolu, symbolem jest etykieta <b>label</b>. Dyrektywê .SYMBOL mo¿na umieszczaæ w dowolnym miejscu bloku relokowalnego SDX (BLK RELOC) w przeciwieñstwie do SMB.

<p>
Je¶li wyst±pi³a dyrektywa .SYMBOL zostanie wygenerowany odpowiedni blok aktualizacji:
</p>

<span style="color: #0000FF">
<pre>
BLK UPDATE NEW LABEL 'LABEL'
</pre>
</span>

Wiêcej na temat deklaracji symboli SDX w rozdziale <A HREF="#_smb">Definiowanie symbolu SMB</A>.
<p></p>
<br />


<A NAME="_align">
<p>
<u><tt><h3>.ALIGN N [,fill]</h3></tt></u>
Dyrektywa .ALIGN pozwala wyrównaæ adres asemblacji do zadanej warto¶ci N, oraz potencjalnie wype³niæ pamiêæ zadan± warto¶ci± FILL. Mo¿liwe jest wyrównanie adresu asemblacji dla kodu relokowalnego pod warunkiem ¿e podamy warto¶æ wype³nienia pamiêci FILL.
<p>
Domy¶lne warto¶ci to: N=$0100, FILL=0.
</p>


<span style="color: #0000FF">
<pre>
Example:

 .align

 .align $400
 
 .align $100,$ff
</pre>
</span>

<br />
<p></p>


<A NAME="_rept">
<p>
<u><tt><h3>.REPT expression [,parameter1, parameter2, ...]</h3></tt></u>
Dyrektywa <b><tt>REPT</tt></b> jest rozwiniêciem <a href="#_repeat"><b>:repeat</b></a> z t± ró¿nic±, ¿e nie jest powtarzana jedna linia, tylko zaznaczony blok programu. Pocz±tek bloku definiowany jest dyrektyw± <b><tt>.REPT</tt></b>, po niej musi wyst±piæ warto¶æ lub wyra¿enie arytmetyczne okre¶laj±ce liczbê powtórzeñ z zakresu <b><tt>&lt0..2147483647&gt</tt></b>, po liczbie powtórzeñ opcjonalnie mog± wyst±piæ parametry. W przeciwieñstwie do makr parametry dla .REPT zawsze s± najpierw obliczane i dopiero ich wynik jest podstawiany (t± w³a¶ciwo¶æ mo¿na wykorzystaæ do definiowania nowych etykiet). Z parametrów w bloku .REPT korzystamy podobnie jak z parametrów w bloku .MACRO. Koniec bloku .REPT definiuje dyrektywa <b><tt>.ENDR</tt></b>, przed któr± nie powinna znajdowaæ siê ¿adna etykieta.
</p>

Dodatkowo w obszarze bloku oznaczonego przez <b>.REPT</b> i <b>.ENDR</b> mamy mo¿liwo¶æ skorzystania ze znaku hash '#' (lub dyrektywy <b>.R</b>), który zwraca aktualn± warto¶æ licznika pêtli <b><tt>.REPT</tt></b> (podobnie jak dla <b>:repeat</b>).
<span style="color: #0000FF">
<pre>
Example:

 .rept 12, #*2, #*3        ; bloki .REPT mo¿emy ³±czyæ z :rept
 :+4 dta :1                ; :+4 aby odró¿niæ licznik powtórzeñ od parametru :4
 :+4 dta :2
 .endr

 .rept 9, #                ; definiujemy 9 etykiet label0..label8
label:1 mva #0 $d012+#
 .endr
</pre>
</span>
<br />


<A NAME="_pages">
<p>
<u><tt><h3>.PAGES [expression]</h3></tt></u>
Dyrektywa <tt><b>.PAGES</b></tt> pozwala okre¶liæ liczbê stron pamiêci w których powinien zmie¶ciæ siê nasz fragment kodu ograniczony przez <b>&lt.PAGES .. .ENDPG&gt</b> (domy¶lnie jest to warto¶æ 1). Je¶li kod programu przekroczy zadeklarowan± liczbê stron pamiêci wówczas zostanie wygenerowany komunikat b³êdu <tt><b>Page error at ????</b></tt>.

<p></p>
Dyrektywy te mog± nam pomóc gdy zale¿y nam aby fragment programu mie¶ci³ siê w granicach jednej strony pamiêci albo gdy piszemy program mieszcz±cy siê w dodatkowym banku pamiêci (64 strony pamiêci), np.:
<span style="color: #0000FF">
<pre>
Example:

 org $4000
 
 .pages $40
  ...
  ...
 .endpg
</pre>
</span>
<br />


<A NAME="_segment">
<u><tt><h3>.SEGDEF label address length [attrib] [bank]<br />
.SEGMENT label<br />
.ENDSEG
</h3></tt></u>
<p>
Dyrektywa .SEGDEF definiuje nowy segment LABEL o adresie pocz±tkowym ADDRESS i d³ugo¶ci LENGTH, dodatkowo mo¿liwe jest okre¶lenie atrybutu dla segmentu (R-read, W-rite, RW-ReadWrite - domy¶lnie) oraz przypisanie numeru wirtualnego banku BANK (domy¶lnie BANK=0).
</p>
<p>
Dyrektywa .SEGMENT aktywuje zapis kodu wynikowego segmentu LABEL. W przypadku przekroczenia zadanej d³ugo¶ci segmentu zostanie wygenerowany komunikat b³êdu <tt><b>Segment LABEL error at ADDRESS</b></tt>.
</p>
<p>
Dyrektywa .ENDSEG koñczy zapis do aktualnego segmentu, przywraca zapis do g³ównego bloku programu.
</p>

<span style="color: #0000FF">
<pre>
Example:

	.segdef sdata adr0 $100
	.segdef test  adr1 $40

	org $2000

	nop

	.cb 'ALA'

	.segment sdata

	nop
	
	.endseg

	lda #0

	.segment test
	ldx #0
	clc

	dta c'ATARI'

	.endseg

adr0	.ds $100
adr1	.ds $40 
</pre>
</span>
<br />


<A NAME="__end">
<p>
<u><tt><h3>.END</h3></tt></u>
Dyrektywa <tt><b>.END</b></tt> mo¿e byæ zamiennie u¿ywana z dyrektywami <tt><b>.ENDP</b></tt>, <tt><b>.ENDM</b></tt>, <tt><b>.ENDS</b></tt>, <tt><b>.ENDA</b></tt>, <tt><b>.ENDL</b></tt>, <tt><b>.ENDR</b></tt>, <tt><b>.ENDPG</b></tt>, <tt><b>.ENDW</b></tt>, <tt><b>.ENDT</b></tt>

<p></p>
<br />



<A NAME="__var">
<p>
<u><tt><h3>.VAR var1[=value1],var2[=value2]... (.BYTE|.WORD|.LONG|.DWORD) [=address]</h3></tt></u>
Dyrektywa <tt><b>.VAR</b></tt> s³u¿y do deklaracji i inicjacji zmiennych w g³ównym bloku programu oraz w blokach .PROC i .LOCAL. MADS nie wykorzystuje informacji na temat takich zmiennych w dalszych operacjach z udzia³em pseudo i makro rozkazów. Dopuszczalne typy zmiennych to .BYTE, .WORD, .LONG, .DWORD i ich wielokrotno¶ci, a tak¿e typy zadeklarowane przez .STRUCT i .ENUM np.:
<span style="color: #0000FF">
<pre>
Example:

 .var a,b , c,d   .word          ; 4 zmienne typu .WORD
 .var a,b,f  :256 .byte          ; 3 zmienne ka¿da o wielko¶ci 256 bajtów
 .var c=5,d=2,f=$123344 .dword   ; 3 zmienne .DWORD o warto¶ciach 5, 2, $123344

 .var .byte i=1, j=3             ; 2 zmienne typu .BYTE o warto¶ciach 1, 3

 .var a,b,c,d .byte = $a000      ; 4 zmienne typu .BYTE o adresach kolejno $A000, $A001, $A002, $A003
 
 .var .byte a,b,c,d = $a0        ; 4 zmienne typu bajt, ostatnia zmiennna 'D' o warto¶ci $A0
                                 ; !!! dla takiego zapisu nie ma mo¿liwo¶ci okre¶lenia adresu alokacji zmiennych

  .proc name
  .var .word p1,p2,p3            ; deklaracja trzech zmiennych typu .WORD
  .endp

 .local
  .var a,b,c .byte
  lda a
  ldx b
  ldy c
 .endl

 .struct Point                   ; nowy typ danych strukturalnych POINT
 x .byte
 y .byte
 .ends

  .var a,b Point                 ; deklaracja zmiennych strukturalnych
  .var Point c,d                 ; odpowiednik sk³adni 'label DTA POINT'
</pre>
</span>

Tak zadeklarowane zmienne zostan± fizycznie alokowane dopiero na koñcu bloku w którym zosta³y zadeklarowane, po dyrektywie .ENDP, .ENDL (.END). Wyj±tek stanowi blok .PROC gdzie zmienne zadeklarowane przez .VAR zawsze alokowane s± przed dyrektyw± .ENDP niezale¿nie czy w bloku procedury wyst±pi³y jakiekolwiek dodatkowe bloki .LOCAL ze zmiennymi deklarowanymi przez .VAR
<p></p>
<br />


<A NAME="__zpvar">
<p>
<u><tt><h3>.ZPVAR var1, var2... (.BYTE|.WORD|.LONG|.DWORD) [=address]</h3></tt></u>
Dyrektywa <tt><b>.ZPVAR</b></tt> s³u¿y do deklaracji zmiennych strony zerowej w g³ównym bloku programu oraz w blokach .PROC i .LOCAL. Próba przypisania warto¶ci (zaincjowania) takiej zmiennej spowoduje wygenerowanie komunikatu ostrze¿enia <b>Uninitialized variable</b>. MADS nie wykorzystuje informacji na temat takich zmiennych w dalszych operacjach z udzia³em pseudo i makro rozkazów. Dopuszczalne typy zmiennych to .BYTE, .WORD, .LONG, .DWORD i ich wielokrotno¶ci, a tak¿e typy zadeklarowane przez .STRUCT i .ENUM np.:
<span style="color: #0000FF">
<pre>
Example:

 .zpvar a b c d  .word = $80    ; 4 zmienne typu .WORD o adresie pocz±tkowym $0080
 .zpvar i j .byte               ; dwie kolejne zmienne od adresu $0080+8

 .zpvar .word a,b               ; 2 zmienne typu .WORD
                                ; !!! dla takiej sk³adni nie ma mo¿liwo¶ci okre¶lenia adresu zmiennych

 .struct Point                  ; nowy typ danych strukturalnych POINT
 x .byte
 y .byte
 .ends

  .zpvar a,b Point              ; deklaracja zmiennych strukturalnych
  .zpvar Point c,d              ; odpowiednik sk³adni 'label DTA POINT'                                
</pre>
</span>

Tak zadeklarowanym zmiennym strony zerowej zostan± przypisane adresy dopiero na koñcu bloku w którym zosta³y zadeklarowane, po dyrektywie .ENDP, .ENDL (.END). Wyj±tek stanowi blok .PROC gdzie zmiennym zadeklarowanym przez .ZPVAR adresy przypisywane s± przed dyrektyw± .ENDP niezale¿nie czy w bloku procedury wyst±pi³y jakiekolwiek dodatkowe bloki .LOCAL ze zmiennymi deklarowanymi przez .ZPVAR.

<p>
Przy pierwszym u¿yciu dyrektywy .ZPVAR nale¿y zaincjowaæ adres jaki bêdzie przypisywany kolejnym zmiennym (domy¶lnym adresem jest $0080).
</p>
<span style="color: #0000FF">
<pre>
Example:

 .zpvar = $40                       
</pre>
</span>


<p>
 Z ka¿d± kolejn± zmienn± adres ten jest automatycznie zwiêkszany przez MADS-a, w przypadku gdy adresy zmiennych powtórz± siê zostanie wygenerowany komunikat ostrze¿enia <b>Access violations at address $xxxx</b>. W przypadku przekroczenia zakresu strony zerowej zostaje wygenerowany komunikat b³êdu <b>Value out of range</b>.
</p>

<p></p>
<br />



<A NAME="_print">
<p>
<u><tt><h3>.PRINT [.ECHO]</h3></tt></u>
Powoduje wypisanie na ekranie podanej jako parametr warto¶ci wyra¿enia lub ci±gu znakowego ograniczonego apostrofami <b><tt>' '</tt></b> lub <b><tt>" "</tt></b>, np.:
</p>
<span style="color: #0000FF">
<pre>
Example:

 .print "End: ",*,'..',$8000-*
 .echo "End: ",*,'..',$8000-*
</pre>
</span>
<br />


<A NAME="_error">
<p></p>
<u><tt><h3>.ERROR</A> [ERT] 'string'["string"] | .ERROR [ERT] expression</h3></tt></u>
Dyrektywa <b><tt>.ERROR</tt></b> i pseudo rozkaz <b><tt>ERT</tt></b> maj± to samo znaczenie. Zatrzymuj± asemblacjê programu oraz wy¶wietlaj± komunikat podany jako parametr, ograniczony apostrofami <b><tt>' '</tt></b> lub <b><tt>" "</tt></b>. Je¶li parametrem jest wyra¿enie logiczne, wówczas asemblacja zostanie zatrzymana gdy warto¶æ wyra¿enia logicznego jest prawd± (komunikat <b><tt>User error</tt></b>), np.:

<span style="color: #0000FF">
<pre>
Example:

 ert "halt"            ; ERROR: halt
 .error "halt"

 ert *>$7fff           ; ERROR: User error
 .error *>$7fff
</pre>
</span>

<br />



<A NAME="_byte">
<u><tt><h3>.BYTE, .WORD, .LONG, .DWORD</h3></tt></u>
W/w dyrektywy s³u¿± do oznaczenia dopuszczalnych typów parametrów w deklaracji parametrów procedury <b><tt>(.BYTE, .WORD, .LONG, .DWORD)</tt></b>. Mo¿liwe jest tak¿e ich u¿ycie w celu definicji danych, w zastêpstwie pseudo rozkazu <b><tt>DTA</tt></b>.
<span style="color: #0000FF">
<pre>
Example:

.proc test (.word tmp,a,b .byte value)

 .byte "atari",5,22
 .word 12,$FFFF
 .long $34518F
 .dword $11223344
</pre>
</span>
<br />



<A NAME="_dbyte">
<p>
<u><tt><h3>.DBYTE</h3></tt></u>
Definicja danych typu <b><tt>WORD</tt></b> w odwrotnej kolejno¶ci tzn. najpierw starszy bajt, nastêpnie m³odszy bajt.
<span style="color: #0000FF">
<pre>
Example:

.DBYTE $1234,-1,1     ; 12 34 FF FF 00 01
</pre>
</span>
<br />


<A NAME="_ds">
<p>
<u><tt><h3>[label] .DS expression | label .DS [elements0][elements1][...] .type</h3></tt></u>
Ta dyrektywa zapo¿yczona zosta³a z <tt>MAC'65</tt>, pozwala zarezerwowaæ pamiêæ bez jej uprzedniej inicjalizacji. Jest to odpowiednik pseudo rozkazu <tt><b>ORG *+expression</b></tt>. Dyrektywy .DS nie mo¿na u¿ywaæ w kodzie relokowalnym podobnie jak ORG-a.
</p>
<p>
U¿ycie nawiasów kwadratowych w wyra¿eniu umo¿liwia rezerwowanie pamiêci jako tablicy, podobnie jak .ARRAY, wymagane jest wówczas podanie etykiety. U¿ycie dyrektywy .DS w bloku relokowalnym Sparta DOS X wymusi utworzenie bloku pustego 'blk empty'.
</p>

<span style="color: #0000FF">
<pre>
purpose: reserves space for data without initializing then space to any particular value(s).

usage: [label] .DS expression
       label .DS [elements0][elements1][...] .TYPE

Using ".DS expression" is exactly equivalent of using "ORG *+expression". That is, the label
(if it is given) is set equal to the current value of the location counter. Then then value
of the expression is added to then location counter.

Example: BUFFERLEN .DS 1     ;reserve a single byte
         BUFFER   .DS [256]  ;reserve 256 bytes as array [0..255]
</pre>
</span>
<br />


<A NAME="_by">
<p>
<u><tt><h3>.BY [+byte] bytes and/or ASCII</h3></tt></u>
<span style="color: #0000FF">
<p>
Store byte values in memory. ASCII strings can be specified by enclosing the string in either single or double quotes.
</p>
If the first character of the operand field is a '+', then the following byte will be used as a constant and added to all remaining bytes of the instruction.
<pre>
Example:
      .BY +$80 1 10 $10 'Hello' $9B

will generate:
        81 8A 90 C8 E5 EC EC EF 1B
</pre>

Values in .BY statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</span>
<p></p>
<br />


<A NAME="_wo">
<p>
<u><tt><h3>.WO words</h3></tt></u>
<span style="color: #0000FF">
Stores words in memory. Multiple words can be entered.

<br />
<br />

Values in .WO statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.

</span>
<p></p>
<br />


<A NAME="_he">
<p>
<u><tt><h3>.HE hex bytes</h3></tt></u>
<span style="color: #0000FF">
Store hex bytes in memory. This is a convenient method to enter strings of hex bytes, since it does not require the use of the '$' character. The bytes are still separated by spaces however, which I feel makes a much more readable layout than the 'all run together' form of hex statement that some other assemblers use.
<p>
Example:
      .HE 0 55 AA FF
</p>

Values in .HE statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.

</span>
<p></p>
<br />


<A NAME="_sb">
<p>
<u><tt><h3>.SB [+byte] bytes and/or ASCII</h3></tt></u>
<span style="color: #0000FF">
This is in the same format as the .BY pseudo-op, except that it will convert all bytes into ATASCII screen codes before storing them. The ATASCII conversion is done before any constant is added with the '+' modifier.

<br />
<br />

Values in .SB statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</span>

<p></p>
<p></p>
<br />


<A NAME="_cb">
<p>
<u><tt><h3>.CB [+byte] bytes and/or ASCII</h3></tt></u>
<span style="color: #0000FF">
This is in the same format as the .BY pseudo-op, except that the last character on the line will be EOR'ed with $80.

<br />
<br />

Values in .CB statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</span>

<p></p>
<br />


<A NAME="_fl">
<p>
<u><tt><h3>.FL floating point numbers</h3></tt></u>
<span style="color: #0000FF">
Stores 6-byte BCD floating point numbers for use with the OS FP ROM routines.

<br />
<br />

Values in .FL statements may also be separated with commas for compatibility with other assemblers. Spaces are allowed since they are easier to type.
</span>

<p></p>
<br />



<A NAME="_en">
<p>
<u><tt><h3>.EN</h3></tt></u>
Dyrektywa .EN jest odpowiednikiem pseudo rozkazu END, oznacza koniec asemblowanego bloku programu.
<p>
<span style="color: #0000FF">
This is an optional pseudo-op to mark the end of assembly. It can be placed before
the end of your source file to prevent a portion of it from being assembled.
</span>
</p>
<p></p>
<br />


<A NAME="_adr">
<p>
<u><tt><h3>.ADR label</h3></tt></u>
Dyrektywa .ADR zwraca warto¶æ etykiety LABEL przed zmian± adresu asemblacji (mo¿liwe jest umieszczenie nazwy etykiety LABEL pomiêdzy nawiasami okr±g³ymi lub kwadratowymi), np.:
<span style="color: #0000FF">
<pre>
 org $2000

.proc tb,$1000
tmp lda #0
.endp

 lda .adr tb.tmp  ; = $2000
 lda tb.tmp       ; = $1000
</pre>
</span>
<p></p>
<br />


<A NAME="_len">
<p>
<u><tt><h3>.LEN label ['filename'], .SIZEOF label, .FILESIZE 'filename'</h3></tt></u>
Dyrektywa .LEN zwraca d³ugo¶æ (wyra¿on± w bajtach) bloku .PROC, .ARRAY, .LOCAL, .STRUCT lub d³ugo¶æ pliku o nazwie 'filename'. Etykieta LABEL to nazwa bloku .PROC, .ARRAY, .LOCAL lub .STRUCT (mo¿liwe jest umieszczenie nazwy etykiety LABEL pomiêdzy nawiasami okr±g³ymi lub kwadratowymi), np.:
<span style="color: #0000FF">
<pre>
label .array [255] .dword
      .enda

      dta a(.len label)   ; = $400

.proc wait
 lda:cmp:req 20
 rts
.endp

 dta .sizeof wait    ; = 7
</pre>
</span>
<p>
Dyrektywy .SIZEOF i .FILESIZE to alternatywne nazwy dla .LEN, mo¿na u¿ywaæ ich zamiennie zale¿nie od upodobañ programuj±cego.
</p>
<br />


<A NAME="_fex">
<p>
<u><tt><h3>.FILEEXISTS 'filename'</h3></tt></u>
Dyrektywa .FILEEXISTS zwraca '1' gdy plik 'filename' istnieje w przeciwnym wypadku zwraca warto¶æ '0'  np.:
<span style="color: #0000FF">
<pre>
 ift .fileexists 'filename'
 .print 'true'
 els
 .print 'false'
 eif
</pre>
</span>
<br />


<A NAME="_defi">
<p></p>
<u><tt><h3>.DEFINE macro_name expression</h3></tt></u>
Dyrektywa .DEFINE pozwala zdefiniowaæ jedno-liniowe makro MACRO_NAME. Dopuszczalnych jest dziewiêæ parametrów %%1.%%9 (:1..:9) reprezentowanych w ten sam sposób jak dla makr .MACRO, poprzez znaki '%%' lub znak ':'. Nazwy literowe parametrów nie s± akceptowane, nie ma mo¿liwo¶ci u¿ycia znaku podzia³u linii '\'. 
<span style="color: #0000FF">
<pre>
 .define poke mva #%%2 %%1
 
 poke(712, 100)
</pre>
</span>
Makro jedno-liniowe .DEFINE mo¿na wielokrotnie definiowaæ w trakcie jednego przebiegu asemblacji.
<span style="color: #0000FF">
<pre>
 .define pisz %%1+%%2
 
 .print pisz(712, 100)
 
 .define pisz %%1-%%2
 
 .print pisz(712, 100)
</pre>
</span>
<br />


<A NAME="_undef">
<p></p>
<u><tt><h3>.UNDEF macro_name</h3></tt></u>
Dyrektywa .UNDEF usuwa definicjê jedno-liniowego makra MACRO_NAME.
<span style="color: #0000FF">
<pre>
 .define poke mva #%%2 %%1
 
 .undef poke
</pre>
</span>
<br />



<A NAME="_def">
<p></p>
<u><tt><h3>.DEF label [= expression]</h3></tt></u>
Dyrektywa .DEF pozwala sprawdziæ obecno¶æ definicji etykiety <b><tt>LABEL</tt></b> lub j± zdefiniowaæ. Je¶li etykieta zosta³a zdefiniowana zwraca warto¶æ <tt><b>1</b></tt> czyli <b><tt>TRUE</tt></b>, w przeciwnym wypadku zwraca <tt><b>0</b></tt> czyli <b><tt>FALSE</tt></b>. Mo¿liwe jest umieszczenie nazwy etykiety LABEL pomiêdzy nawiasami okr±g³ymi lub kwadratowymi, np.:

<span style="color: #0000FF">
<pre>
 ift .not(.def label)
 .def label
 eif
</pre>
</span>

<p>
Definiowane etykiety s± zasiêgu aktualnego obszaru lokalnego, je¶li chcemy zdefiniowaæ etykiety globalne stawiamy przed etykiet± znak ':', np.
</p>

<span style="color: #0000FF">
<pre>
.local test
 :10 .def :label%%1
.endl
</pre>
</span>

<span style="color: #0000FF">
This unary operator tests whether the following label has been defined yet, returning TRUE or FALSE as appropriate.

<p>
<b>CAUTION</b>: Defining a label AFTER the use of a .DEF which references it can be dangerous, particularly if the .DEF is used in a .IF directive.
</p>
</span>
<br />


<A NAME="_ifdef">
<p></p>
<u><tt><h3>.IFDEF label</h3></tt></u>
Dyrektywa .IFDEF jest krótszym odpowiednikiem warunku <b>.IF .DEF LABEL</b>
<span style="color: #0000FF">
<pre>
Example:

.ifdef label
       jsr proc1
.else
       jsr proc2
.endif
</pre>
</span>

<br />


<A NAME="_ifndef">
<p></p>
<u><tt><h3>.IFNDEF label</h3></tt></u>
Dyrektywa .IFNDEF jest krótszym odpowiednikiem warunku <b>.IF .NOT .DEF LABEL</b>
<span style="color: #0000FF">
<pre>
Example:

.ifndef label
      clc
.else
      sec
.endif
</pre>
</span>

Dla n/w przyk³adu asemblacja bloku .IFNDEF (.IF) bêdzie mia³a miejsce tylko w pierwszym przebiegu, je¶li umie¶cimy w takim bloku jakikolwiek kod programu na pewno nie zostanie on wygenerowany do pliku, definicje etykiet zostan± przeprowadzone tylko w pierwszym przebiegu, je¶li wyst±pi³y jakiekolwiek b³êdy zwi±zane z ich definiowaniem dowiemy siê o nich dopiero w momencie próby odwo³ania do takich etykiet, bêdzie to komunikat b³êdu <b>Undeclared label LABEL_NAME</b>

<span style="color: #0000FF">
<pre>
 .ifndef label
 .def label
 lda #0               ; ten rozkaz nie zostanie zasemblowany, tylko ostatni przebieg asemblacji generuje kod
 temp = 100           ; etykieta TEMP zostanie zdefiniowana tylko w 1 przebiegu asemblacji
 .endif
</pre>
</span>

<br />



<A NAME="_nowarn">
<p></p>
<u><tt><h3>.NOWARN</h3></tt></u>
Dyrektywa .NOWARN wy³±cza komunikat ostrze¿enia dla aktualnie asemblowanego wiersza programu.

<span style="color: #0000FF">
<pre>
Example:

.nowarn .proc temp       ; nie zostanie wygenerowane ostrze¿enie 'Unreferenced procedure TEMP'
        .endp
</pre>
</span>

<br />



<A NAME="_using">
<p>
<u><tt><h3>.USING, [.USE]</h3></tt></u>
Dyrektywa .USING (.USE) pozwala okre¶liæ dodatkow± ¶cie¿kê poszukiwañ dla nazw etykiet. Dzia³anie .USING (.USE) obowi±zuje w aktualnej przestrzeni nazw jak i kolejnych zawieraj±cych siê w tej przestrzeni.

<span style="color: #0000FF">
<pre>
Example:

.local move

tmp    lda #0
hlp    sta $a000

.local move2

tmp2   ldx #0
hlp2   stx $b000

.endl

.endl

.local main

.use move.move2

       lda tmp2
 
.use move

       lda tmp

.endl
</pre>
</span>
<br />



<A NAME="_get">
<p>
<u><tt><h3>.GET [index] 'filename'... [.BYTE, .WORD, .LONG, .DWORD]</h3></tt></u>
<u><tt><h3>.WGET [index] | .LGET [index] | .DGET [index]</h3></tt></u>

<b><tt>.GET</tt></b> jest odpowiednikiem pseudo rozkazu <b><tt>INS</tt></b> (podobna sk³adnia), z t± ró¿nic± ¿e plik nie jest do³±czany do asemblowanego pliku tylko ³adowany do pamiêci <tt>MADS-a</tt>. Ta dyrektywa pozwala wczytaæ okre¶lony plik do pamiêci <tt>MADS-a</tt> i odwo³ywaæ siê do bajtów tego pliku jak do tablicy jednowymiarowej.
</p>
<span style="color: #0000FF">
<pre>
Example:

 .get 'file'                    ; wczytanie pliku do tablicy MADS-a
 .get [5] 'file'                ; wczytanie pliku do tablicy MADS-a od indeksu = 5

 .get 'file',0,3                ; wczytanie do tablicy MADS-a 3-ech warto¶ci

 lda #.get[7]                   ; odczytanie 7 bajtu z tablicy MADS-a
 adres = .get[2]+.get[3]&lt&lt8     ; 2 i 3 bajt w nag³ówku pliku DOS zawiera informacje o adresie ³adowania
 
 adres = .wget[2]              ; word
 tmp = .lget[5]                ; long
 ?x = .dget[11]                ; dword
</pre>
</span>
Przy pomocy dyrektyw <tt>.GET, .PUT</tt> mo¿na odczytaæ np modu³ <tt>Theta Music Composer (TMC)</tt> i dokonaæ jego relokacji. Realizuje to za³±czone do <tt>MADS-a</tt> makro z katalogu <tt>../EXAMPLES/MSX/TMC_PLAYER/tmc_relocator.mac</tt>.
<p></p>
Dopuszczalny zakres warto¶ci dla <tt>INDEX = &lt0..65535&gt</tt>. Warto¶ci odczytywane przez <b><tt>.GET</tt></b> s± typu <tt>BYTE</tt>. Warto¶ci odczytywane przez <b><tt>.WGET</tt></b> s± typu <tt>WORD</tt>. Warto¶ci odczytywane przez <b><tt>.LGET</tt></b> s± typu <tt>LONG</tt>. Warto¶ci odczytywane przez <b><tt>.DGET</tt></b> s± typu <tt>DWORD</tt>.

<p></p>
<br />



<A NAME="_put">
<p>
<u><tt><h3>.PUT [index] = value</h3></tt></u>
Dyrektywa <tt>.PUT</tt> pozwala odwo³aæ siê do tablicy jednowymiarowej w pamiêci <tt>MADS-a</tt> i zapisaæ w niej warto¶æ typu <tt>BYTE</tt>. Jest to ta sama tablica do której dyrektywa <tt>.GET</tt> zapisuje plik.
<p>
Dopuszczalny zakres warto¶ci dla <tt>INDEX = &lt0..65535&gt</tt>.
</p>
<span style="color: #0000FF">
<pre>
Example:

 .put [5] = 12       ; zapisanie wartosci 12 w talicy MADS-a na pozycji 5-ej
</pre>
</span>
<br />


<A NAME="_sav">
<p>
<u><tt><h3>.SAV [index] ['filename',] length</h3></tt></u>
Dyrektywa <tt>.SAV</tt> pozwala zapisaæ bufor u¿ywany przez dyrektywy <tt>.GET</tt>, <tt>.PUT</tt> do pliku zewnêtrznego lub do³±czenie do aktualnie asemblowanego.
<span style="color: #0000FF">
<pre>
Example:

 .sav ?length            ; do³±czenie do asemblowanego pliku zawarto¶ci bufora [0..?length-1]
 .sav [200] 256          ; do³±czenie do asemblowanego pliku zawarto¶ci bufora [200..200+256-1]
 .sav [6] 'filename',32  ; zapisanie do pliku FILENAME zawarto¶ci bufora [6..6+32-1]
</pre>
</span>
Dopuszczalny zakres warto¶ci dla <tt>INDEX = &lt0..65535&gt</tt>.
<p></p>
<br />


<A NAME="_or">
<p>
<u><tt><h3>.OR, .AND, .XOR, .NOT</h3></tt></u>
W/w dyrektywy to odpowiedniki operatorów logicznych <tt>||</tt> <tt>(.OR)</tt>, <tt>&&</tt> <tt>(.AND)</tt>, <tt>^</tt> <tt>(.XOR)</tt>, <tt>!</tt> <tt>(.NOT)</tt>.
</p>
<br />


<A NAME="_lohi">
<p>
<u><tt><h3>.LO (expression), .HI (expression)</h3></tt></u>
W/w dyrektywy to odpowiedniki operatorów odpowiednio '&lt' (m³odszy bajt) i '&gt' (starszy bajt).
</p>
<br />


<A NAME="warun">
<u><tt><h3>.IF, .ELSE, .ELSEIF, .ENDIF</h3></tt></u>
<span style="color: #0000FF">
<pre>
 .IF     [IFT] expression
 .ELSE   [ELS]
 .ELSEIF [ELI] expression
 .ENDIF  [EIF]
</pre>
</span>
<p>
W/w dyrektywy i pseudo rozkazy wp³ywaj± na przebieg asemblacji (mo¿na ich u¿ywaæ zamiennie), np.:
</p>

<span style="color: #0000FF">
<pre>
Example:

 .IF .NOT .DEF label_name
   label_name = 1
 .ENDIF

 .IF [.NOT .DEF label_name] .AND [.NOT .DEF label_name2]
   label_name = 1
   label_name2 = 2
 .ENDIF
</pre>
</span>

<p>
W w/w przyk³adzie nawiasy (kwadratowe lub okr±g³e) s± konieczno¶ci±, ich brak spowodowa³by ¿e dla pierwszej dyrektywy <tt>.DEF</tt> parametrem by³aby nazwa etykiety <b><tt>label_name.AND.NOT.DEFlabel_name2</tt></b> (spacje s± pomijane, a znak kropki akceptowany w nazwie etykiety).
</p>
<br />



<A NAME="dyrekt6502">
<p class="duzy">
DYREKTYWY GENERUJ¡CE KOD 6502
</p>

<span style="color: #0000FF">
<pre>
 <A HREF="#_test6502">#IF</A> type expression [.OR type expression] [.AND type expression]
 <A HREF="#_test6502">#ELSE</A>
 #END

 <A HREF="#_while6502">#WHILE</A> type expression [.OR type expression] [.AND type expression]
 #END

 <A HREF="#_cycle6502">#CYCLE #N</A>
 </pre>
</span>


<A NAME="_test6502">
<p>
<u><tt><h3>#IF type expression [.OR type expression] [.AND type expression]</h3></tt></u>
Dyrektywa #IF to skromniejszy odpowiednik instrukcji IF z jêzyków wy¿szego poziomu (C, Pascal).
<p>
Dyrektywy #IF, #ELSE i #END pozwalaj± na wygenerowanie kodu maszynowego CPU 6502 instrukcji warunkowej IF dla wyznaczonego bloku programu, mo¿liwe jest ich zagnie¿d¿anie. Dopuszczalne s± wszystkie typy .BYTE, .WORD, .LONG, .DWORD, mo¿liwe jest ³±czenie wiêkszej ilo¶ci warunków przy pomocy dyrektyw .OR i .AND, nie ma mo¿liwo¶ci okre¶lenia kolejno¶ci warto¶ciowania poprzez nawiasy.
</p>
</p>

Wykonanie dyrektywy #IF zaczyna siê od obliczenia warto¶ci wyra¿enia prostego tzn. takiego które sk³ada siê z dwóch argumentów i jednego operatora (wyra¿enia mo¿emy ³±czyæ dyrektywami .OR lub .AND).

<p>
Je¿eli wyra¿enie ma warto¶æ ró¿n± od zera (TRUE), to zostanie wykonywany blok programu wystêpuj±cy po dyrektywie #IF. Blok takiego programu automatycznie koñczony jest instrukcj± 'JMP' realizuj±c± skok do nastêpnej instrukcji programu za dyrektyw± #END w przypadku wystêpowania bloku #ELSE.
</p>

Je¿eli wyra¿enie ma warto¶æ zero (FALSE), to wykonywany jest kod programu wystêpuj±cy po dyrektywie #ELSE, je¶li dyrektywa #ELSE nie wystêpuje sterowanie przekazywane jest do nastêpnej instrukcji programu za dyrektyw± #END, np.:
<span style="color: #0000FF">
<pre>
#if .byte label>#10 .or .byte label<#5
#end

#if .byte label>#100

#else

 #if .byte label<#200
 #end
 
#end

#if .byte label>#100 .and .byte label<#200 .or .word lab=temp
#end

#if .byte @
#end
</pre>
</span>
<br />



<A NAME="_while6502">
<p>
<u><tt><h3>#WHILE type expression [.OR type expression] [.AND type expression]</h3></tt></u>
Dyrektywa #WHILE jest odpowiednikiem instrukcji WHILE z jêzyków wy¿szego poziomu (C, Pascal).
<p>
Dyrektywy #WHILE i #END pozwalaj± na wygenerowanie kodu maszynowego CPU 6502 pêtli dla wyznaczonego bloku programu, mo¿liwe jest ich zagnie¿d¿anie. Dopuszczalne s± wszystkie typy .BYTE, .WORD, .LONG, .DWORD, mo¿liwe jest ³±czenie wiêkszej ilo¶ci warunków przy pomocy dyrektyw .OR i .AND, nie ma mo¿liwo¶ci okre¶lenia kolejno¶ci warto¶ciowania poprzez nawiasy.
</p>
<p>
Sekwencja dzia³añ przy wykonywaniu dyrektywy #WHILE jest nastêpuj±ca:
<ul>
<li>1. Oblicz warto¶æ wyra¿enia i sprawd¼, czy jest równe zeru (FALSE).<ul><li>je¿eli tak, to pomiñ krok 2;<li>je¿eli nie (TRUE), przejd¼ do kroku 2.</ul>
<li>2. Wykonaj blok programu ograniczonego dyrektywami #WHILE i #END, nastêpnie przejd¼ do kroku 1.
</ul>

<p>
Je¿eli pierwsze warto¶ciowanie wyra¿enia wyka¿e, ¿e ma ono warto¶æ zero, to blok programu nigdy nie zostanie wykonany i sterowanie przejdzie do nastêpnej instrukcji programu za dyrektyw± #END
</p>
<span style="color: #0000FF">
<pre>
#while .byte label>#10 .or .byte label<#5
#end

#while .byte label>#100
 #while .byte label2<#200
 #end
#end

#while .byte label>#100 .and .byte label<#200 .or .word lab=temp
#end
</pre>
</span>

Wersja krótka pêtli #WHILE, trwa dopóki LABEL<>0
<span style="color: #0000FF">
<pre>
#while .word label
#end
</pre>
</span>

<br />


<A NAME="_cycle6502">
<p>
<u><tt><h3>#CYCLE #N</h3></tt></u>
<p>
Dyrektywa #CYCLE pozwala wygenerowaæ kod 6502 o zadanej liczbie cykli. Wygenerowany kod nie modyfikuje ¿adnej komórki pamiêci, ani rejestru CPU, co najwy¿ej znaczniki.
</p>

<span style="color: #0000FF">
<pre>
#cycle #17  ; pha      3 cycle
            ; pla      4 cycle
            ; pha      3 cycle
            ; pla      4 cycle
            ; cmp $00  3 cycle
                      ---------
                      17 cycle
</pre>
</span>
<br />



<A NAME="zpage">
<u><tt><h2>Asemblacja na stronie zerowej</h2></tt></u>

<p>
W przeciwieñstwie do dwu-przebiegowych asemblerów takich jak <tt>QA</tt> i <tt>XASM</tt>, <tt>MADS</tt> jest wielo-przebiegowy. Co to daje ?
</p>

We¼my sobie taki przyk³ad:

<span style="color: #0000FF">
<pre>
 org $00
 
 lda tmp+1
 
tmp lda #$00
</pre>
</span>

Dwu-przebiegowy assembler nie znaj±c warto¶ci etykiety <tt>TMP</tt> przyjmie domy¶lnie, ¿e jej warto¶æ bêdzie dwu-bajtowa, czyli typu <tt>WORD</tt> i wygeneruje rozkaz <tt>LDA W</tt>.

<p>
Natomiast <tt>MADS</tt> uprzejmie wygeneruje rozkaz strony zerowej <tt>LDA Z</tt>. I to w³a¶ciwie g³ówna i najprostsza do wyt³umaczenia w³a¶ciwo¶æ wiêkszej liczby przebiegów.
</p>

Teraz kto¶ powie, ¿e woli gdy rozkaz odwo³uj±cy siê do strony zerowej ma postaæ <tt>LDA W</tt>. Nie ma sprawy, wystarczy ¿e rozszerzy mnemonik:

<span style="color: #0000FF">
<pre>
 org $00
 
 lda.w tmp+1
 
tmp lda #$00
</pre>
</span>

S± dopuszczalne trzy rozszerzenia mnemonika
<pre>
 <b>.b</b>[<b>.z</b>]
 <b>.w</b>[<b>.a</b>][<b>.q</b>]
 <b>.l</b>[<b>.t</b>]
</pre>
czyli odpowiednio <tt>BYTE</tt>, <tt>WORD</tt>, <tt>LONG</tt> <tt>(TRIPLE)</tt>. Z czego ostatni generuje 24bitow± warto¶æ i odnosi siê do <tt>65816</tt> i pamiêci o ci±g³ym obszarze (w±tpiê czy kiedykolwiek u¿yjecie taki rozkaz).
Wiêcej informacji na temat mnemoników <tt>CPU 6502, 65816</tt> oraz ich dopuszczalnych rozszerzeñ w rodziale <A HREF="#mnemo">Mnemoniki</A>.

<p>
Innym sposobem na wymuszenie rozkazu strony zerowej jest u¿ycie nawiasów klamrowych <tt>{ }</tt> np. 
</p>

<span style="color: #0000FF">
<pre>
 dta {lda $00},$80    ; lda $80
</pre>
</span>

W <tt>MADS</tt> mo¿emy robiæ tak samo, ale po co, ostatni przebieg za³atwi sprawê za nas :)
Problem stanowi teraz umieszczenie takiego fragmentu kodu w pamiêci komputera. Mo¿emy spróbowaæ za³adowaæ taki program bezpo¶rednio na stronê zerow± i je¶li obszar docelowy mie¶ci siê w granicy <tt>$80..$FF</tt> to pewnie <tt>OS</tt> prze¿yje, poni¿ej tego obszaru bêdzie trudniej.

<p>
Dlatego <tt>MADS</tt> umo¿liwia takie co¶:
</p>

<span style="color: #0000FF">
<pre>
 org $20,$3080
 
 lda tmp+1
 
tmp lda #$00
</pre>
</span>

Czyli asembluj od adresu <tt>$0020</tt>, ale za³aduj pod adres <tt>$3080</tt>. Oczywi¶cie pó¼niejsze przeniesienie kodu pod w³a¶ciwy adres (w naszym przyk³adzie <tt>$0020</tt>) nale¿y ju¿ do zadañ programisty.

<p>
Podsumowuj±c:
</p>

<span style="color: #0000FF">
<pre>
 org adres1,adres2
</pre>
</span>

<p>
Asembluj od adresu <tt><b>adres1</b></tt>, umie¶æ w pamiêci od adresu <tt><b>adres2</b></tt>.
Taki <tt><b>ORG</b></tt> zawsze spowoduje stworzenie nowego bloku w pliku, czyli zostan± zapisane dodatkowe cztery bajty nag³ówka nowego bloku.
</p>


Je¶li nie zale¿y nam na nowym adresie umiejscowienia danych w pamiêci, adresem umiejscowienia danych ma byæ aktualny adres wówczas mo¿emy skorzystaæ z w³a¶ciwo¶ci bloków .LOCAL i .PROC, bajty nag³ówka nie bêd± w takim przypadku zapisywane, np.:

<span style="color: #0000FF">
<pre>
     1
     2 					org $2000
     3
     4 FFFF> 2000-200D> A9 00		lda #0
     5 2002 EA				nop
     6
     7 0060			.local	temp, $60
     8
     9 0060 BD FF FF			lda $ffff,x
    10 0063 BE FF FF			ldx $ffff,y
    11
    12 				.endl
    13
    14 2009 A5 60			lda temp
    15 200B AD 03 20			lda .adr temp
    16
</pre>
</span>

Dla w/w przyk³adu blok programu <b>TEMP</b> zostanie zasemblowany z nowym adresem <b>= $60</b> i umiejscowiony w pamiêci pod adresem <b>$2003</b>. Po dyrektywie koñcz±cej blok (.ENDL, .ENDP, .END) przywracamy jest adres asemblacji sprzed bloku plus jeszcze d³ugo¶æ tak zasemblowanego bloku, w naszym przyk³adzie adresem od którego bêdzie kontynuowana asemblacja po zakoñczeniu bloku .LOCAL bêdzie adres <b>$2009</b>.

<p>
Nastêpnie wykorzystuj±c dyrektywy .ADR i .LEN mo¿na dokonaæ skopiowania takiego bloku pod w³a¶ciwy adres, np.:
</p>

<span style="color: #0000FF">
<pre>
      ldy #0
copy  mva .adr(temp),y temp,y+
      cpy #.len temp
      bne copy
</pre>
</span>

Wiêcej informacji na temat dzia³ania dyrektyw <a href="#_ADR">.ADR</a> i <a href="#_LEN">.LEN</a>.

<p></p>
<br />


<A NAME="types">
<p class="duzy">
TYPY
<p>
MADS udostêpnia mo¿liwo¶æ deklaracji dwóch typów danych: strukturalne .STRUCT i wyliczeniowe .ENUM

</p>


<A NAME="structs">
<p class="duzy">
TYP STRUKTURALNY, STRUKTURY
</p>


Je¶li programowali¶cie w <b><tt>C</tt></b>, to pewnie spotkali¶cie siê ju¿ ze strukturami.
Ogólnie w <tt>MADS</tt> struktura definiuje tablicê wirtualn±, jednowymiarow± o polach ró¿nego typu <b><tt>.BYTE</tt></b>, <b><tt>.WORD</tt></b>, <b><tt>.LONG</tt></b>, <b><tt>.DWORD</tt></b> i ich wielokrotno¶ci. Wirtualna poniewa¿ istnieje ona jak na razie tylko w pamiêci assemblera.

<p>
Pola takiej struktury zawieraj± informacjê o ofsecie do pocz±tku struktury.
</p>
<br />



<A NAME="struct">
<u><tt><h2>Deklaracja struktury (<b>.STRUCT</b>)</h2></tt></u>

<p>
Struktur dotycz± n/w dyrektywy:
</p>
<span style="color: #0000FF">
<pre>
name .STRUCT
     .STRUCT name
     .ENDS [.SEND] [.END]
</pre>
</span>

<u><tt><h3>name .STRUCT</h3></tt></u>

Deklaracja struktury <tt><b>name</b></tt> przy u¿yciu dyrektywy <tt><b>.STRUCT</b></tt>.
Nazwa struktury jest wymagana i konieczna, jej brak wygeneruje b³±d.
Do nazw struktur nie mo¿na u¿ywaæ nazw mnemoników i pseudo rozkazów.
Je¶li nazwa jest zarezerwowana wyst±pi b³±d z komunikatem <b><tt>Reserved word</tt></b>.

<p></p>
<u>Przyk³ad deklaracji struktury:</u>

<span style="color: #0000FF">
<pre>
.STRUCT name

  x .word      ; lda #name.x = 0
  y .word      ; lda #name.y = 2
  z .long      ; lda #name.z = 4
  v .dword     ; lda #name.v = 7

  q :3 .byte   ; lda #name.q = 11

.ENDS          ; lda #name   = 14 (length)
</pre>
</span>

Pola struktury definiujemy przez podanie nazwy i typu pola (.BYTE, .WORD, .LONG, .DWORD). Nazwa pola mo¿e byæ poprzedzona "bia³ymi spacjami". W obszarze ograniczonym dyrektywami .STRUCT i .ENDS nie ma mo¿liwo¶ci u¿ywania mnemoników CPU, je¶li je u¿yjemy lub u¿yjemy innych niedozwolonych znaków wyst±pi b³±d z komunikatem <b>Improper syntax</b> lub <b>Illegal instruction</b>.

<p>
Podsumowuj±c, etykieta <b><tt>name</tt></b> zawiera informacjê o ca³kowitej d³ugo¶ci struktury (w bajtach). Pozosta³e etykiety opisuj±ce pola zawieraj± informacjê o ofsecie do pocz±tku struktury.
</p>

Deklaracji struktur nie mo¿na zagnie¿d¿aæ, mo¿na zagnie¿d¿aæ wcze¶niej zadeklarowane struktury (kolejno¶æ wyst±pienia w programie nie ma znaczenia), np.:

<span style="color: #0000FF">
<pre>
.STRUCT temp

x .word
y .word
v .byte
z .word

.ENDS


.STRUCT test

tmp  temp

.ENDS

 lda #temp.v
 lda #test.tmp.x
 lda #test.tmp.z
</pre>
</span>

Do czego mo¿e przydaæ siê struktura ?

<p></p>
Przypu¶æmy, ¿e mamy jak±¶ tablicê z polami ró¿nego typu, mo¿emy odczytywaæ pola takiej tablicy przy pomocy
z góry okre¶lonych warto¶ci offsetów. Jednak gdy dodamy dodatkowe pole do tablicy, czy te¿ zmodyfikujemy j± w inny sposób, bêdziemy zmuszeni
poprawiaæ kod programu który pos³ugiwa³ siê z góry okre¶lonymi warto¶ciami offsetów. Gdy zdefiniujemy tak± tablicê przy
pomocy struktury bêdziemy mogli odczytywaæ jej pola pos³uguj±c siê offsetami zapisanymi w deklaracji struktury, czyli
zawsze odczytamy w³a¶ciwe pole niezale¿nie od zmian jakie zasz³y w tablicy.

<p>
Inny przyk³ad zastosowania struktur zosta³ opisany w rozdziale <a href="#labels_ext">Symbole zewnêtrzne</a>, <a href="#_prz_str">przyk³ad zastosowania symboli external i struktur .STRUCT</a>.
</p>

<p></p>
<br />




<A NAME="struct_wy">
<u><tt><h2>Definiowanie danych strukturalnych, odwo³ania</h2></tt></u>
<p>
Definiowanie danych strukturalnych polega na przypisaniu nowej etykiecie konkretnej struktury z u¿yciem pseudo rozkazu <b><tt>DTA</tt></b> lub bez tego pseudo rozkazu. Wynikiem takiego przypisania jest zarezerwowana pamiêæ, nie jest to ju¿ twór wirtualny.
</p>

<span style="color: #0000FF">
<pre>
label DTA struct_name [count] (data1,data2,data3...) (data1,data2,data3...) ...

label struct_name
</pre>
</span>

<p>
<tt><b>COUNT</b></tt> okre¶la liczbê z przedzia³u <tt>&lt0..COUNT&gt</tt>, która definiuje maksymaln± warto¶æ indeksu tablicy jednowymiarowej, a przez to tak¿e liczbê od³o¿onych w pamiêci danych typu strukturalnego.
</p>

Przyk³ad deklaracji struktury i definicji danych strukturalnych:

<span style="color: #0000FF">
<pre>
;----------------------;
; deklaracja struktury ;
;----------------------;
.STRUCT temp

x .word
y .word
v .byte
z .word

.ENDS

;---------------------;
; definiowanie danych ;
;---------------------;

data dta temp [12] (1,20,200,32000) (19,2,122,42700)

data2 dta temp [0]

data3 temp          // krótszy odpowiednik DATA2
</pre>
</span>

Po nazwie struktury w nawiasie kwadratowym musi znajdowaæ siê warto¶æ z przedzia³u <b><tt>&lt0..2147483647&gt</tt></b>, która definiuje maksymaln± warto¶æ indeksu tablicy jednowymiarowej, a jednocze¶nie liczbê od³o¿onych w pamiêci danych typu strukturalnego.

<p>
Po nawiasie kwadratowym mo¿e wyst±piæ opcjonalnie lista warto¶ci pocz±tkowych (ograniczona nawiasami okr±g³ymi), je¶li nie wyst±pi wówczas domy¶lnymi warto¶ciami pól struktury s± zera. Z kolei je¶li lista warto¶ci pocz±tkowych jest mniejsza od liczby pól zadeklarowanych, wówczas pozosta³e pola inicjowane s± ostatnimi warto¶ciami jakie zosta³y podane, np.
</p>

<span style="color: #0000FF">
<pre>
data dta temp [12] (1,20,200,32000)
</pre>
</span>

Taka deklaracja spowoduje, ¿e wszystkie pola zostan± zaincjowane warto¶ciami <tt>1,20,200,32000</tt>, a nie tylko pierwsze pole <tt>data[0]</tt>.


<p>
Je¶li lista warto¶ci pocz±tkowych bêdzie wiêksza lub mniejsza od liczby pól struktury, wówczas wyst±pi b³±d z komunikatem <b><tt>Constant expression violates subrange bounds</tt></b>.
</p>

Aby odwo³aæ siê do pól tak nowo powsta³ych danych nale¿y podaæ ich nazwê, koniecznie indeks w nawiasie kwadratowym i nazwê pola po kropce, np.:

<span style="color: #0000FF">
<pre>
 lda data[4].y
 ldx #data[0].v
</pre>
</span>

<p>
Brak nawiasu kwadratowego z indeksem <b>label[index]</b> zakoñczy siê komunikatem b³êdu <b><tt>Undeclared label</tt></b>.
</p>
<br />


<A NAME="enums">
<p class="duzy">
TYP WYLICZENIOWY, WYLICZENIA
</p>

<p>
Wyliczeñ dotycz± n/w dyrektywy:
</p>
<span style="color: #0000FF">
<pre>
name .ENUM
     .ENDE [.EEND] [.END]

Example:

.enum portb
 rom_off = $fe
 rom_on = $ff
.ende

.enum test
 a             ; a=0
 b             ; b=1
 c = 5         ; c=5
 d             ; d=6
.ende
</pre>
</span>
<p>
Deklaracja wyliczenia odbywa siê przy u¿yciu dyrektyw <b>.ENUM</b> i <b>.ENDE</b>. Nazwa wyliczenia jest wymagana i konieczna, jej brak wygeneruje b³±d. Do nazw wyliczeñ nie mo¿na u¿ywaæ nazw mnemoników i pseudo rozkazów. Je¶li nazwa jest zarezerwowana wyst±pi b³±d z komunikatem <b>Reserved word</b>. 
</p>

Warto¶ci kolejnych etykiet s± zwiêkszane automatycznie o 1 zaczynaj±c od domy¶lnej warto¶ci 0, warto¶ci etykiet mo¿na definiowaæ samodzielnie albo pozostawiæ to automatowi.

<p>
Do etykiet wyliczeniowych odwo³ujemy siê przy pomocy sk³adni:
</p>

<span style="color: #0000FF">
<pre>
 enum_name (field)
</pre>
</span>

lub bezpo¶rednio podobnie jak w przypadku odwo³añ do bloków .LOCAL, .PROC, czyli po nazwie typu oddzielone znakiem kropki wystêpuj± kolejne pola, np.:


<span style="color: #0000FF">
<pre>
 lda #portb(rom_off)

 dta portb.rom_on, portb.rom_off
</pre>
</span>

Wyliczeñ mo¿emy u¿yæ do deklaracji pól struktury .STRUCT, do alokacji zmiennych dyrektyw± .VAR, np.:

<span style="color: #0000FF">
<pre>
bank portb           // alokacja zmiennej BANK o rozmiarze 1 bajtu
.var bank portb      // alokacja zmiennej BANK o rozmiarze 1 bajtu

.struct test
 a portb
 b portb
.ends
</pre>
</span>

Rozmiar zmiennej typu wyliczeniowego zale¿ny jest od maksymalnej warto¶ci jakie przyjmuj± kolejne etykiety wyliczenia, np.:
<span style="color: #0000FF">
<pre>
    .enum EState
        DONE, DIRECTORY_SEARCH=$ff, INIT_LOADING, LOADING
    .ende
</pre>
</span>

Dla w/w przyk³adu alokacja zmiennej typu "EState" bêdzie mia³a rozmiar dwóch bajtów (WORD).

<p>
Rozmiar mo¿emy sprawdziæ przy pomocy dyrektywy .LEN (.SIZEOF), wynikiem bêd± warto¶ci 1..4 (1-BYTE, 2=WORD, 3-LONG, 4-DWORD) np.:
</p>

<span style="color: #0000FF">
<pre>
 .print .len EState
</pre>
</span>

<p></p>
<br />


<A NAME="arrays">
<p class="duzy">
TABLICE
</p>


<A NAME="array">
<u><tt><h2>Deklaracja tablicy wielowymiarowej (<b>.ARRAY</b>)</h2></tt></u>

Tablic dotycz± n/w dyrektywy:
</p>
<span style="color: #0000FF">
<pre>
label .ARRAY [elements0][elements1][...] [.type] [= init_value]
      .ARRAY label [elements0][elements1][...] [.type] [= init_value]
      .ENDA [.AEND] [.END]
</pre>
</span>

Dostêpne typy danych to <b><tt>.BYTE</tt></b>, <b><tt>.WORD</tt></b>, <b><tt>.LONG</tt></b>, <b><tt>.DWORD</tt></b>. W przypadku braku podania typu domy¶lnie przyjmowany jest typ .BYTE. Definicja tablicy lokalizuje j± in-place (w miejscu definicji). 

<p>
<tt>ELEMENTS</tt> okre¶la liczbê elementów tablicy, które bêd± indeksowane od &lt0..ELEMENTS-1&gt. Warto¶æ ELEMENTS mo¿e byæ sta³± lub wyra¿eniem, powinna byæ z przedzia³u <b><tt>&lt0..65535&gt</tt></b>. W przypadku braku podania liczby elementów zostanie ona ustalona na podstawie liczby wprowadzonych danych. 
</p>

W obszarze ograniczonym dyrektywami .ARRAY i .ENDA nie ma mo¿liwo¶ci u¿ywania mnemoników CPU, je¶li je u¿yjemy lub u¿yjemy innych niedozwolonych znaków wówczas wyst±pi b³±d z komunikatem <b>Improper syntax</b>.

<p></p>
Dopuszczalne jest okre¶lenie indeksu od jakiego bêdziemy wpisywali warto¶ci dla kolejnych pól tablicy. Now± warto¶æ takiego indeksu okre¶lamy umieszczaj±c na pocz±tku nowego wiersza w nawiasach kwadratowych wyra¿enie <b>[expression]</b>. Mo¿liwe jest okre¶lenie wiêkszej ilo¶ci indeksów, w tym celu rodzielamy kolejne indeksy znakiem dwukropka <b>':'</b>. Nastêpnie wprowadzamy warto¶ci dla pól tablicy po znaku równo¶ci <b>'='</b>, np.:
<span style="color: #0000FF">
<pre>
.array tab .word      ; tablica TAB o nieokre¶lonej z góry liczbie pól typu .WORD
 1,3                  ; [0]=1, [1]=3
 5                    ; [2]=5 
 [12] = 1             ; [12]=1
 [3]:[7]:[11] = 9,11  ; [3]=9, [4]=11, [7]=9, [8]=11, [11]=9, [12]=11
.enda

.array scr [24][40]   ; tablica dwuwymiarowa SCR typu .BYTE
  [11][15] = "ATARI"
.enda
</pre>
</span>

<p>
Przyk³ad tablicy t³umacz±cej kod naci¶niêtego klawisza na kod <tt>INTERNAL</tt>.
</p>

<span style="color: #0000FF">
<pre>
.array TAB [255] .byte = $ff   ; alokowanie 256 bajtów [0..255] o warto¶ci pocz±tkowej $FF

 [63]:[127] = "A"              ; przypisanie nowej warto¶ci TAB[63]="A", TAB[127]="A"
 [21]:[85]  = "B"
 [18]:[82]  = "C"
 [58]:[122] = "D"
 [42]:[106] = "E"
 [56]:[120] = "F"
 [61]:[125] = "G"
 [57]:[121] = "H"
 [13]:[77]  = "I"
 [1] :[65]  = "J"
 [5] :[69]  = "K"
 [0] :[64]  = "L"
 [37]:[101] = "M"
 [35]:[99]  = "N"
 [8] :[72]  = "O"
 [10]:[74]  = "P"
 [47]:[111] = "Q"
 [40]:[104] = "R"
 [62]:[126] = "S"
 [45]:[109] = "T"
 [11]:[75]  = "U"
 [16]:[80]  = "V"
 [46]:[110] = "W"
 [22]:[86]  = "X"
 [43]:[107] = "Y"
 [23]:[87]  = "Z"
 [33]:[97]  = " "

 [52]:[180] = $7e
 [12]:[76]  = $9b

.enda
</pre>
</span>

<p>
W w/w przyk³adzie stworzyli¶my tablicê <tt>TAB</tt> o rozmiarze 256 bajtów <tt>[0..255]</tt>, typie danych <tt>.BYTE</tt> i wype³nili¶my pola warto¶ci± = <tt>$FF</tt>, dodatkowo zapisali¶my warto¶ci kodów literowych <tt>INTERNAL</tt> na pozycjach (indeksach tablicy) równych kodowi naci¶niêcia klawisza (bez <tt>SHIFT-a</tt> i z <tt>SHIFT-em</tt>, czyli du¿e i ma³e litery).
</p>

Znak dwukropka <tt>':'</tt> rozdziela poszczególne indeksy tablicy.

<p>
Przyk³ad procedury detekcji ruchu joysticka, np.:
</p>

<span style="color: #0000FF">
<pre>
.local HERO

  .pages
  
  lda $d300
  and #$0f
  tay
  lda joy,y
  sta _jmp

  jmp null
_jmp equ *-2

left
right
up
down  

null

  rts

  .endpg

  _none     = 15
  _up       = 14
  _down     = 13
  _left     = 11
  _left_up  = 10
  _left_dw  = 9
  _right    = 7
  _right_up = 6
  _right_dw = 5

.array joy [16] .byte = .lo(null)

	[_left]     = .lo(left)
	[_left_up]  = .lo(left)
	[_left_dw]  = .lo(left)

	[_right     = .lo(right)
	[_right_up] = .lo(right)
	[_right_dw] = .lo(right)

	[_up]       = .lo(up)
	[_dw]       = .lo(down)
.enda

.endl
</pre>
</span>


<p></p>
Innym przyk³adem mo¿e byæ umieszczenie wycentrowanego napisu, np.:
<span style="color: #0000FF">
<pre>
 org $bc40

.array txt 39 .byte
 [17] = "ATARI"
.enda
</pre>
</span>


Do tak stworzonej tablicy odwo³ujemy siê nastêpuj±co:
<span style="color: #0000FF">
<pre>
 lda tab,y
 lda tab[23],x
 ldx tab[200]
</pre>
</span>

Je¶li w nawiasie kwadratowym podamy warto¶æ indeksu przekraczaj±c± zadeklarowan± dla danej tablicy, zostanie wygenerowany komunikat b³êdu <b><tt>Constant expression violates subrange bounds</tt></b>.
</p>

<br />




<A NAME="macros">
<p class="duzy">
MAKRA
<p>

Makra u³atwiaj± nam wykonywanie powtarzaj±cych siê czynno¶ci, automatyzuj± je. Istniej± tylko w pamiêci assemblera, dopiero w momencie wywo³ania s± asemblowane. Przy ich pomocy <tt>MADS</tt> mo¿e odk³adaæ i zdejmowaæ z programowego stosu parametry dla procedur zadeklarowanych dyrektyw± <tt>.PROC</tt> oraz prze³±czaæ banki rozszerzonej pamiêci w trybie <tt>BANK SENSITIVE (OPT B+)</tt>.

<p></p>


<A NAME="makra">
<u><tt><h2>Deklaracja makra</h2></tt></u>

<p>
Makr dotycz± n/w pseudo rozkazy i dyrektywy:
</p>
<span style="color: #0000FF">
<pre>
name .MACRO [arg1, arg2 ...] ['separator'] ["separator"]
     .MACRO name [(arg1, arg2 ...)] ['separator'] ["separator"]
     .EXITM [.EXIT]
     .ENDM [.MEND]
     :[%%]parameter
     :[%%]label
</pre>
</span>

<tt><h3>name .MACRO [(arg1, arg2 ...)] ['separator'] ["separator"]</h3></tt>
Deklaracja makra o nazwie <b><tt>name</tt></b> za pomoc± dyrektywy <b><tt>.MACRO</tt></b>. Nazwa makra jest wymagana i konieczna, jej brak wygeneruje b³±d. Do nazw makr nie mo¿na u¿ywaæ nazw mnemoników i pseudo rozkazów (b³±d <b><tt>Reserved word</tt></b>).

<p></p>
Dopuszczalna jest lista z etykietami nazw argumentów jakie bêd± przekazywane do makra, taka lista mo¿e byæ ograniczona dodatkowo nawiasem okr±g³ym (). Przedstawianie argumentów w postaci nazw etykiet ma na celu poprawienie przejrzysto¶ci kodu makra. W samym ciele makra mo¿na u¿ywaæ zamiennie nazw etykiet argumentów lub ich numerycznych odpowiedników.
<span style="color: #0000FF">
<pre>
.macro SetColor val,reg
 lda :val
 sta :reg
.endm
</pre>
</span>

<p></p>
Na koñcu deklaracji makra mo¿e wyst±piæ deklaracja separatora i zarazem trybu przekazywania parametrów do makra (pojedyñczy apostrof bez zmian, podwójny apostrof z rozbijaniem parametrów na tryb adresacji i argument).

<p>
<b>Domy¶lnym separatorem</b>, rozdzielaj±cym parametry przekazywane do makra jest znak przecinka <tt>','</tt> oraz spacji ' '.
</p>

<span style="color: #0000FF">
<pre>
<li>name .MACRO 'separator'
</pre>
</span>
Pomiêdzy pojedyñczymi apostrofami <tt>''</tt> mo¿emy umie¶ciæ znak separatora, który bêdzie u¿ywany do oddzielenia parametrów przy wywo³aniu makra (tylko do tego mog± s³u¿yæ pojedyñcze apostrofy).

<span style="color: #0000FF">
<pre>
<li>name .MACRO "separator"
</pre>
</span>
Pomiêdzy podwójnymi apostrofami <tt>""</tt> mo¿emy tak¿e umie¶ciæ znak separatora, który bêdzie u¿ywany do oddzielenia parametrów przy wywo³aniu makra. Dodatkowo u¿ycie podwójnego apostrofu sygnalizuje <tt>MADS-owi</tt> aby rozk³ada³ przekazywane parametry na dwa elementy: tryb adresacji i argument, np.:

<span style="color: #0000FF">
<pre>
 test #12 200 <30

test .macro " "
.endm
</pre>
</span>

Makro <tt>TEST</tt> ma zadeklarowany separator-spacjê przy u¿yciu apostrofu <b><tt>"</tt></b>, czyli po wywo³aniu makra parametry zostan± roz³o¿one na dwa elementy: tryb adresacji i argument.
<span style="color: #0000FF">
<pre>
 #12   -&gt  tryb adresacji '#' argument 12
 200   -&gt  tryb adresacji ' ' argument 200
 &lt30   -&gt  tryb adresacji '#' argument 0   (obliczona warto¶æ wyra¿enia "<30")

 test '#' 12 ' ' 200 '#' 0
</pre>
</span>

<b>UAWAGA #1:</b> Parametry ze znakiem operatora <tt>'&lt', '&gt'</tt> zostaj± obliczone i dopiero ich wynik jest przekazywany do makra (podstawiany pod parametr).

<p>
<b>UAWAGA #2:</b> Je¶li parametrem makra jest licznik pêtli <b>'#'</b>, <b>'.R'</b> (!!! pojedyñczy znak '#' lub dyrektywa '.R' a nie wyra¿enie z udzia³em tego znaku, tej dyrektywy !!!) wówczas do makra przekazywana jest warto¶æ licznika pêtli (podstawiana pod parametr).
</p>

T± w³a¶ciwo¶æ mo¿emy wykorzystaæ do stworzenia "samopisz±cego" siê kodu, kiedy potrzebujemy tworzyæ nowe etykiety typu "label0", "label1", "label2", "label3" ... itd. , np.:

<span style="color: #0000FF">
<pre>
 :32 find #

find .macro
      ift .def label:1
      dta a(label:1)
      eif
     .endm
</pre>
</span>

W/w przyk³ad zapisuje adres etykiety pod warunkiem ¿e taka etykiety istnieje (zosta³a zdefiniowana).
<p></p>
<br />


<p>
<u><tt><h3>.EXITM [.EXIT]</h3></tt></u>
Zakoñczenie dzia³ania makra. Powoduje bezwzglêdne zakoñczenie dzia³ania makra.
</p>

<p>
<u><tt><h3>.ENDM [.MEND]</h3></tt></u>
Przy pomocy dyrektywy .ENDM lub .MEND koñczymy deklaracjê aktualnego makra. Nie ma mo¿liwo¶ci u¿ycia dyrektywy .END jak ma to miejsce dla innych obszarów deklarowanych przez dyrektywy .LOCAL, .PROC, .ARRAY, .STRUCT, .REPT
</p>

<u><tt><h3>:[%%]parameter</h3></tt></u>
Parametr jest <b>liczb± decymaln± dodatni±</b> <tt>(>=0)</tt>, poprzedzon± znakiem dwukropka <tt>':'</tt> lub dwoma znakami procentu <tt>'%%'</tt>. Je¶li w makrze chcemy aby znak <tt>':'</tt> okre¶la³ liczbê powtórzeñ a nie numer parametru wystarczy ¿e nastêpny znak po dwukropku nie bêdzie z przedzia³u <tt>'0'..'9'</tt>, tylko np:
<span style="color: #0000FF">
<pre>
 :$2 nop
 :+2 nop
 :%10 nop
</pre>
</span>

Parametr <tt>:0 (%%0)</tt> ma specjalne znaczenie, zawiera liczbê przekazanych parametrów. Z jego pomoc± mo¿emy sprawdziæ czy wymagana liczba parametrów zosta³a przekazana do makra, np.:
<span style="color: #0000FF">
<pre>
  .IF :0<2 || :0>5
    .ERROR "Wrong number of arguments"
  .ENDIF

  IFT %%0<2 .or :0>5
    ERT "Wrong number of arguments"
  EIF 
</pre>
</span>


<p>
<u>Przyk³ad makra:</u>
</p>
<span style="color: #0000FF">
<pre>
.macro load_word

   lda <:1
   sta :2
   lda >:1
   sta :2+1   
 .endm

 test ne
 test eq

.macro test
  b%%1 skip
.endm
</pre>
</span>
<br />




<A NAME="makra_wy">
<u><tt><h2>Wywo³anie makra</h2></tt></u>

<p>
Makro wywo³ujemy poprzez jego nazwê, po niej mog± wyst±piæ parametry makra, rozdzielone separatorem którym jest domy¶lnie znak przecinka <tt>','</tt> lub spacji ' '.
Liczba parametrów uzale¿niona jest od wolnej pamiêci komputera PC. Je¶li przekazana liczba parametrów jest mniejsza od liczby 
parametrów u¿ywanych w danym makrze, wówczas pod brakuj±ce parametry zostanie podstawiona warto¶æ <b><tt>-1 ($FFFFFFFF)</tt></b>. T± w³a¶ciwo¶æ mo¿na wykorzystaæ do sprawdzenia czy zosta³ przekazany parametr czy te¿ nie, ³atwiej jednak tego dokonaæ za pomoc± parametru zerowego %%0.

<span style="color: #0000FF">
<pre>
 macro_name [Par1, Par2, Par3, 'Par4', "string1", "string2" ...]
</pre>
</span>

<p>
Parametrem mo¿e byæ warto¶æ, wyra¿enie lub ci±g znaków ograniczony apostrofem pojedyñczym <tt>''</tt> lub podwójnym <tt>""</tt>.
</p>

<li><u>apostrofy pojedyñcze</u> <tt>' '</tt> zostan± przekazane do makra razem ze znakami znajduj±cymi siê pomiêdzy nimi
<li><u>apostrofy podwójne</u> <tt>" "</tt> oznaczaj± ci±g znaków i tylko ci±g znaków znajduj±cy siê pomiêdzy apostrofami zostanie przekazany do makra

<p>
Wszelkie definicje etykiet w obrêbie makra maj± zasiêg lokalny.
</p>

Je¶li poszukiwana przez assembler etykieta nie wyst±pi³a w obszarze makra, wówczas nast±pi jej szukanie w obszarze lokalnym (je¶li wyst±pi³a dyrektywa <b><tt>.LOCAL</tt></b>), nastêpnie w procedurze (je¶li procedura jest aktualnie przetwarzana), na koñcu w g³ównym programie.

<p>
<u>Przyk³ad wywo³ania makra:</u>
</p>
<span style="color: #0000FF">
<pre>
 macro_name 'a',a,>$a000,cmp    ; dla domy¶lnego separatora ','
 macro_name 'a'_a_>$a000_cmp    ; dla zadeklarowanego separatora '_'
 macro_name 'a' a >$a000 cmp    ; dla domy¶lnego separatora ' '
</pre>
</span>

Mo¿liwe jest wywo³ywanie makr z poziomu makra, oraz rekurencyjne wywo³ywanie makr. W tym ostatnim przypadku nale¿y byæ ostro¿nym bo mo¿e doj¶æ do przepe³nienia stosu <tt>MADS-a</tt>. <tt>MADS</tt> zabezpiecza siê przez rekurencj± makr bez koñca i zatrzymuje asemblacje gdy liczba wywo³añ makra przekroczy <tt>4095</tt> (b³±d <tt><b>Infinite recursion</b></tt>).

<p>
<u>Przyk³ad makra, które spowoduje przepe³nienie stosu <tt>MADS-a</tt>:</u>
</p>
<span style="color: #0000FF">
<pre>
jump .macro

      jump

     .endm
</pre>
</span>


<u>Przyk³ad programu, który przekazuje parametry do pseudo procedur <tt>..\EXAMPLES\MACRO.ASM</tt>:</u>
<span style="color: #0000FF">
<pre>
 org $2000
 
 proc PutChar,'a'-64    ; wywo³anie makra PROC, jako parametr
 proc PutChar,'a'-64    ; nazwa procedury która bêdzie wywo³ana przez JSR
 proc PutChar,'r'-64    ; oraz jeden argument (kod znaku INTERNAL)
 proc PutChar,'e'-64
 proc PutChar,'a'-64

 proc Kolor,$23         ; wywo³anie innej procedurki zmieniaj±cej kolor t³a

;---

loop jmp loop           ; pêtla bez koñca, aby zobaczyæ efekt dzia³ania

;---

proc .macro             ; deklaracja makra PROC
 push =:1,:2,:3,:4      ; wywo³anie makra PUSH odk³adaj±cego na stos argumenty
                        ; =:1 wylicza bank pamieci
 
 jsr :1                 ; skok do procedury (nazwa procedury w pierwszym parametrze)
 
 lmb #0                 ; Load Memory Bank, ustawia bank na wartosc 0
 .endm                  ; koniec makra PROC 

;---

push .macro             ; deklaracja makra PUSH

  lmb #:1               ; ustawia wirtualny bank pamiêci

 .if :2<=$FFFF          ; je¶li przekazany argument jest mniejszy równy $FFFF to
  lda <:2               ; od³ó¿ go na stosie
  sta stack
  lda >:2
  sta stack+1
 .endif 

 .if :3<=$FFFF
  lda <:3
  sta stack+2
  lda >:3
  sta stack+3
 .endif 

 .if :4<=$FFFF
  lda <:4
  sta stack+4
  lda >:4
  sta stack+5
 .endif 
 
 .endm
 

* ------------ *            ; procedura KOLOR
*  PROC Kolor  *
* ------------ *
 lmb #1                     ; ustawienie numeru wirtualnego banku na 1
                            ; wszystkie definicje etykiet bêd± teraz nale¿eæ do tego banku
stack org *+256             ; stos dla procedury KOLOR
color equ stack

Kolor                       ; kod procedury KOLOR
 lda color
 sta 712
 rts

 
* -------------- *          ; procedura PUTCHAR
*  PROC PutChar  *
* -------------- *
 lmb #2                     ; ustawienie numeru wirtualnego banku na 2
                            ; wszystkie definicje etykiet bêd± teraz nale¿eæ do tego banku
stack org *+256             ; stos dla procedury PUTCHAR
char  equ stack

PutChar                     ; kod procedury PUTCHAR
 lda char
 sta $bc40
scr equ *-2

 inc scr
 rts
</pre>
</span>

Oczywi¶cie stos w tym przyk³adowym programie jest programowy. W przypadku <tt>65816</tt> mo¿na by³oby u¿yæ stosu sprzêtowego. Dziêki temu, ¿e zdefiniowane zmienne przypisywane s± do konkretnego numeru banku, mo¿na stworzyæ strukturê wywo³ania procedury czy funkcji podobn± do tych z jêzyków wy¿szego poziomu.

<p>
Pro¶ciej i efektywniej jednak skorzystaæ z deklaracji procedury <b><tt>.PROC</tt></b> jak± umo¿liwia <tt>MADS</tt>. Wiêcej o deklaracji procedury i operacjach jej dotycz±cych w rozdziale <A HREF="#procs">Procedury</A>. 
</p>
<br />



<A NAME="procs">
<p class="duzy">
PROCEDURY .PROC
</p>

<tt>MADS</tt> wprowadza nowe mo¿liwo¶ci w obs³udze procedur z parametrami. Nowe mo¿liwo¶ci upodabniaj± ten mechanizm do tych znanych z jêzyków wysokiego poziomu i s± tak samo ³atwe w u¿yciu dla programisty.

<p>
Aktualnie do³±czone do <tt>MADS-a</tt> deklaracje makr (<tt>@CALL.MAC, @PULL.MAC, @EXIT.MAC</tt>) umo¿liwiaj± obs³ugê stosu programowego o wielko¶ci 256 bajtów, czyli tej samej wielko¶ci jak stos sprzêtowy, udostêpniaj± mechanizm zdejmowania ze stosu programowego i odk³adania na stos programowy parametrów potrzebnych podczas wywo³ywania procedur, jak i wychodzenia z takich procedur. <tt>MADS</tt> uwzglêdnia mo¿liwo¶æ rekurencji takich procedur.
</p>

<p>
Programista nie jest zaanga¿owany w ten mechanizm, mo¿e skupiæ uwagê na swoim programie. Musi tylko pamiêtaæ o potrzebie zdefiniowania odpowiednich etykiet i do³±czeniu odpowiednich makr podczas asemblacji programu.
</p>

Dodatkowo istnieje mo¿liwo¶æ pominiêcia "mechanizmu" stosu programowego MADS-a i skorzystanie z klasycznego sposobu ich przekazywania, za pomoc± rejestrów CPU (dyrektywa .REG) lub przez zmienne (dyrektywa .VAR).

<p>
Inn± w³a¶ciwo¶ci± procedur .PROC jest mo¿liwo¶æ pominiêcia ich podczas asemblacji je¶li nie wyst±pi³o ¿adne odwo³anie do nich, czyli zosta³y zdefiniowane ale nie s± wykorzystane. Wyst±pi wówczas komunikat ostrze¿enia <b>Unreferenced procedure ????</b>. Pominiêcie takiej procedury podczas asemblacji mo¿liwe jest poprzez podanie parametru do MADS-a w linii poleceñ <b>-x</b> 'Exclude unreferenced procedures'.
</p>


<p></p>
Wszelkie etykiety zdefiniowane w obszarze procedury <tt>.PROC</tt> s± zasiêgu lokalnego, mo¿na je te¿ okre¶liæ jako etykiety globalne zdefiniowane lokalnie o dostêpie swobodnym, poniewa¿ mo¿na siê do nich odwo³ywaæ co nie jest normalne w innych jêzykach programowania.

<p></p>

W obszarze procedury <tt>.PROC</tt> istnieje mo¿liwo¶æ zdefiniowania etykiet o zasiêgu globalnym (patrz rozdzia³ <A HREF="#labels_glo">Etykiety globalne</A>). 

<p></p>

Je¶li chcemy dostaæ siê do etykiet zdefiniowanych w procedurze spoza obszaru procedury, wówczas adresujemy z u¿yciem znaku kropki '.', np.: 

<span style="color: #0000FF">
<pre>
 lda test.pole

.proc test

pole nop

.endp
</pre>
</span>

Je¶li poszukiwana przez assembler etykieta nie wyst±pi³a w obszarze procedury <tt>.PROC</tt>, wówczas <tt>MADS</tt> bêdzie poszukiwa³ j± w obszarze ni¿szym a¿ dojdzie do obszaru globalnego. Aby odczytaæ natychmiastowo warto¶æ etykiety globalnej z poziomu procedury <tt>.PROC</tt> (czy te¿ innego obszaru lokalnego) poprzedzamy nazwê etykiety znakiem dwukropka ':'. 

<p></p>


<tt>MADS</tt> wymaga dla procedur wykorzystuj±cych stos programowy, trzech globalnych definicji etykiet o konkretnych nazwach (adres stosu, wska¼nik stosu, adres parametrów procedury):
<span style="color: #0000FF">
<pre>
<li>@PROC_VARS_ADR
<li>@STACK_ADDRESS
<li>@STACK_POINTER
</pre>
</span>

<p>
Brak definicji w/w etykiet i próba u¿ycia bloku <tt><b>.PROC</b></tt> wykorzystuj±cego stos programowy spowoduje ¿e MADS przyjmie swoje domy¶lne warto¶ci tych etykiet: <b>@PROC_VARS_ADR = $0500</b>, <b>@STACK_ADDRESS = $0600</b>, <b>@STACK_POINTER = $FE</b>
</p>

<tt>MADS</tt> dla procedur wykorzystuj±cych stos programowy wymaga tak¿e deklaracji makr o konkretnych nazwach. Do³±czone do <tt>MADS-a</tt> deklaracje tych makr znajduj± siê w plikach:

<span style="color: #0000FF">
<pre>
<li>@CALL    ..\EXAMPLES\MACROS\@CALL.MAC
<li>@PUSH    ..\EXAMPLES\MACROS\@CALL.MAC
<li>@PULL    ..\EXAMPLES\MACROS\@PULL.MAC
<li>@EXIT    ..\EXAMPLES\MACROS\@EXIT.MAC
</pre>
</span>

W/w makra realizuj± przekazywanie i odk³adanie na programowy stos parametrów, oraz zdejmowanie i odk³adanie parametrów dla procedur wykorzystuj±cych stos programowy i wywo³ywanych z poziomu innych procedur wykorzystuj±cych stos programowy.

<p></p>


<A NAME="proc">
<u><tt><h2>Deklaracja procedury .PROC</h2></tt></u>

<p>
Procedur dotycz± n/w dyrektywy:
</p>
<span style="color: #0000FF">
<pre>
 name .PROC [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR]
 .PROC name [,address] [(.TYPE PAR1 .TYPE PAR2 ...)] [.REG] [.VAR]
 .ENDP [.PEND] [.END]
</pre>
</span>


<p></p>


<u><tt><h3>name .PROC [(.TYPE Par1,Par2 .TYPE Par3 ...)] [.REG] [.VAR]</h3></tt></u>

Deklaracja procedury <b>name</b> przy u¿yciu dyrektywy <tt><b>.PROC</b></tt>. Nazwa procedury jest wymagana i konieczna, jej brak wygeneruje b³±d. Do nazw procedur nie mo¿na u¿ywaæ nazw mnemoników i pseudo rozkazów. Je¶li nazwa jest zarezerwowana wyst±pi b³±d z komunikatem <b><tt>Reserved word</tt></b>.

<p></p>
Je¶li chcemy wykorzystaæ jeden z mechanizmów <tt>MADS-a</tt> do przekazywania parametrów do procedur, musimy je wcze¶niej zadeklarowaæ. Deklaracja parametrów procedury mie¶ci siê pomiêdzy nawiasami okr±g³ymi <tt>( )</tt>. Dostêpne s± cztery typy parametrów:

<pre>
<li><tt>.BYTE</tt>  (8-bit)  relokowalne
<li><tt>.WORD</tt>  (16-bit) relokowalne
<li><tt>.LONG</tt>  (24-bit) nierelokowalne
<li><tt>.DWORD</tt> (32-bit) nierelokowalne
</pre>

<tt><b>
W obecnej wersji <tt>MADS-a</tt> nie ma mo¿liwo¶ci przekazywania parametrów za pomoc± struktur <tt><b>.STRUCT</b>.
</b></tt>

<p></p>

Bezpo¶rednio po deklaracji typu, oddzielona minimum jedn± spacj±, nastêpuje nazwa parametru. Je¶li deklarujemy wiêcej parametrów tego samego typu mo¿emy rozdzieliæ ich nazwy znakiem przecinka <tt>','</tt>.
<p></p>

<u>Przyk³ad deklaracji procedury wykorzystuj±cej stos programowy:</u>
<span style="color: #0000FF">
<pre>
name .PROC ( .WORD par1 .BYTE par2 )
name .PROC ( .BYTE par1,par2 .LONG par3 )
name .PROC ( .DWORD p1,p2,p3,p4,p5,p6,p7,p8 )
</pre>
</span>

<p>
Dodatkowo u¿ywaj±c dyrektyw .REG lub .VAR mamy mo¿liwo¶æ okre¶lenia sposobu i metody przekazywania parametrów do procedur MADS-a. Przez rejestry CPU (.REG) lub przez zmienne (.VAR). Dyrektywy okre¶laj±ce sposób przekazywania parametrów umieszczamy na koñcu naszej deklaracji procedury .PROC
</p>

<u>Przyk³ad deklaracji procedury wykorzystuj±cej rejestry CPU:</u>
<span style="color: #0000FF">
<pre>
name .PROC ( .BYTE x,y,a ) .REG
name .PROC ( .WORD xa .BYTE y ) .REG
name .PROC ( .LONG axy ) .REG
</pre>
</span>

<p>
Dyrektywa .REG wymaga aby nazwy parametrów sk³ada³y siê z liter 'A', 'X', 'Y' lub ich kombinacji. Litery te odpowiadaj± nazwom rejestrów CPU i wp³ywaj± na kolejno¶æ u¿ycia rejestrów. Ograniczeniem w liczbie przekazywanych parametrów jest ilo¶æ rejestrów CPU, przez co mo¿emy przekazaæ do procedury w sumie maksimum 3 bajty. Zalet± takiego sposobu jes natomiast szybko¶æ i ma³e zu¿ycie pamiêci RAM.
</p>

<u>Przyk³ad deklaracji procedury wykorzystuj±cej zmienne:</u>
<span style="color: #0000FF">
<pre>
name .PROC ( .BYTE x1,x2,y1,y2 ) .VAR
name .PROC ( .WORD inputPointer, outputPointer ) .VAR
name .PROC ( .WORD src+1, dst+1 ) .VAR
</pre>
</span>

Dla .VAR nazwy parametrów wskazuj± nazwy zmiennych do których bêd± ³adowane przekazywane parametry. Metoda ta jest wolniejsza od .REG jednak nadal szybsza od metody ze stosem programowym.
</p>

<p>
Procedurê opuszczamy w standardowy sposób, czyli przy pomocy rozkazu RTS. Dodanie rozkazu <b><tt>RTS</tt></b> w ciele procedury przy wyj¶ciu z ka¿dej ¶cie¿ki jest obowi±zkiem programuj±cego, a nie assemblera.
</p>

Podobnie jak w przypadku bloku .LOCAL mamy mo¿liwo¶æ okre¶lenia nowego adresu asemblacji dla bloku .PROC, np.:
<span style="color: #0000FF">
<pre>
.PROC label,$8000
.ENDP

.PROC label2,$a000 (.word ax) .reg
.ENDP
</pre>
</span>


W przypadku procedur wykorzystuj±cych stos programowy po zakoñczeniu procedury przez .ENDP MADS wywo³uje makro <tt><b>@EXIT</b></tt>, którego zadaniem jest modyfikacja wska¼nika stosu programowego <b><tt>@STACK_POINTER</tt></b>, jest to konieczne dla prawid³owego dzia³ania stosu programowego. U¿ytkownik mo¿e sam zaprojektowaæ swoje makro <tt><b>@EXIT</b></tt>, albo skorzystaæ z do³±czonego do MADS-a (plik <tt>..\EXAMPLES\MACROS\@EXIT.MAC</tt>), ma ono obecnie nastêpuj±c± postaæ:

<span style="color: #0000FF">
<pre>
.macro @EXIT

 ift :1<>0

  ift :1=1
   dec @stack_pointer

  eli :1=2
   dec @stack_pointer
   dec @stack_pointer

  els
   pha
   lda @stack_pointer
   sub #:1
   sta @stack_pointer
   pla

  eif

 eif

.endm
</pre>
</span>

<p>
Makro <b><tt>@EXIT</tt></b> nie powinno zmieniaæ zawarto¶ci rejestrów <tt>CPU</tt> je¶li chcemy zachowaæ mo¿liwo¶æ zwrócenie wyniku dzia³ania procedury .PROC poprzez rejestry CPU.
<p></p>


<u><tt><h3>.ENDP</h3></tt></u>

Dyrektywa <tt><b>.ENDP</b></tt> koñczy deklaracjê bloku procedury.
<p></p>



<A NAME="proc_wy">
<u><tt><h2>Wywo³anie procedury</h2></tt></u>

<p>
Procedurê wywo³ujemy poprzez jej nazwê (identycznie jak makro), po niej mog± wyst±piæ parametry, rozdzielone separatorem w postaci znaku przecinka <tt>','</tt> lub spacji ' ' (nie ma mo¿liwo¶ci zadeklarowania innych separatorów).
</p>

Je¶li typ parametru nie bêdzie zgadza³ siê z typem zadeklarowanym w deklaracji procedury wyst±pi komunikat b³êdu <b><tt>Incompatible types</tt></b>.

<p>
Je¶li przekazana liczba parametrów ró¿ni siê od liczby zadeklarowanych parametrów w deklaracji procedury to wyst±pi komunikat b³êdu <b><tt>Improper number of actual parameters</tt></b>. Wyj±tkiem jest procedura do której parametry przekazywane s± przez rejestry CPU (.REG) lub zmienne (.VAR), w takich przypadkach mo¿emy pomin±æ parametry, w domy¶le s± one ju¿ za³adowane do odpowiednich rejestrów czy te¿ zmiennych.
</p>

<p>
<u>Mo¿liwe s± trzy sposoby przekazania parametru:</u>
</p>
<li>'#' przez warto¶æ
<li>' ' przez warto¶æ spod adresu (bez znaku poprzedzaj±cego)
<li>'@' przez akumulator (parametry typu .BYTE)
<li>"string" przez ci±g znakowy, np. "label,x"

<p>
<u>Przyk³ad wywo³ania procedury:</u>
</p>
<span style="color: #0000FF">
<pre>
 name @ , #$166 , $A400  ; dla stosu programowego
 name , @ , #$3f         ; dla .REG lub .VAR
 name "(hlp),y" "tab,y"	 ; dla .VAR lub dla stosu programowego (stos programowy korzysta z regX)
</pre>
</span>

<p>
<tt>MADS</tt> po napotkaniu wywo³ania procedury, która korzysta ze stosu programowego wymusza wykonanie makra  <tt>@CALL</tt>. Je¶li jednak procedura nie korzysta ze stosu programowego, zamiast makra <b><tt>@CALL</tt></b> zostanie wynegerowany zwyk³y rozkaz <b><tt>JSR PROCEDURE</tt></b>.
</p>

Do makra <b><tt>@CALL</tt></b> <tt>MADS</tt> przekazuje parametry wyliczone na podstawie deklaracji procedury (rozbija ka¿dy parametr na trzy sk³adowe: tryb adresacji, typ parametru, warto¶æ parametru).
<span style="color: #0000FF">
<pre>
@CALL_INIT 3\ @PUSH_INIT 3\ @CALL '@','B',0\ @CALL '#','W',358\ @CALL ' ',W,"$A400"\ @CALL_END PROC_NAME
</pre>
</span>

Makro <b><tt>@CALL</tt></b> od³o¿y na stos zawarto¶æ akumulatora, nastêpnie warto¶æ <tt>$166 (358 dec)</tt>, nastêpnie warto¶æ spod adresu <tt>$A400</tt>. Wiêcej informacji na temat sposobu przekazywania parametrów do makr (znaczenia apostrofów '' i "") w rozdziale <A HREF="#makra_wy">Wywo³anie makra</A>.

<p>
Parametr przekazywany przez akumulator <tt>'@'</tt> powinien byæ zawsze pierwszym parametrem przekazywanym do procedury, je¶li wyst±pi w innym miejscu zawarto¶æ akumulatora zostanie zmodyfikowana (domy¶lne makro <b><tt>@CALL</tt></b> nak³ada takie ograniczenie). Oczywi¶cie u¿ytkownik mo¿e to zmieniæ pisz±c swoj± wersjê makra <b><tt>@CALL</tt></b>.

<u><b>W przypadku procedur .REG lub .VAR kolejno¶æ wyst±pienia parametru '@' nie ma znaczenia.</b></u>
</p>


Wyj¶cie z procedury <b><tt>.PROC</tt></b> nastêpuje poprzez rozkaz RTS. Po powrocie z procedury MADS wywo³uje makro <b>@EXIT</b> które zawiera program modyfikuj±cy warto¶æ wska¼nika stosu <b><tt>@STACK_POINTER</tt></b>, jest to niezbêdne w celu prawid³owego dzia³ania stosu programowego. Od wska¼nika stosu odejmowana jest liczba bajtów które zosta³y przekazane do procedury, liczba bajtów przekazywana jest do makra jako parametr.

<p>
Dodanie rozkazu <b><tt>RTS</tt></b> w ciele procedury przy wyj¶ciu z ka¿dej ¶cie¿ki jest obowi±zkiem
programuj±cego, a nie assemblera.
</p>
<br />



<A NAME="para_od">
<u><tt><h2>Parametry procedury, odwo³ania</h2></tt></u>

Odwo³ania do parametrów procedury z poziomu procedury nie wymagaj± dodatkowych operacji ze strony programisty, np.:
<span style="color: #0000FF">
<pre>
@stack_address equ $400
@stack_pointer equ $ff
@proc_vars_adr equ $80

name .PROC (.WORD par1,par2)

 lda par1
 clc
 adc par2
 sta par1
 
 lda par1+1
 adc par2+1
 sta par1+1

.endp

 icl '@call.mac'
 icl '@pull.mac'
 icl '@exit.mac'
</pre>
</span>

MADS w momencie napotkania deklaracji .PROC z parametrami, dokonuje automatycznej definicji tych parametrów przypisuj±c im warto¶ci na podstawie @PROC_VARS_ADR. W w/w przyk³adzie MADS dokona automatycznej definicji parametrów PAR1 = @PROC_VARS_ADR, PAR2 = @PROC_VARS_ADR + 2.

<p>
Programista odwo³uje siê do tych parametrów po nazwie jaka zosta³a im nadana w deklaracji procedury, czyli podobnie jak ma to miejsce w jêzykach wy¿szego poziomu. W MADS istnieje mo¿liwo¶æ dostêpu do parametrów procedury spoza procedury co nie jest ju¿ normalne w jêzykach wy¿szego poziomu. Mo¿emy odczytaæ z w/w przyk³adu zawarto¶æ PAR1, np.:
</p>

<span style="color: #0000FF">
<pre>
 lda name.par1
 sta $a000
 lda name.par1+1
 sta $a000+1
</pre>
</span>
Warto¶æ PAR1 zosta³a przepisane pod adres $A000, warto¶æ PAR1+1 pod adres $A000+1. Oczywi¶cie mo¿emy tego dokonaæ tylko bezpo¶rednio po zakoñczeniu tej konkretnej procedury. Trzeba pamiêtaæ ¿e parametry takich procedur odk³adane s± pod wspólnym adresem @PROC_VARS_ADR, wiêc z ka¿dym nowym wywo³aniem procedury wykorzystuj±cej stos programowowy zawarto¶æ obszaru &lt@PROC_VARS_ADR .. @PROC_VARS_ADR + $FF&gt ulega zmianom.

<p>
Je¶li procedura ma zadeklarowane parametry typu .REG programista powinien zatroszczyæ siê o to aby je zapamiêtaæ czy te¿ w³a¶ciwie wykorzystaæ zanim zostan± zmodyfikowane przez kod procedury. W przypadku parametrów typu .VAR nie trzeba siê o nic martwiæ poniewa¿ parametry zosta³y zapisane do konkretnych komórek pamiêci sk±d zawsze mo¿emy je odczytaæ.
</p>


<p></p>
<br />



<A NAME="locals">
<p class="duzy">
OBSZAR LOKALNY
</p>


G³ównym zadaniem obszaru lokalnego w <tt>MADS</tt> jest stworzenie nowej przestrzeni nazw dla etykiet.
<p></p>

Wszelkie etykiety zdefiniowane w obszarze lokalnym <tt>.LOCAL</tt> s± zasiêgu lokalnego, mo¿na je te¿ okre¶liæ jako etykiety globalne zdefiniowane lokalnie o dostêpie swobodnym, poniewa¿ mo¿na siê do nich odwo³ywaæ co nie jest normalne w innych jêzykach programowania.

<p></p>

Obszary lokalne s± addytywne tzn. ¿e mo¿e byæ wiele bloków .LOCAL o tej samej nazwie, nie zostanie wygenerowany komunikat b³êdu <b>Label ... declared twice</b>.

<p></p>

W obszarze lokalnym <tt>.LOCAL</tt> istnieje mo¿liwo¶æ zdefiniowania etykiet o zasiêgu globalnym (patrz rozdzia³ <A HREF="#labels_glo">Etykiety globalne</A>). 

<p></p>

Je¶li poszukiwana przez assembler etykieta nie wyst±pi³a w obszarze lokalnym <tt>.LOCAL</tt>, wówczas <tt>MADS</tt> bêdzie poszukiwa³ j± w obszarze ni¿szym a¿ dojdzie do obszaru globalnego. Aby odczytaæ natychmiastowo warto¶æ etykiety globalnej z poziomu obszaru lokalnego <tt>.LOCAL</tt> (czy te¿ innego obszaru lokalnego) poprzedzamy nazwê etykiety znakiem dwukropka ':'.

<p></p>


<A NAME="obszar_lok">
<u><tt><h2>Deklaracja obszaru lokalnego .LOCAL</h2></tt></u>

<p>
Obszarów lokalnych dotycz± n/w dyrektywy:
</p>
<span style="color: #0000FF">
<pre>
 [name] .LOCAL [,address]
 .LOCAL [name] [,address]
 .ENDL [.LEND] [.END]
</pre>
</span>

<u><tt><h3>[name] .LOCAL [,address]</h3></tt></u>
<p>
Deklaracja obszaru lokalnego o nazwie <b>name</b> za pomoc± dyrektywy <tt><b>.LOCAL</b></tt>. Nazwa obszaru nie jest wymagana i nie jest konieczna. Do nazw obszarów lokalnych nie mo¿na u¿ywaæ nazw mnemoników i pseudo rozkazów. Je¶li nazwa jest zarezerwowana wyst±pi b³±d z komunikatem <b><tt>Reserved word</tt></b>.
</p>

<p>
Po nazwie obszaru lokalnego (lub po dyrektywie .LOCAL) mo¿emy podaæ nowy adres asemblacji bloku lokalnego. Po zakoñczeniu takiego bloku (.ENDL) przywracany jest poprzedni adres asemblacji zwiêkszony o d³ugo¶æ bloku lokalnego.
</p>

<span style="color: #0000FF">
<pre>
label .local,$4000
.endl

.local label2,$8000
.endl

.local
.endl

.local label3
.endl
</pre>
</span>


Wszelkie definicje etykiet w obszarze <b><tt>.LOCAL</tt></b> s± typu lokalnego. Aby odwo³aæ siê do etykiety globalnej o tej samej nazwie co etykieta lokalna nale¿y poprzedziæ j± znakiem dwukropka <tt>':'</tt>, np.:

<span style="color: #0000FF">
<pre>
lab equ 1

.local

lab equ 2

 lda #lab
 ldx #:lab

.endl
</pre>
</span>
W w/w przyk³adzie do rejestru A zostanie za³adowana warto¶æ 2, natomiast do rejestru X warto¶æ 1.


<p>
Je¶li poszukiwana przez assembler etykieta nie wyst±pi³a w obszarze <b><tt>.LOCAL</tt></b>, wówczas nast±pi jej szukanie w obszarze makra (je¶li jest aktualnie przetwarzane), potem w procedurze (je¶li procedura jest aktualnie przetwarzana), na koñcu w g³ównym programie.
</p>

W zadeklarowanym obszarze lokalnym wszystkie definicje etykiet rozró¿niane s± na podstawie nazwy obszaru
lokalnego. Aby dotrzeæ do zdefiniowanej etykiety w obszarze lokalnym spoza obszaru lokalnego musimy znaæ
nazwê obszaru i etykiety w nim wystêpuj±cej, np.:

<span style="color: #0000FF">
<pre>
 lda #name.lab1
 ldx #name.lab2

.local name

lab1 = 1
lab2 = 2

.endl
</pre>
</span>

<p>
W adresowaniu takiej struktury <b><tt>.LOCAL</tt></b> u¿ywamy znaku kropki <tt>'.'</tt>.
</p>

<p>
Obszary lokalne mo¿emy zagnie¿d¿aæ, mo¿emy je umieszczaæ w ciele procedur zadeklarowanych przez dyrektywê <tt><b>.PROC</b></tt>. Obszary lokalne s± addytywne, tzn. mo¿e istnieæ wiele obszarów lokalnych o tej samej nazwie, wszystkie symbole wystêpuj±ce w tych obszarach nale¿eæ bêd± do wspólnej przestrzeni nazw.
</p>

<p>
D³ugo¶æ wygenerowanego kodu w bloku LOCAL mo¿na sprawdziæ przy pomocy dyrektywy .LEN (.SIZEOF).
</p>


<u><tt><h3>.ENDL</h3></tt></u>
<p>
Dyrektywa <b>.ENDL</b> koñczy deklaracjê obszaru lokalnego.
</p>

<u>Przyk³ad deklaracji obszaru lokalnego:</u>
<span style="color: #0000FF">
<pre>
 org $2000
 
tmp ldx #0   <-------------   etykieta w obszarze globalnym
                          |
 lda obszar.pole  <---    |   odwolanie do obszaru lokalnego
                     |    |
.local obszar        |    |   deklaracja obszaru lokalnego
                     |    |
 lda tmp   <---      |    |
              |      |    |
 lda :tmp     |      | <---   odwolanie do obszaru globalnego
              |      |
tmp nop    <---      |        definicja w obszarze lokalnym
                     | 
pole lda #0       <---   <--- definicja w obszarze lokalnym
                            |
 lda pole  <----------------- odwolanie w obszarze lokalnym

.endl                        koniec deklaracji obszaru lokalnego
</pre>
</span>

<br />



<A NAME="syntax">
<p class="duzy">
SK£ADNIA
</p>

<tt>MADS</tt> akceptuje podobn± sk³adniê jak <tt>QA, XASM</tt>. Jest jednak mniej tolerancyjny w kwestii komentarzy umieszczanych na koñcu linii (komentarze powinny byæ poprzedzone odpowiednim znakiem) lub bardziej tolerancyjny w przypadku bia³ych spacji i w przypadkach braku argumentu dla mnemonika rozkazu <tt>CPU</tt>, np.:

<span style="color: #0000FF">
<pre>
   asl            ->  asl @
   lda #          ->  lda #0
</pre>
</span>

<p></p>

<tt>MADS</tt> akceptuje brak bia³ych spacji rozdzielaj±cych mnemonik i argument, pod warunkiem ¿e znaki argumentu nie zaczynaj± siê znakiem <tt>'@'</tt> u¿ywanym w nazwach etykiet lub znakami <tt>'%', ':'</tt> u¿ywanymi do oznaczenia numeru parametru w makrach (<tt>%%numer, :numer</tt>), np.:

<span style="color: #0000FF">
<pre>
   lda$44
   lda#
   lda(80),y
</pre>
</span>


<p></p>


<A NAME="kom">
<u><tt><h2>Komentarze</h2></tt></u>

Znaki komentarza jednoliniowego powinni¶my poprzedzaæ znakiem <tt>';'</tt> lub <tt>'*'</tt>.
Do oznaczania komentarza jednoliniowego najbezpieczniej jest jednak u¿ywaæ ¶rednika <tt>';'</tt> poniewa¿ znak <tt>'*'</tt> ma te¿ inne znaczenia, mo¿e oznaczaæ operacjê mno¿enia, czy te¿ aktualny adres podczas asemblacji. ¦rednik natomiast dedykowany jest tylko i wy³±cznie do oznaczania komentarzy.

<p></p>

Do oznaczenia komentarza jednoliniowego mo¿liwe jest te¿ u¿ycie znaków <tt>'//'</tt>, a dla wieloliniowego znaków <tt>'/* */'</tt>.

<span style="color: #0000FF">
<pre>
 * to jest komentarz
                 ; to jest komentarz
 lda #0      ; to jest komentarz
 dta  1 , 3     * B£ÊDNY KOMENTARZ, ZOSTANIE ¬LE ZINTERPRETOWANY

 org $2000 + 1      B£ÊDNY KOMENTARZ, ZOSTANIE ¬LE ZINTERPRETOWANY

 nop // to jest komentarz

 // to jest komentarz

 dta 1,2, /* komentarz */ 3,4

 lda /* komentarz */ #0

/*
  ...
  to jest komentarz wieloliniowy
  ...
*/

/*************************************
  to tez jest komentarz wieloliniowy
**************************************/
</pre>
</span>

<p>
Znaki oznaczaj±ce komentarz wieloliniowy <tt>'/* */'</tt> i znaki oznaczaj±ce komentarz jednoliniowy <tt>'//'</tt> mo¿na stosowaæ bez ograniczeñ.
</p>
<br />



<A NAME="znak_p">
<u><tt><h2>£±czenie/Dzielenie wielu wierszy listingu w jeden wiersz</h2></tt></u>

<p>
Dowoln± ilo¶æ wierszy listingu mo¿emy po³±czyæ (rozdzieliæ) w jeden wiersz u¿ywaj±c znaku <tt>'\'</tt>, np.:
</p>

<span style="color: #0000FF">
<pre>
 lda 20\ cmp 20\ beq *-2
 
    lda 20   \ cmp  20   \   beq *-2
 
  lda #0  \lop  sta $a000,y  \ iny  \ bne lop     ; komentarz tylko na koñcu takiego wiersza
</pre>
</span>

<p>
Je¶li po znaku <tt>'\'</tt> nie umie¶cimy znaku spacji, wówczas mnemonik czy inny ci±g znakowy mo¿e zostaæ zinterpretowany jako etykieta, nale¿y pamiêtaæ ¿e znak <tt>'\'</tt> oznacza pocz±tek nowej linii.
</p>

<p>
<tt>MADS</tt> koñczy przetwarzaæ taki wiersz, a¿ do napotkania komentarza lub napotkania koñca ci±gu znakowego, dlatego komentarze mo¿emy umieszczaæ tylko na koñcu takiego wielo-wiersza.
</p>

<b>UWAGA!!!</b> <u>Umieszczenie znaku '\' na koñcu wiersza oznacza dla MADS-a chêæ kontynuowania aktualnego wiersza od nastêpnego wiersza, np.:</u>

<span style="color: #0000FF">
<pre>
 lda\
 #\
 12
</pre>
</span>

Dla w/w przyk³adu otrzymamy rozkaz 'LDA #12'.
<p></p>
<br />


<A NAME="znak_d">
<u><tt><h2>£±czenie wielu mnemoników</h2></tt></u>
<p>
Mo¿liwo¶æ ³±czenia dwóch mnemoników za pomoc± znaku dwukropka <tt>':'</tt> znana jest ju¿ z <tt>XASM-a</tt>. W <tt>MADS</tt> ta mo¿liwo¶æ zosta³a rozszerzona o ³±czenie dowolnej liczby znanych <tt>MADS-owi</tt> mnemoników, np.:

<span style="color: #0000FF">
<pre>
 lda:cmp:req 20

 lda:iny:sta:iny $600,y
</pre>
</span>

<p></p>
<br />



<A NAME="expres">
<p class="duzy">
WYRA¯ENIA
</p>

Termin <b>wyra¿enie</b> oznacza sekwencjê operatorów i operandów (argumentów), która okre¶la <b>operacje</b>, tj. rodzaj i kolejno¶æ obliczeñ. <b>Wyra¿eniem z³o¿onym</b> nazywa siê takie wyra¿enie, w którym wystêpuje dwa lub wiêcej operatorów. Operatory, które oddzia³ywuj± tylko na jeden operand, nazywa siê <b>jednoargumentowymi</b> (unarnymi). Operatory dwuargumentowe nazywa siê <b>binarnymi</b>.

<p></p>
Warto¶ciowanie wyra¿enia przebiega w porz±dku, okre¶lonym pierwszeñstwem operatorów i w kierunku, okre¶lonym przez kierunek wi±zania operatorów.

<p></p>


<A NAME="numbers">
<u><tt><h2>Liczby</h2></tt></u>

<p>
<tt>MADS</tt> akceptuje zapis liczb w formacie decymalnym, hexadecymalnym, binarnym oraz w kodach ATASCII i INTERNAL.
</p>

<li>zapis decymalny:
<pre>
 -100
 -2437325
 1743
</pre>

<li>zapis hexadecymalny:
<pre>
 $100
 $e430
 $000001
 
 0x12
 0xa000
 0xaabbccdd
</pre>

<li>zapis binarny:
<pre>
 %0001001010
 %000000001
 %001000
</pre>

<li>zapis kodami ATASCII:
<pre>
 'a'
 'fds'
 'W'*
</pre>


<li>zapis kodami INTERNAL:
<pre>
 "B"
 "FDSFSD"
 "."*
</pre>

Tylko pierwszy znak ci±gu ATASCII, INTERNAL jest znacz±cy. Znak <tt>'*'</tt> za apostrofem zamykaj±cym powoduje invers znaku.
<p></p>
Dodatkowo mo¿liwe s± jeszcze dwie operacje '+' i '-' dla ci±gów znakowych, które powoduj± zwiêkszenie/zmniejszenie kodów znaków ograniczonych apostrofami.

<pre>
 "FDttrteSFSD"-12
 'FDSFdsldksla'+2
</pre>


<p></p>
<br />




<A NAME="opers">
<u><tt><h2>Operatory</h2></tt></u>

<pre>
<u>Binary operators:</u>

+   Addition
-   Subtraction
*   Multiplication
/   Division
%   Remainder
&   Bitwise and
|   Bitwise or
^   Bitwise xor
&lt&lt  Arithmetic shift left
&gt&gt  Arithmetic shift right
=   Equal
==  Equal (same as =)
&lt&gt  Not equal
!=  Not equal (same as <>)
&lt   Less than
&gt   Greater than
&lt=  Less or equal
&gt=  Greater or equal
&&  Logical and
||  Logical or


<u>Unary operators:</u>

+  Plus (does nothing)
-  Minus (changes sign)
~  Bitwise not (complements all bits)
!  Logical not (changes true to false and vice versa)
&lt  Low (extracts low byte)
&gt  High (extracts high byte)
^  High 24bit (extracts high byte)
=  Extracts memory bank
:  Extracts global variable value


<u>Operator precedence:</u>

first []              (brackets)
 + - ~ &lt &gt            (unary)
 * / % & &lt&lt &gt&gt        (binary)
 + - | ^              (binary)
 = == &lt&gt != &lt &gt &lt= &gt= (binary)
 !                    (unary)
 &&                   (binary)
last  ||              (binary)
</pre>
<br />



<A NAME="labels">
<p class="duzy">
ETYKIETY
</p>


<p>
Etykiety zdefiniowane w programie mog± posiadaæ zasiêg lokalny lub globalny, w zale¿no¶ci od miejsca w jakim zosta³y zdefiniowane. Oprócz tego mo¿na zdefiniowaæ etykiety tymczasowe, które tak¿e mog± posiadaæ zasiêg lokalny lub globalny.
</p>

<p>
<li><tt><b>Zasiêg globalny etykiety</b></tt> oznacza, ¿e jest ona widoczna z ka¿dego miejsca w programie, niezale¿nie czy jest to makro <tt><b>.MACRO</b></tt>, procedura <tt><b>.PROC</b></tt> czy obszar lokalny <tt><b>.LOCAL</b></tt>.
</p>

<p>
<li><tt><b>Zasiêg lokalny etykiety</b></tt> oznacza, ¿e jest ona widoczna tylko w konkretnie zdefiniowanym obszarze, np. przez dyrektywy: <tt><b>.MACRO</b></tt>, <tt><b>.PROC</b></tt>, <tt><b>.LOCAL</b></tt>.
</p>

<li>etykiety musz± zaczynaæ siê znakiem <tt>['A'..'Z','a'..'z','_','?','@']</tt>
<li>pozosta³e dopuszczalne znaki etykiety to <tt>['A'..'Z','a'..'z','0'..'9','_','?','@']</tt>
<li>etykiety wystêpuj± zawsze na pocz±tku wiersza
<li>etykiety poprzedzone "bia³ymi znakami" powinny koñczyæ siê znakiem <tt>':'</tt> aby unikn±æ b³êdnej interpretacji takiej etykiety jako makra
<li>w adresowaniu etykieta mo¿e byæ poprzedzona znakiem ':' informuje to asembler ¿e odwo³ujemy siê do etykiety w bloku g³ównym programu (odwo³ujemy siê do etykiety globalnej)

<p>
<u>Przyk³ad definicji etykiet:</u>
</p>
<span style="color: #0000FF">
<pre>
?nazwa   EQU  $A000      ; definicja etykiety tymczasowej globalnej
nazwa     =   *          ; definicja etykiety globalnej
nazwa2=12                ; definicja etykiety globalnej
@?nazwa  EQU  'a'+32     ; definicja etykiety globalnej
  name: equ 12           ; definicja etykiety globalnej nie zaczynaj±cej siê od pierwszego znaku wiersza
         nazwa: = 'v'    ; definicja etykiety globalnej nie zaczynaj±cej siê od pierwszego znaku wiersza
</pre>
</span>


<p>
W porównaniu do QA/XASM dosz³a mo¿liwo¶æ u¿ycia znaku zapytania <tt>'?'</tt> i "ma³pki" <tt>'@'</tt> w nazwach etykiet.
</p>

U¿ycie znaku kropki <tt>'.'</tt> w nazwie etykiety jest dopuszczalne, jednak nie zalecane. Znak kropki zarezerwowany jest do oznaczania rozszerzenia mnemonika, do oznaczenia dyrektyw assemblera, w adresowaniu nowych struktur <tt>MADS-a</tt>.

<p>
Znak kropki <tt>'.'</tt> na pocz±tku nazwy etykiety sugeruje ¿e jest to dyrektywa assemblera, natomiast znak zapytania <tt>'?'</tt> na pocz±tku etykiety oznacza etykietê tymczasow±, tak± której warto¶æ mo¿e siê zmieniaæ wielokrotnie w trakcie asemblacji.
</p>
<br />


<A NAME="labels_anm">
<u><tt><h2>Etykiety anonimowe</h2></tt></u>
<p>
W celu zapewnienia przejrzysto¶ci kodu u¿ycie etykiet anonimowych ograniczone jest tylko dla skoków warunkowych oraz do 10-u wyst±pieñ w przód/ty³.
</p>
<p>
Dla etykiet anonimowych zosta³ zarezerwowany znak '@', po takim znaku musi wyst±piæ znak okre¶laj±cy skok w przód '+' lub w ty³ '-'. Dodatkowo mo¿na okre¶liæ numer wyst±pienia etykiety anonimowej z zakresu [0..9], brak numeru wyst±pienia oznacza domy¶lnie 0 (zero).
<span style="color: #0000FF">
<pre>
 @+[0..9]     ; forward
 @-[0..9]     ; backward
 
 @+           ; @+0
 @-           ; @-0

@ dex   ---- -------
  bne @+   |  --   |
  stx $80  |   |   |
@ lda #0   |  --   |
  bne @- ---       |
  bne @-1  ---------
  
  ldx #6
@ lda:cmp:req 20
@ dex
  bne @-1
</pre>
</span>
<br />



<A NAME="labels_lok">
<u><tt><h2>Etykiety lokalne</h2></tt></u>

<p>
Ka¿da definicja etykiety w obrêbie makra <b><tt>.MACRO</tt></b>, procedury <b><tt>.PROC</tt></b> czy obszaru lokalnego <b><tt>.LOCAL</tt></b> domy¶lnie jest zasiêgu lokalnego, innymi s³owy jest lokalna. Takich etykiet u¿ytkownik nie musi dodatkowo oznaczaæ.
</p>

Etykiety lokalne definiujemy u¿ywaj±c n/w równowa¿nych pseudo rozkazów:
<span style="color: #0000FF">
<pre>
 EQU
  =
</pre>
</span>


Aby mieæ dostêp do etykiet o zasiêgu globalnym (czyli zdefiniowanych poza makrem <b><tt>.MACRO</tt></b>, procedur± <b><tt>.PROC</tt></b>, obszarem lokalnym <b><tt>.LOCAL</tt></b>) i o takich samych nazwach jak lokalne,
nale¿y u¿yæ operatora <tt>':'</tt>, np.:
<span style="color: #0000FF">
<pre>
lp   ldx #0         ; definicja globalna etykiety LP

     test
     test
 
test .macro

      lda :lp       ; znak ':' przed etykiet± odczyta warto¶æ etykiety globalnej LP

      sta lp+1      ; odwo³anie do etykiety lokalnej LP w obszarze makra
lp    lda #0        ; definicja etykiety lokalnej LP w obszarze makra

     .endm
</pre>
</span>

W w/w przyk³adzie wystêpuj± definicje etykiet o tych samych nazwach (<tt>LP</tt>), lecz ka¿da z nich ma inn± warto¶æ i jest innego zasiêgu.
<p></p>
<br />




<A NAME="labels_glo">
<u><tt><h2>Etykiety globalne</h2></tt></u>

<p>
Ka¿da definicja etykiety dokonana w g³ównym bloku programu poza obszarem makra <b><tt>.MACRO</tt></b>, procedury <b><tt>.PROC</tt></b> czy obszaru lokalnego <b><tt>.LOCAL</tt></b> jest zasiêgu globalnego, innymi s³owy jest globalna.
</p>

Etykiety globalne definiujemy u¿ywaj±c n/w równowa¿nych pseudo rozkazów:
<span style="color: #0000FF">
<pre>
 EQU
  =
</pre>
</span>

lub dyrektywy .DEF o sk³adni:
<span style="color: #0000FF">
<pre>
 .DEF :label [= expression]
</pre>
</span>

<p>
Dyrektywa .DEF umo¿liwia zdefiniowanie etykiety w aktualnym obszarze lokalnym, znak ':' na pocz±tku etykiety sygnalizuje etykietê globaln±. U¿ycie dyrektywy o sk³adni <b>.DEF :label</b> pozwala na zdefiniowanie etykiety globalnej z pominiêciem aktualnego poziomu lokalno¶ci.
</p>

<b>Znak dwukropka ':' na pocz±tku etykiety ma specjalne znaczenie, informuje ¿e odwo³ujemy siê do etykiety globalnej, czyli etykiety z g³ównego bloku programu z pominiêciem wszystkich poziomów lokalno¶ci.
</b>

<p></p>
Wiêcej informacji na temat u¿ycia dyrektywy .DEF w rozdziale <a href="#_def">Dyrektywa .DEF</a>

<p></p>


<u>Przyk³ad definicji etykiet globalnych:</u>
<span style="color: #0000FF">
<pre>
lab equ *
   lab2 equ $4000

	?tmp = 0
	?tmp += 40
 
.proc name

      .def :?nazwa   = $A000
           .def :nazwa=20

      .local lok1
        .def :@?nazw   = 'a'+32
      .endl

.endp
</pre>
</span>

Przyk³adem zastosowania definicji etykiety globalnej tymczasowej jest m.in. makro <b><tt>@CALL</tt></b> (plik  <tt>..\EXAMPLES\MACROS\@CALL.MAC</tt>), w którym wystêpuje definicja etykiety tymczasowej <b><tt>?@STACK_OFFSET</tt></b>. Jest ona pó¼niej wykorzystywana przez pozosta³e makra wywo³ywane z poziomu makra <b><tt>@CALL</tt></b>, a s³u¿y do optymalizacji programu odk³adaj±cego parametry na stos programowy.

<span style="color: #0000FF">
<pre>
@CALL .macro

  .def ?@stack_offset = 0    ; definicja etykiety globalnej tymczasowej ?@stack_offset
 
  ...
  ...
 
 
@CALL_@ .macro

  sta @stack_address+?@stack_offset,x
  .def ?@stack_offset = ?@stack_offset + 1    ; modyfikacja etykiety ?@stack_offset

 .endm 
</pre>
</span>
<br />



<A NAME="labels_set">
<u><tt><h2>Etykiety tymczasowe</h2></tt></u>

<p>
Definicja etykiety tymczasowej posiada t± w³a¶ciwo¶æ, ¿e jej warto¶æ mo¿e ulegaæ zmianie wielokrotnie nawet podczas jednego przebiegu asemblacji. Normalnie próba ponownej definicji etykiety koñczy siê komunikatem <b><tt>Label declared twice</tt></b>. Nie bêdzie takiego komunikatu je¶li jest to etykieta tymczasowa.
</p>

<p>
Zasiêg etykiet tymczasowych uzale¿niony jest od obszaru w jakim etykieta zosta³a zdefiniowana. Etykiety tymczasowe mog± posiadaæ zasiêg lokalny (<A HREF="#labels_lok">Etykiety lokalne</A>) lub globalny (<A HREF="#labels_glo">Etykiety globalne</A>).
</p>

Etykietê tymczasow± definiuje u¿ytkownik poprzez umieszczenie na pocz±tku nazwy etykiety znaku zapytania <tt>'?'</tt>, np.:
<span style="color: #0000FF">
<pre>
 ?label
</pre>
</span>

<b>
Etykiet tymczasowych nie powinno u¿ywaæ siê do nazw procedur <tt>.PROC</tt>, makr <tt>.MACRO</tt>, obszarów lokalnych <tt>.LOCAL</tt>, struktur <tt>.STRUCT</tt>, tablic <tt>.ARRAY</tt>.
</b>

<p></p>

Etykiety tymczasowe definiujemy u¿ywaj±c n/w równowa¿nych pseudo rozkazów:
<span style="color: #0000FF">
<pre>
 EQU
  =
</pre>
</span>

Dodatkowo mo¿emy je modyfikowaæ za pomoc± znanych z <tt>C</tt> operatorów:
<span style="color: #0000FF">
<pre>
 -= expression
 += expression
 --
 ++
</pre>
</span>

W/w operatory modyfikuj±ce dotycz± tylko etykiet tymczasowych, próba ich u¿ycia dla innego typu etykiety skoñczy siê komunikatem b³êdu <tt><b>Improper syntax</b></tt>.

<p></p>

<u>Przyk³ad u¿ycia etykiet tymczasowych:</u>
<span style="color: #0000FF">
<pre>
?loc = $567
?loc2 = ?loc+$2000

	 lda ?loc
	 sta ?loc2

?loc = $123

	 lda ?loc
</pre>
</span>
<br />


<A NAME="labels_mae">
<u><tt><h2>Etykiety lokalne w stylu MAE</h2></tt></u>

<p>
Opcja <b>OPT ?+</b> informuje MADS aby etykiety zaczynaj±ce siê znakiem <b>'?'</b> interpretowa³ jako etykiety lokalne tak jak robi to MAE. Domy¶lnie etykiety zaczynaj±ce siê znakiem <b>'?'</b> traktowane s± przez MADS jako <a href="#labels_set">Etykiety tymczasowe</a>.
</p>

<u>Przyk³ad u¿ycia etykiet lokalnych w stylu MAE:</u>
<span style="color: #0000FF">
<pre>
       opt ?+
       org $2000

local1 ldx #7
?lop   sta $a000,x
       dex
       bpl ?lop

local2 ldx #7
?lop   sta $b000,x
       dex
       bpl ?lop
</pre>
</span>
<br />




<A NAME="sdx">
<p class="duzy">
SPARTA DOS X
</p>


<A NAME="sdx_plik">
<u><tt><h2>Budowa plików Sparta DOS X, Atari DOS</h2></tt></u>
<p>
Przedruk z Serious Magazine, autor Qcyk/Dial.
</p>

<p>
Plik sam w sobie jest tylko  niewiele wartym zbiorem bajtów. Mnóstwo liczb, które mog± oznaczaæ wszystko, a zarazem nic, je¶li nie wiadomo jak je zinterpretowaæ. Wiêkszo¶æ plików wyposa¿a siê z tego powodu w ró¿norodne nag³ówki, w których pamiêtane s± informacje o tym co plik zawiera, ew. jak go potem traktowaæ przy odczycie. Do takich nale¿± równie¿ pliki wykonywalne, binarne, czy po prostu: przeznaczone do za³adowania z poziomu <tt>DOS'u</tt>. Wszak <tt>DOS</tt> to te¿ program i jak ka¿dy inny ma prawo oczekiwaæ danych o okre¶lonej, znanej mu strukturze.
</p>

<p>
Tradycyjne pliki binarne, rozpoznawane przez wszystkie <tt>DOS'y</tt> dla komputerów <tt>Atari XL/XE</tt>, maj±  budowê blokow±, gdzie ka¿dy blok posiada swój nag³ówek. Istniej± dwa rodzaje nag³ówków:
</p>
<pre>
 1. dta a($ffff),a(str_adr),a(end_adr)

 2. dta a(str_adr),a(end_adr)
</pre>

<p>
<tt><b>str_adr</b></tt> - adres, pod który zostanie za³adowany pierwszy bajt danych 
</p>

<p>
<tt><b>end_adr</b></tt> - adres, pod który zostanie za³adowany ostatni bajt
</p>
</pre>


<p>
Pierwszy blok w pliku musi mieæ nag³ówek typu <tt>$ffff</tt>, pozosta³e bloki dowolnie. Za nag³ówkiem oczywi¶cie powinny znale¼æ siê dane w ilo¶ci:
</p>

<pre>
   (end_adr-str_adr)+1
</pre>

<p>
Tyle tytu³em przypomnienia. Twórcy systemu Sparta DOS X zachowali powy¿szy standard, dodaj±c  jednocze¶nie kilka nowych typów  nag³ówków. Ci±gle wiêc mamy do czynienia z plikiem podzielonym na bloki, z tym ¿e rodzajów bloków jest teraz du¿o wiêcej. Oto one:
</p>
<br />


<h4><u>1. Blok nierelokowalny (³adowany pod sta³y adres w pamiêci):</u></h4>
<pre>
    dta a($fffa),a(str_adr),a(end_adr)
</pre>
<p>
Jest to to samo co blok <tt>$ffff</tt> - nie ma znaczenia, który zostanie u¿yty. <tt>$fffa</tt> bêdzie jednak wyra¼nie wskazywaæ, ¿e program jest przeznaczony dla <tt>SDX</tt> - inny <tt>DOS</tt> takiego pliku nie odczyta.
</p>
<br />


<h4><u>2. Blok relokowalny (³adowany pod <tt>MEMLO</tt> we wskazany rodzaj pamiêci):</u></h4>
<pre>
    dta a($fffe),b(blk_num),b(blk_id)
    dta a(blk_off),a(blk_len)
</pre>
<p>
<tt><b>blk_num</b></tt> - numer bloku w pliku. Ka¿dy blok relokowalny powinien posiadaæ swój w³asny numer. Poniewa¿ adresy ³adowania bloków nie s± znane, bloki identyfikowane s± w³a¶nie poprzez swoje numery.
Mog± one przyjmowaæ warto¶ci z zakresu 0-7, z tym ¿e w praktyce stosuje siê zwykle numeracjê od 1 w górê.
</p>

<p>
<tt><b>blk_id</b></tt> - bity 1-5 stanowi± indeks pamiêci, do której blok ma zostaæ za³adowany. Spotka³em siê z
dwoma warto¶ciami:
<pre>
 $00 - pamiêæ podstawowa
 $02 - pamiêæ rozszerzona
</pre>       
Ustawienie dodatkowo bitu 7 oznacza brak bloku danych. <tt>SDX</tt> nic wtedy nie ³aduje, ale rezerwuje pamiêæ.
</p>

<p>     
<tt><b>blk_off</b></tt> - tzw. przesuniêcie adresów w bloku, czyli po prostu adres, pod który by³ assemblowany  kod. Jest to potrzebne przy uaktualnianiu adresów odwo³uj±cych siê do zawarto¶ci bloku.
</p>

<p> 
<tt><b>blk_len</b></tt> - d³ugo¶æ bloku. Tyle danych powinno byæ za nag³ówkiem chyba, ¿e jest to blok rezerwuj±cy pamiêæ wtedy danych nie ma.
</p>

Pisz±c kod relokowalny trzeba mieæ na uwadze kilka ograniczeñ jakie narzuca idea  "przemieszczalnego"
kodu. Wszystkie adresy odwo³uj±ce siê do obszaru takiego programu musz± zostaæ uaktualnione podczas ³adowania, w zwi±zku z tym nie mo¿na u¿ywaæ sekwencji takich jak np.:

<pre>
       lda <co¶
       ldx >co¶
       ...
      co¶ equ *
       ...
    Zamiast tego, pozostaje np.:
       lda _co¶
       ldx _co¶+1
       ...
      _co¶ dta a(co¶)
       ...
      co¶ equ *
</pre>
<br />


<h4><u>3. Blok aktualizacji adresów  odnosz±cych siê do bloku relokowalnego:</u></h4>
<pre>
    dta a($fffd),b(blk_num),a(blk_len)
</pre>

<p>
<tt><b>blk_num</b></tt> - numer bloku, do którego odnosz± siê uaktualniane adresy.
</p>

<p>
<tt><b>blk_len</b></tt> - d³ugo¶æ bloku aktualizacji (bez nag³ówka). Jest ona ignorowana.
</p>

<p>
Adresy s± uaktualniane poprzez dodanie do adresu istniej±cego ró¿nicy pomiêdzy adresem, pod który zosta³ za³adowany wskazany blok relokowalny, a warto¶ci± <tt>blk_off</tt> (adresem asemblacji) tego bloku.  Mo¿na to przedstawiæ wzorem:
<pre>
       ADR=ADR+(blk_adr-blk_off)
</pre>
</p>

<p>
"Cia³o" bloku aktualizacji stanowi± wska¼niki do poprawianych adresów oraz rozkazy specjalne. Wska¼nik
jest liczb± z zakresu <tt>$00-$fb</tt> i oznacza przesuniêcie wzglêdem miejsca poprzedniej aktualizacji. Miejsce to jest pamiêtane przez program ³aduj±cy jako bezpo¶redni adres, nazwijmy go licznikiem aktualizacji. Licznik ten mo¿na zainicjowaæ za pomoc± funkcji specjalnych, którymi s± liczby wiêksze od <tt>$fb</tt>:

<p>
<u><tt><b>$fc</b></tt></u>
oznacza koniec bloku aktualizacji,
</p>

<p>
<u><tt><b>$fd,a(ADDR)</b></tt></u>
nastêpuje aktualizacja adresu wskazanego bezpo¶rednio przez <tt>ADDR</tt>. Tym samym warto¶æ <tt>ADDR</tt> jest wpisywana do licznika aktualizacji i od niej bêd± liczone kolejne przesuniêcia,
</p>

<p>
<u><tt><b>$fe,b(blk_num)</b></tt></u>
do licznika aktualizacji wstawiany jest adres bloku wskazanego przez <tt>blk_num</tt>, czyli kolejne aktualizacje bêd± siê odnosi³y do kodu zawartego w tym bloku,
</p>

<p>
<u><tt><b>$ff</b></tt></u>
licznik aktualizacji zwiêkszany jest o <tt>$fa</tt> (bez aktualizacji adresu).
</p>
<br />


<h4><u>4. Blok aktualizacji adresów procedur zdefiniowanych symbolami:</u></h4>
<pre>
    dta a($fffb),c'SMB_NAME',a(blk_len)
</pre>

<p>
<tt><b>SMB_NAME</b></tt> - symboliczna nazwa procedury (lub tablicy, rejestru systemowego itp.) Osiem  znaków w kodzie <tt>ATASCII</tt>,
</p>

<p>
<tt><b>blk_len</b></tt> - jak w bloku <tt>$fffd</tt>.
<p>

<p>
Po nag³ówku wystêpuje ci±g wska¼ników okre¶laj±cych po³o¿enie adresów do zaktualizowania - identycznie
jak w bloku <tt>$fffd</tt>. Adresy s± zmieniane poprzez dodanie do istniej±cego adresu, adresu procedury okre¶lonej symbolem. Pozwala to na wykorzystywanie w programach procedur, których adresów nie znamy, np.
procedur dodawanych przez inne programy uruchamiane w ¶rodowisku <tt>SDX</tt>. Tak¿e procedury  systemowe powinny byæ wykorzystywane w ten sposób, przecie¿ mog± one mieæ ró¿ne adresy w ró¿nych wersjach Sparty.
</p>
<br />


<h4><u>5. Blok definicji nowych symboli:</u></h4>
<pre>
    dta a($fffc),b(blk_num),a(smb_off)
    dta c'SMB_NAME'
</pre>

<p>
<tt><b>blk_num</b></tt> - numer bloku, w którym znajduje siê definiowana procedura. Wynika z tego, ¿e procedura musi byæ za³adowana jako blok relokowalny.
</p>

<p>
<tt><b>smb_off</b></tt> - przesuniêcie adresu procedury w bloku, czyli offset procedury wzglêdem pocz±tku bloku (pierwszy bajt ma numer 0) powiêkszony o warto¶æ <tt>blk_off</tt> tego bloku. Inaczej  jest to adres pod jaki procedura zosta³a zassemblowana, <tt>SMB_NAME</tt> - symboliczna nazwa definiowanej procedury.
</p>

<p>
Bloki typu <tt>$fffb</tt>, <tt>$fffc</tt>, <tt>$fffd</tt> nie s± na sta³e zatrzymywane w pamiêci. System wykorzystuje je tylko podczas ³adowania programu.
</p>
<br />



<A NAME="sparta">
<u><tt><h2>Programowanie Sparta DOS X (SDX)</h2></tt></u>
<p>
Sk³adnia dotycz±ca obs³ugi <tt>Sparta DOS X</tt>, zaczerpniêta zosta³a z <tt>FastAssemblera</tt> autorstwa <tt>Marka Goderskiego</tt>, poni¿ej cytat z instrukcji do³±czonej do <tt>FA</tt>. Pliki ¼ród³owe <tt>*.FAS</tt> mo¿na obecnie bez wiêkszych problemów asemblowaæ <tt>MADS-em</tt>. Rozkazy relokowalne maj± zawsze 2 bajtowy argument, nie ma mo¿liwo¶ci relokowania 3 bajtowych argumentów <tt>(65816)</tt>.
</p>

<p>
Najwa¿niejsz± nowo¶ci± w <tt>SDX</tt> dla programisty jest mo¿liwo¶æ prostego pisania programów relokowalnych. Poniewa¿ procesor <tt>MOS 6502</tt> nie posiada adresowania wzglêdnego, (prócz krótkich skoków warunkowych) programi¶ci z <tt>ICD</tt> zastosowali specjalne mechanizmy ³adowania bloków programu. Ca³y proces polega na za³adowaniu bloku, a nastêpnie specjalnego bloku aktualizacji adresów. Wszystkie adresy w bloku programu s± liczone od zera. Wystarczy wiêc dodaæ do nich warto¶æ <tt>memlo</tt> aby otrzymaæ adres w³a¶ciwy. Które adresy zwiêkszyæ, a które pozostawiæ? W³a¶nie po to jest specjalny blok aktualizacji który zawiera wska¼niki (specjalnie kodowane) do tych¿e adresów. Tak wiêc po bloku lub blokach <tt><b>RELOC</b></tt> obowi±zkowe jest wykonanie <tt><b>UPDATE ADRESS</b></tt> dla poprawnego dzia³ania programu. Równie¿ po blokach <tt><b>SPARTA</b></tt> w których rozkazy (lub wektory) odwo³uj± siê do bloków <tt><b>RELOC</b></tt> lub <tt><b>EMPTY</b></tt> obowi±zkowe jest wykonanie <tt><b>UPDATE ADRESS</b></tt>.
</p>

<p>
Nastêpn± innowacj± jest wprowadzenie symboli. Otó¿ niektóre procedury us³ugowe <tt>SDX</tt> zosta³y
zdefiniowane za pomoc± nazw! Nazwy te maja zawsze 8 liter (podobnie jak nazwy plików). Zamiast korzystaæ z tablic wektorów lub skoków (jak w OS) korzystamy z symboli definiowanych <b><tt>SMB</tt></b>. Po wczytaniu bloku lub bloków programu <tt>SDX</tt> ³aduje blok aktualizacji symboli i w podobny sposób
jak przy blokach relokowalnych zamienia adresy w programie. Symbole mog± byæ u¿ywane dla bloków <tt><b>RELOC</b></tt> i <tt><b>SPARTA</b></tt>.
</p>

<p>
Programista mo¿e zdefiniowaæ w³asne symbole zastêpuj±ce <tt>SDX</tt> lub zupe³nie nowe dla wykorzystania przez inne programy. Robi siê to poprzez blok <tt><b>UPDATE NEW</b></tt>. Trzeba jednak wiedzieæ ¿e nowy symbol musi byæ zawarty w bloku <tt><b>RELOC</b></tt>.
</p>

<p>
Liczba bloków <tt><b>RELOC</b></tt> i <tt><b>EMPTY</b></tt> jest ograniczona do 7 przez <tt>SDX</tt>.
</p>

<p>
Bloki takie mo¿na ³±czyæ w ³añcuchy np:
<pre>
       blk sparta $600
       ...

       blk reloc main
       ...

       blk empty $100 main
       ...

       blk reloc extended
       ...

       blk empty $200 extended
</pre>
Oznacza to ¿e rozkazy w tych blokach mog± odwo³ywaæ siê do wszystkich bloków w ³añcuchu.
</p>

<p>
£añcuch taki nie jest przerywany przez aktualizacjê adresów, lub symboli ale jest niszczony przez
definicjê nowego symbolu, oraz inne bloki (np: dos).
</p>

<p>
<tt><b>Uwaga:</b></tt> £añcuch taki ma sens tylko wtedy gdy wszystkie jego bloki ³aduj± siê do tej samej pamiêci, lub gdy program przy odpowiednich odwo³aniach prze³±cza pamiêæ.
</p>

<p>
<tt><b>Uwaga:</b></tt> Rozkazy i wektory w blokach <tt><b>RELOC</b></tt> i <tt><b>EMPTY</b></tt> nie powinny odwo³ywaæ siê do bloków <tt><b>SPARTA</b>!</tt> Mo¿e to spowodowaæ b³±d gdy u¿ytkownik za³aduje program komend± <tt><b>LOAD</b></tt>, a u¿yje go po d³u¿szym czasie. O ile bloki <tt><b>RELOC</b></tt> i <tt><b>EMPTY</b></tt> by³y bezpieczne to nigdy nie wiadomo co jest w pamiêci tam gdzie ostatnio by³ blok <tt><b>SPARTA</b>!</tt>
</p>

<p>
Równie niebezpieczne jest u¿ywanie odwo³añ do bloków <tt><b>RELOC</b></tt> i <tt><b>EMPTY</b></tt> przez bloki <tt><b>SPARTA</b></tt> (powód jak wy¿ej), jednak¿e podczas instalowania nak³adek (*.sys) z u¿yciem
<tt><b>INSTALL</b></tt> jest to czasem niezbêdne, st±d jest dopuszczalne. Mo¿na tak¿e inicjowaæ blok <tt><b>SPARTA</b></tt> (porzez <tt>$2E2</tt>) bêdzie on wtedy zawsze uruchomiony, a potem ju¿ zbêdny.
</p>

<p>
<tt><b>Uwaga:</b></tt> Pomiêdzy blokami <tt><b>SPARTA</b></tt>, a <tt><b>RELOC</b></tt> i <tt><b>EMPTY</b></tt> mo¿e doj¶æ do kolizji adresów! <tt>FA</tt> rozpoznaje odwo³ania do innych bloków poprzez adresy, przyjmuj±c <tt>PC</tt> dla <tt><b>RELOC</b></tt> i <tt><b>EMPTY</b></tt> od <tt>$1000</tt>, tak wiêc gdy mieszamy te bloki nale¿y mieæ pewno¶æ ze <tt><b>SPARTA</b></tt> le¿y poni¿ej <tt>$1000</tt> (np:<tt>$600</tt>) lub powy¿ej ostatniego bloku relokowalnego, zazwyczaj wystarcza <tt>$4000</tt>. B³±d taki nie jest przez kompilator wykrywany !
</p>
<p></p>
<br />



<A NAME="_relok">
<p class="duzy">
KOD RELOKOWALNY
</p>
Kod relokowalny to taki kod, który nie ma z góry okre¶lonego adresu ³adowania do pamiêci komputera, kod taki musi zadzia³aæ niezale¿nie od adresu za³adowania. W Atari XE/XL kod relokowalny udostêpnia system Sparta DOS X (SDX), wiêcej na ten temat mo¿na przeczytaæ w rozdziale <A HREF="#sparta">Programowanie Sparta DOS X</A>.
<p>
Kod relokowalny dla SDX posiada podstawowe ograniczenie jakim jest relokowanie tylko adresów typu WORD, nie ma tak¿e obs³ugi rozkazów CPU 65816. MADS udostêpnia mo¿liwo¶æ generowania kodu relokowalnego w formacie SDX jak i swoim w³asnym niekompatybilnym z SDX, który znosi wcze¶niej wymienione ograniczenia.
</p>

<p>
Format zapisu pliku z kodem relokowalnym MADS-a jest podobny do tego znanego z SDX, podobnie wystêpuje tutaj blok g³ówny i bloki dodatkowe z informacj± o adresach które nale¿y poddaæ relokacji. MADS stosuje prostszy zapis bloków aktualizacji, bez "kompresji" jak± stosuje SDX.
</p>

<A NAME="_relok_zal">
<p>
<u>Zalety kodu relokowalnego MADS-a:</u>
<li>uwzglêdnia rozmiar argumentów dla CPU 6502, 65816
<li>mo¿na u¿ywaæ wszystkie rozkazy CPU, bez ograniczeñ
<li>pozwala na relokacje m³odszych i starszych bajtów adresu
</p>

<A NAME="_relok_ogr">
<p>
<u>Ograniczenia kodu relokowalnego MADS-a:</u>
<li>deklaracji etykiet przez EQU dokonujemy przed blokiem .RELOC
<li>je¶li chcemy zdefiniowaæ now± etykietê w bloku .RELOC musimy jej nazwê poprzedziæ spacj± lub tabulatorem (etykieta globalna)
<li>nie mo¿na u¿ywaæ pseudo rozkazów ORG, RMB, LMB, NMB oraz dyrektywy .DS
<li>nie mo¿na relokowaæ najstarszego bajtu ze s³owa 24bit, np. lda ^$121416
</p>

Przyk³adem tego jak prosto mo¿na stworzyæ kod relokowalny jest plik ..\EXAMPLES\TETRIS_RELOC.ASM, który od strony u¿ytej listy rozkazów CPU i pseudo rozkazów definiuj±cych dane niczym nie ró¿ni siê od wersji nierelokowalnej ..\EXAMPLES\TETRIS.ASM 

<p></p>
<br />


<A NAME="_reloc">
<u><tt><h2>Blok relokowalny .RELOC</h2></tt></u>

<p>
Blok relokowalny MADS-a zostanie wygenerowany po u¿yciu dyrektywy:
<span style="color: #0000FF">
<pre>
 .RELOC [.BYTE|.WORD]
</pre>
</span>

Blok aktualizacji dla bloku relokowalnego MADS-a wywo³ujemy u¿ywaj±c pseudo rozkazu BLK:
<span style="color: #0000FF">
<pre>
 BLK UPDATE ADDRESS
</pre>
</span>


Po dyrektywie .RELOC mo¿liwe jest podanie typu bloku relokowalnego (.BYTE, .WORD), domy¶lnie jest to typ .WORD. Typ .BYTE dotyczy bloku przeznaczonego do umieszczenia wy³±cznie na stronie zerowej (bêdzie zawiera³ rozkazy strony zerowej), MADS bêdzie asemblowa³ taki blok od adresu <b>$0000</b>. Typ .WORD oznacza ¿e MADS bêdzie asemblowa³ blok relokowalny od adresu <b>$0100</b> i bêdzie przeznaczony do umieszczenia w dowolnym obszarze pamiêci (nie bêdzie zawiera³ rozkazów strony zerowej).

<p>
Nag³ówek bloku .RELOC przypomina ten znany z DOS-a, dodatkowo zosta³ on rozszerzony o 10 nowych bajtów czyli w sumie zajmuje 16 bajtów, np.:
</p>

<span style="color: #0000FF">
<pre>
HEADER            .WORD = $FFFF
START_ADDRESS     .WORD = $0000
END_ADDRESS       .WORD = FILE_LENGTH-1
MADS_RELOC_HEADER .WORD = $524D
UNUSED            .BYTE = $00
CONFIG            .BYTE (bit0)
@STACK_POINTER    .WORD
@STACK_ADDRESS    .WORD    
@PROC_VARS_ADR    .WORD
</pre>
</span>


<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><tt><b>MADS_RELOC_HEADER</b> </td>
	<td><tt>zawsze o warto¶ci $524D co odpowiada znakom 'MR' (M-ADS R-ELOC)</td>
</tr>
<tr>
	<td><tt><b>FILE_LENGTH</b></td>
	<td><tt>to d³ugo¶æ bloku relokowalnego bez 16 bajtowego nag³ówka</td>
</tr>
<tr>
	<td><tt><b>CONFIG</b></td>
	<td><tt>wykorzystany jest obecnie tylko bit0 tego bajtu, bit0=0 oznacza blok relokowalny asemblowany od adresu <b>$0000</b>, bit0=1 blok relokowalny asemblowany od adresu <b>$0100</b></td>
</tr>
</table>

<p>
Ostatnie 6 bajtów zawiera informacjê o warto¶ciach etykiet potrzebnych do dzia³ania stosu programowego <b>@STACK_POINTER, @STACK_ADDRESS, @PROC_VARS_ADR</b> je¶li zosta³y u¿yte podczas asemblacji bloków relokowalnych. Je¶li poszczególne bloki .RELOC zosta³y zasemblowane z ró¿nymi warto¶ciami tych etykiet i s± one linkowane  wyst±pi wówczas komunikat ostrze¿enia <b>Incompatible stack parameters</b>. Je¶li stos programowy nie zosta³ u¿yty warto¶ciami tych etykiet s± zera.
</p>

<p>
Pseudo rozkaz .RELOC powoduje prze³±czenie MADS-a w tryb generowania kodu relokowalnego z uwzglêdnianiem rozmiaru argumentów rozkazów CPU 6502, 65816. W obszarze takiego kodu niemo¿liwe jest u¿ywanie pseudo rozkazów <b>ORG, LMB, NMB, RMB</b> oraz dyrektywy <b>.DS</b>. Niemo¿liwy jest powrót MADS-a do trybu generowania kodu nie relokowalnego, mo¿liwe jest wygenerowanie wiêcej ni¿ jednego bloku .RELOC.
</p>

<p>
U¿ycie dyrektywy .RELOC powoduje dodatkowo zwiêkszenie licznika wirtualnych banków MADS-a, przez co taki obszar staje siê lokalny i niewidoczny dla innych bloków. Wiêcej informacji na temat wirtualnych banków w rozdziale <A HREF="#banks_wir">Wirtualne banki pamiêci (OPT B-)</A>.
</p>


<p>
Na koñcu bloku .RELOC wymagane jest wygenerowanie bloku aktualizacji, realizuje to pseudo rozkaz BLK z identyczn± sk³adni± jak dla bloku relokowalnego SDX ("BLK UPDATE ADDRESS"). Format zapisu takiego bloku aktualizacji nie jest jednak identyczny z SDX, ma nastêpuj±c± postaæ:
</p>

<span style="color: #0000FF">
<pre>
HEADER       WORD ($FFEF)
TYPE         CHAR (B-YTE, W-ORD, L-ONG, D-WORD, &lt, &gt)
DATA_LENGTH  WORD
DATA         WORD [BYTE]
</pre>
</span>


<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><tt><b>HEADER</b></td>
	<td><tt>zawsze o warto¶ci $FFEF</td>
</tr>
<tr>
	<td><tt><b>TYPE</b></td>
	<td><tt>typ danych zapisany jest na bitach 0..6 tego bajtu i okre¶la typ modyfikowanych adresów, znak "&lt" oznacza m³odszy bajt adresu, znak "&gt" oznacza starszy bajt adresu.</td>
</tr>
<tr>
	<td><tt><b>DATA_LENGTH</b></td>
	<td><tt>to liczba 2-bajtowych danych (adresów) do modyfikacji</td>
</tr>
<tr>
	<td><tt><b>DATA</b></td>
	<td><tt>to w³a¶ciwy ci±g danych s³u¿±cych modyfikacji g³ównego bloku relokowalnego. Pod wskazanym tutaj adresem nale¿y odczytaæ warto¶æ typu TYPE a nastêpnie zmodyfikowaæ na podstawie nowego adresu ³adowania.</td>
</tr>
</table>

<p>
Wyj±tek stanowi blok aktualizacji dla starszych bajtów adresów "&gt", dla takiego bloku w DATA zapisywany jest jeszcze dodatkowy bajt BYTE (m³odszy bajt modyfikowanego adresu). Aby dokonaæ aktualizacji starszych bajtów, musimy odczytaæ bajt spod adresu WORD w DATA, dodaæ go do aktualnego adresu relokacji i dodaæ jeszcze m³odszy bajt z BYTE w DATA. Tak nowo obliczony starszy bajt umieszczamy pod adresem WORD z DATA. 
</p>
<br />



<A NAME="labels_ext">
<u><tt><h2>Symbole zewnêtrzne</h2></tt></u>

<p>
Symbole zewnêtrzne informuj±, ¿e zmienne i procedury które reprezentuj± bêd± znajdowa³y siê gdzie¶ na zewn±trz, poza aktualnym programem. Nie musimy okre¶laæ gdzie. Musimy jedynie podaæ ich nazwy oraz typy. W zale¿no¶ci od typu danych jakie reprezentuje symbol instrukcje asemblera t³umaczone s± na odpowiednie kody maszynowe, asembler musi znaæ rozmiar u¿ywanych danych.
</p>

<b>Aktualnie nie istnieje mo¿liwo¶æ dokonywania operacji na symbolach external typu '^' (najstarszy bajt).</b>


<p>
Symbole zewnêtrzne mog± byæ u¿ywane w blokach relokowalnych .RELOC jak i w zwyk³ych blokach DOS-a.
</p>

Symbole zewnêtrzne (external) deklarujemy u¿ywaj±c pseudo rozkazu EXT lub dyrektywy .EXTRN:
<span style="color: #0000FF">
<pre>
label EXT type
label .EXTRN type
.EXTRN label1,label2,label3... type
</pre>
</span>


Blok aktualizacji dla symboli external wywo³ujemy u¿ywaj±c pseudo rozkazu BLK:
<span style="color: #0000FF">
<pre>
 BLK UPDATE EXTERNAL
</pre>
</span>

<b>UWAGA:</b> <u>Zostan± zapisane symbole, które zosta³y u¿yte w programie</u>.

<p>
Symbole external nie maj± zdefiniowanej warto¶ci tylko typ (<tt>.BYTE, .WORD, .LONG , .DWORD</tt>) np.:

<span style="color: #0000FF">
<pre>
name EXT .BYTE

label_name EXT .WORD

 .EXTRN label_name .WORD

wait EXT .PROC (.BYTE delay)
</pre>
</span>

Symbol external z deklaracj± procedury .PROC przyjmuje domy¶lnie typ .WORD, próba odwo³ania siê do nazwy takiej etykiety zostanie potraktowana przez MADS jako próba wywo³ania procedury, wiêcej na temat wywo³añ procedur .PROC w rozdziale <A HREF="#procs">Procedury</A>. 
</p>

W procesie asemblacji po napotkaniu odwo³ania do symbolu external zawsze podstawiane s± zera.

<p>
Symbole external przydaæ siê nam mog± wówczas gdy chcemy zasemblowaæ program oddzielnie, niezale¿nie od reszty w³a¶ciwego programu. W takim programie wystêpuj± wówczas najczê¶ciej odwo³ania do procedur, zmiennych które zosta³y zdefiniowane gdzie¶ indziej, na zewn±trz, a my nie znamy ich warto¶ci tylko typ. W tym momencie z pomoc± przychodz± symbole external, które umo¿liwiaj± asemblacjê takiego programu mimo braku w³a¶ciwych procedur czy zmiennych.
</p>

<p>
Innym zastosowaniem symboli external mog± byæ tzw. "pluginy" programy zewnêtrzne po³±czone z programem g³ównym i realizuj±ce dodatkowe czynno¶ci. S± to swoistego rodzaje biblioteki, wykorzystuj±ce procedury programu g³ównego, rozszerzaj±ce jego funkcjonalno¶æ. Aby stworzyæ taki plugin nale¿a³oby okre¶liæ jakie procedury udostêpnia program g³ówny (ich nazwy+parametry i typ) oraz stworzyæ procedurê odczytu pliku z symbolami external, ta procedura realizowa³aby do³±czanie pluginów do g³ównego programu.
</p>

<p>
Poni¿ej format zapisu nag³ówka w pliku z symbolami external typu B-YTE, W-ORD, L-ONG i D-WORD po wywo³aniu przez BLK UPDATE EXTERNAL:
</p>

<span style="color: #0000FF">
<pre>
HEADER        WORD ($FFEE)
TYPE          CHAR (B-YTE, W-ORD, L-ONG, D-WORD, &lt, &gt)
DATA_LENGTH   WORD
LABEL_LENGTH  WORD
LABEL_NAME    ATASCII
DATA          WORD .. .. ..
</pre>
</span>


<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><tt><b>HEADER</b> </td>
	<td><tt>zawsze o warto¶ci $FFEE</td>
</tr>
<tr>
	<td><tt><b>TYPE</b></td>
	<td><tt>typ danych zapisany jest na bitach 0..6 tego bajtu i okre¶la typ modyfikowanych adresów</td>
</tr>
<tr>
	<td><tt><b>DATA_LENGTH</b> </td>
	<td><tt>to liczba 2-bajtowych danych (adresów) do modyfikacji</td>
</tr>
<tr>
	<td><tt><b>LABEL_LENGTH</b> </td>
	<td><tt>to d³ugo¶æ nazwy symbolu wyra¿ona w bajtach</td>
</tr>
<tr>
	<td><tt><b>LABEL_NAME</b></td>
	<td><tt>to nazwa symbolu w kodach ATASCII</td>
</tr>
<tr>
	<td><tt><b>DATA</b> </td>
	<td><tt>w³a¶ciwy ci±g danych s³u¿±cych modyfikacji g³ównego bloku relokowalnego. Pod wskazanym tutaj adresem nale¿y odczytaæ warto¶æ typu TYPE a nastêpnie zmodyfikowaæ na podstawie nowej warto¶ci symbolu.</td>
</tr>
</table>


<p>
<A NAME="_prz_str">
Przyk³adem zastosowania symboli external i struktur .STRUCT jest przyk³adowa biblioteka prymitywów graficznych (PLOT, LINE, CIRCLE) z katalogu ..\EXAMPLES\LIBRARIES\GRAPHICS\LIB. Poszczególne modu³y wykorzystuj± tutaj do¶æ spor± liczbê zmiennych na stronie zerowej, je¶li chcemy aby adresy tych zmiennych by³y relokowalne musieliby¶my ka¿d± z osobna zmienn± zadeklarowaæ jako symbol zewnêtrzny przez EXT (lub .EXTRN). Mo¿emy to upro¶ciæ wykorzystuj±c tylko jeden symbol zewnêtrzny i strukturê danych .STRUCT. Za pomoc± struktur definiujemy "mapê" zmiennych ZP, potem jeden symbol external ZPAGE typu .BYTE bo chcemy aby zmienne by³y na stronie zerowej. Teraz odwo³uj±c siê do zmiennej musimy zapisaæ to w sposób wymuszaj±cy relokowalno¶æ np. ZPAGE+ZP.DX i tak powsta³ modu³ ca³kowicie relokowalny z mo¿liwo¶ci± zmiany adresu zmiennych w przestrzeni strony zerowej.
</p>
<br />



<A NAME="labels_pub">
<u><tt><h2>Symbole publiczne</h2></tt></u>

<p>
Symbole publiczne udostêpniaj± zmienne i procedury wystêpuj±ce w bloku relokowalnym pozosta³ej czê¶ci asemblowanego programu. Dziêki symbolom publicznym mo¿emy odwo³ywaæ siê do zmiennych i procedur "zaszytych" np. w bibliotekach.
</p>

<p>
Symbole publiczne mog± byæ u¿ywane w blokach relokowalnych .RELOC jak i w zwyk³ych blokach DOS-a.
</p>


<p>
MADS sam rozpoznaje czy podana do upublicznienia etykieta jest zmienn±, sta³± czy te¿ procedur± zadeklarown± przez .PROC, nie jest wymagana ¿adna dodatkowa informacja jak w przypadku symboli zewnêtrznych.
</p>


Symbole publiczne deklarujemy u¿ywaj±c n/w dyrektyw:
<span style="color: #0000FF">
<pre>
 .PUBLIC label [,label2,...]
 .GLOBAL label [,label2,...]
 .GLOBL label [,label2,...]
</pre>
</span>

Dyrektywy .GLOBAL i .GLOBL zosta³y dodane z my¶l± o kompatybilno¶ci z innymi assemblerami, ich znaczenie jest identyczne z dyrektyw± .PUBLIC.
<p></p>

Blok aktualizacji dla symboli publicznych wywo³ujemy u¿ywaj±c pseudo rozkazu BLK:
<span style="color: #0000FF">
<pre>
 BLK UPDATE PUBLIC
</pre>
</span>

<p>
Poni¿ej format zapisu nag³ówka w pliku z symbolami publicznymi po wywo³aniu przez BLK UPDATE PUBLIC:
</p>

<span style="color: #0000FF">
<pre>
HEADER        WORD ($FFED)
LENGTH        WORD
TYPE          BYTE (B-YTE, W-ORD, L-ONG, D-WORD)
LABEL_TYPE    CHAR (C-ONSTANT, V-ARIABLE, P-ROCEDURE, A-RRAY, S-TRUCT)
LABEL_LENGTH  WORD
LABEL_NAME    ATASCII
ADDRESS       WORD
</pre>
</span>

MADS automatycznie dobiera odpowiedni typ dla upublicznianej etykiety:
<pre>
<span style="color: #0000FF"><li>C-ONSTANT</li></span>  etykieta nie poddaj±ca siê relokacji
<span style="color: #0000FF"><li>V-ARIABLE</li></span>  etykieta poddaj±ca siê relokacji
<span style="color: #0000FF"><li>P-ROCEDURE</li></span> procedura zadeklarowana przez .PROC, podlega relokacji
<span style="color: #0000FF"><li>A-RRAY</li></span>     tablica zadeklarowana przez .ARRAY, podlega relokacji
<span style="color: #0000FF"><li>S-TRUCT</li></span>    struktura zadeklarowana przez .STRUCT, nie podlega relokacji
</pre>

Je¶li symbol dotyczy struktury .STRUCT wówczas zapisywane s± dodatkowe informacje (typ pola struktury, nazwa pola struktury, liczba powtórzeñ pola struktury):
<span style="color: #0000FF">
<pre>
STRUCT_LABEL_TYPE    CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
STRUCT_LABEL_LENGTH  WORD
STRUCT_LABEL_NAME    ATASCII
STRUCT_LABEL_REPEAT  WORD
</pre>
</span>

Je¶li symbol dotyczy tablicy .ARRAY wówczas zapisywane s± dodatkowe informacje (maksymalny zadeklarowany indeks tablicy, typ zadeklarowanych pól tablicy):
<span style="color: #0000FF">
<pre>
ARRAY_MAX_INDEX  WORD
ARRAY_TYPE       CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
</pre>
</span>


Je¶li symbol dotyczy procedury .PROC wówczas zapisywane s± dodatkowe informacje, niezale¿nie od tego czy procedura mia³a czy te¿ nie mia³a zadeklarowane parametry:
<span style="color: #0000FF">
<pre>
PROC_CPU_REG  BYTE (bits 00 - regA, 01 - regX, 10 - regY)
PROC_TYPE     BYTE (D-EFAULT, R-EGISTRY, V-ARIABLE)
PARAM_COUNT   WORD
</pre>
</span>

<p>
Dla symboli dotycz±cych procedur .REG zapisywane s± ju¿ teraz tylko typy tych parametrów w ilo¶ci PARAM_COUNT:
</p>

<span style="color: #0000FF">
<pre>
PARAM_TYPE    CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
...
...
</pre>
</span>


<p>
Dla symboli dotycz±cych procedur .VAR zapisywane s± typy parametrów i ich nazwy. PARAM_COUNT okre¶la ca³kowit± d³ugo¶æ tych danych:
</p>


<span style="color: #0000FF">
<pre>
PARAM_TYPE    CHAR (B-YTE, W-ORD, L-ONG, D-WORD)
PARAM_LENGTH  WORD
PARAM_NAME    ATASCII
...
...
</pre>
</span>




<table cellspacing="2" cellpadding="2" border="2" frame="box" rules="all">
<tr>
	<td><tt><b>HEADER</b></td>
	<td><tt>zawsze o warto¶ci $FFED</td>
</tr>
<tr>
	<td><tt><b>LENGTH</b> </td>
	<td><tt>to liczba symboli zapisanych w bloku aktualizacji</td>
</tr>
<tr>
	<td><tt><b>TYPE</b></td>
	<td><tt>typ symbolizowanych danych B-YTE, W-ORD, L-ONG, D-WORD</td>
</tr>
<tr>
	<td><tt><b>LABEL_TYPE</b></td>
	<td><tt>typ symbolu: V-ARIABLE, C-ONSTANT, P-ROCEDURE, A-RRAY, S-TRUCT
	<br />
	Dla typu P zapisywane s± dodatkowe informacje: PROC_CPU_REG, PROC_TYPE, PARAM_COUNT, PARAM_TYPE
	<br />
   Dla typu A zapisywane s± dodatkowe informacje: ARRAY_MAX_INDEX, ARRAY_TYPE
   <br />
   Dla typu S zapisywane s± dodatkowe informacje: STRUCT_LABEL_TYPE, STRUCT_LABEL_LENGTH, STRUCT_LABEL_NAME, STRUCT_LABEL_REPEAT 
	</td>
</tr>
<tr>
	<td><tt><b>LABEL_LENGTH</b> </td>
	<td><tt>d³ugo¶æ etykiety symbolu publicznego wyra¿ona w bajtach</td>
</tr>
<tr>
	<td><tt><b>LABEL_NAME</b> </td>
	<td><tt>etykieta symbolu publicznego zapisana w kodach ATASCII</td>
</tr>
<tr>
	<td><tt><b>ADDRESS</b></td>
	<td><tt>adres przypisany symbolowi w bloku relokowalnym .RELOC. Ta warto¶æ zostaje poddana relokacji poprzez dodanie do niej aktualnego adresu asemblacji.</td>
</tr>
<tr>
	<td><tt><b>PROC_CPU_REG</b></td>
	<td><tt>informacja o kolejno¶ci u¿ycia rejestrów CPU dla procedury typu .REG</td>
</tr>
<tr>
	<td><tt><b>PROC_TYPE</b></td>
	<td><tt>typ procedury:<br />
<li>D-EFAULT domy¶lny typ wykorzystuj±cy do przekazywania parametrów stos programowy MADS-a
<br />
<li>R-EGISTRY parametry do procedury przekazywane s± przez rejestry CPU (.REG)
<br />
<li>V-ARIABLE parametry do procedury przekazywane s± przez zmienne (.VAR)</td>
</tr>
<tr>
	<td><tt><b>PARAM_COUNT</b></td>
	<td><tt>informacja o liczbie parametrów procedury (.REG) lub ca³kowitej d³ugo¶ci danych zawieraj±cych informacjê o typie parametrów i ich nazwach (.VAR) </td>
</tr>
<tr>
	<td><tt><b>PARAM_TYPE</b></td>
	<td><tt>typ parametrów zapisany za pomoc± znaków 'B', 'W', 'L', 'D'</td>
</tr>
<tr>
	<td><tt><b>PARAM_LENGTH</b></td>
	<td><tt>d³ugo¶æ nazwy parametru (.VAR)</td>
</tr>
<tr>
	<td><tt><b>PARAM_NAME</b></td>
	<td><tt>nazwa parametru w kodach ATASCII (.VAR)</td>
</tr>
</table>

<p></p>
<br />



<A NAME="_longa">
<u><tt><h2>.LONGA, .LONGI</h2></tt></u>

<span style="color: #0000FF">
<pre>
 .LONGA ON|OFF
 .LONGI ON|OFF
</pre>
</span>

<p>
Dyrektywa .LONGA informuje assembler o rozmiarze rejestru akumulatora, 16bit gdy ON, 8bit gdy OFF.
</p>

<p>
Dyrektywa .LONGI informuje assembler o rozmiarze rejestrów indeksowych XY, 16bit gdy ON, 8bit gdy OFF.
</p>

Dyrektywy wp³ywaj± na rozmiar argumentu przy adresowaniu absolutnym CPU 65816.

<p></p>
<br />



<A NAME="_link">
<u><tt><h2>Linkowanie .LINK</h2></tt></u>

<span style="color: #0000FF">
<pre>
 .LINK 'filename'
</pre>
</span>

Dyrektywa .LINK wymaga podania jako parametru nazwy pliku do relokacji. Akceptowane s± tylko pliki DOS Atari, pliki SDX nie s± akceptowane. 

<p>
Je¶li adres ³adowania pliku jest inny ni¿ <b>$0000</b> oznacza to ¿e plik nie zawiera kodu relokowalnego, jednak mo¿e zawieraæ bloki aktualizacji dla symboli zewnêtrznych i publicznych. Dyrektywa .LINK akceptuje pliki o dowolnym adresie ³adowania, jednak relokacji poddawane s± tylko te o adresie ³adowania <b>$0000</b>, wiêcej szczegó³ów na temat budowy takiego pliku zosta³o zawartych w rozdziale <A HREF="#_reloc">Blok relokowalny .RELOC</A>. 
</p>

<p>
Dyrektywa .LINK pozwala na ³±czenie kodu relokowalnego z nierelokowalnym. MADS na podstawie bloków aktualizacji dokonuje automatycznej relokacji takiego pliku. Uwzglêdniane s± wszystkie 3 rodzaje bloków aktualizacji (ADDRESS, EXTERNAL, PUBLIC). 
</p>

Nie ma ograniczeñ co do adresu pod którym umieszczany jest plik relokowalny.

<p>
Je¶li blok relokowalny do dzia³ania wymaga stosu programowego MADS-a wówczas etykiety @STACK_POINTER, @STACK_ADDRESS, @PROC_VARS_ADR zostan± automatycznie zaktualizowane na podstawie nag³ówka bloku .RELOC. Wymagane jest aby bloki .RELOC i program g³ówny operowa³y na tym samym stosie programowym je¶li jest on konieczny.
</p>

<br />




<A NAME="mnemo">
<p class="duzy">
MNEMONIKI
</p>


<A NAME="8bit">
<u><tt><h2>Dostêpne rozkazy 6502</h2></tt></u>

<span style="color: #0000FF">
<pre>
   LDA   LDX   LDY   STA   STX   STY   ADC   AND  
   ASL   SBC   JSR   JMP   LSR   ORA   CMP   CPY  
   CPX   DEC   INC   EOR   ROL   ROR   BRK   CLC  
   CLI   CLV   CLD   PHP   PLP   PHA   PLA   RTI  
   RTS   SEC   SEI   SED   INY   INX   DEY   DEX  
   TXA   TYA   TXS   TAY   TAX   TSX   NOP   BPL  
   BMI   BNE   BCC   BCS   BEQ   BVC   BVS   BIT  
</pre>
</span>

Mo¿liwe jest u¿ycie rozszerzenia mnemonika po znaku kropki <tt>'.'</tt> dla rozkazów typu LDA, LDX, LDY, STA, STX, STY:
<pre>
   <b>.b</b> lub <b>.z</b>          BYTE
   <b>.a</b> lub <b>.w</b> lub <b>.q</b>   WORD

np.
   lda.w $80   ; AD 80 00
   lda   $80   ; A5 80     
</pre>
<br />


<A NAME="8bit_ill">
<u><tt><h2>Dostêpne nielegalne rozkazy 6502</h2></tt></u>

<span style="color: #0000FF">
<pre>
   ASO   RLN   LSE   RRD   SAX   LAX   DCP   ISB
   ANC   ALR   ARR   ANE   ANX   SBX   LAS   SHA
   SHS   SHX   SHY   NPO   CIM
</pre>
</span>
<br />



<A NAME="16bit">
<p>
<u><tt><h2>Dostêpne rozkazy 65816</h2></tt></u>
</p>

Oczywi¶cie dostêpne s± rozkazy <tt>6502</tt>, a oprócz nich:

<span style="color: #0000FF">
<pre>
   STZ   SEP   REP   TRB   TSB   BRA   COP   MVN  
   MVP   PEA   PHB   PHD   PHK   PHX   PHY   PLB  
   PLD   PLX   PLY   RTL   STP   TCD   TCS   TDC  
   TSC   TXY   TYX   WAI   WDM   XBA   XCE   INA
   DEA   BRL   JSL   JML
</pre>
</span>

Mo¿liwe jest u¿ycie rozszerzenia mnemonika w stylu XASM a:, z:, r: ,np.:
<pre>
 XASM        MADS
 lda a:0     lda.a 0
 ldx z:0     lda.z 0

 org r:$40   org $40,*
</pre>


Mo¿liwe jest u¿ycie rozszerzenia mnemonika po znaku kropki <tt>'.'</tt> dla rozkazów typu LDA, LDX, LDY, STA, STX, STY:
<pre>
   <b>.b</b> lub <b>.z</b>          BYTE
   <b>.a</b> lub <b>.w</b> lub <b>.q</b>   WORD
   <b>.t</b> lub <b>.l</b>          TRIPLE, LONG (24bit)

np.
   lda.w #$00   ; A9 00 00
   lda   #$80   ; A9 80
</pre>

<p>
Wyj±tki stanowi± rozkazy n/w, którym nie mo¿na zmieniæ rozmiaru rejestru w adresowaniu absolutnym (niektóre assemblery nie wymagaj± dla tych rozkazów podania znaku <tt>'#'</tt>, jednak <tt>MADS</tt> wymaga tego)
</p>

<tt><h3>#$xx</h3></tt>
<pre>
   SEP   REP   COP
</pre>

<tt><h3>#$xxxx</h3></tt>
<pre>
   PEA
</pre>

<p>
Innym wyj±tkiem jest tryb adresowania po¶redni d³ugi, który reprezentowany jest przez nawiasy kwadratowe <tt>[ ]</tt>. Jak wiemy tego typu nawiasy wykorzystywane s± te¿ do obliczania wyra¿eñ, jednak je¶li asembler napotka pierwszy znak <tt>'['</tt> uzna to za tryb adresowania po¶redni d³ugi i je¶li nie zasygnalizowali¶my chêci u¿ywania <tt>65816</tt> wyst±pi b³±d z komunikatem <b><tt>Illegal adressing mode</tt></b>. Aby "oszukaæ" assembler wystarczy daæ przed kwadratowym nawiasem otwieraj±cym <tt>'['</tt> znak <tt>'+'</tt>.
</p>

<span style="color: #0000FF">
<pre>
 lda [2+4]     ; lda [6]
 lda +[2+4]    ; lda 6
</pre>
</span>
<br />




<A NAME="det_cpu">
<p class="duzy">
DETEKCJA CPU
</p>


<u><tt><h2>Detekcja CPU6502, CPU65816</h2></tt></u>

Przyk³ad zaczerpniêty ze strony <A HREF="http://www.s-direktnet.de/homepages/k_nadj/cputest.html"> http://www.s-direktnet.de/homepages/k_nadj/cputest.html</A>. Program potrafi zdiagnozowaæ obecno¶æ jednego z mikroprocesorów: <tt>6502</tt>, <tt>65C02</tt>, <tt>65816</tt>.

<span style="color: #0000FF">
<pre>
/*

How to detect on which CPU the assembler code is running

(This information is from Draco, the author of SYSINFO 2.0)

You can test on plain 6502-Code if there is a 65c816 CPU, the 16-Bit processor avaible
in some XLs as a turbo-board, avaible. Draco told me how to do this:

First we make sure, whether we are running on NMOS-CPU (6502) or CMOS (65c02,65c816).
I will just show the "official" way which doesn`t uses "illegal opcodes":

*/

 org $2000

 opt c+

DetectCPU

 lda #$99
 clc
 sed
 adc #$01
 cld
 beq DetectCPU_CMOS

DetectCPU_02

 ldx #<_6502
 ldy #>_6502
 jsr $c642

 lda #0
 rts

DetectCPU_CMOS

 lda #0
 rep #%00000010		;wyzerowanie bitu Z
 bne DetectCPU_C816

DetectCPU_C02

 ldx #<_65c02
 ldy #>_65c02
 jsr $c642

 lda #1
 rts

DetectCPU_C816

 ldx <_65816
 ldy >_65816
 jsr $c642

 lda #$80
 rts

_6502   dta c'6502',$9b
_65c02  dta c'65c02',$9b
_65816  dta c'65816',$9b
</pre>
</span>

<br />

Nastêpny przyk³ad detekcji CPU, ogranicza siê do okre¶lenia obecno¶ci mikroprocesora <tt>6502</tt> lub <tt>65816</tt>. Program po disasemblacji inaczej wygl±da dla <tt>6502</tt>, inaczej dla <tt>65816</tt>. <tt>6502</tt> rozkaz <tt>'inc @'</tt> uzna za <tt>'nop'</tt>, rozkaz <tt>'xba'</tt> uzna za <tt>'sbc #'</tt>. Dziêki takiej "prze¼roczysto¶ci" mo¿emy byæ pewni ¿e program nie wykona ¿adnej nielegalnej operacji i uczciwie rozpozna w³a¶ciwy CPU. Pomys³odawc± tego zwiêz³ego i jak¿e sprytnego testu jest Ullrich von Bassewitz.

<span style="color: #0000FF">
<pre>
 org $2000

 opt c+                 ; 65816 enabled

 lda #0
 
 inc @                  ; increment accumulator
 
 cmp #1
 bcc cpu6502

; ostateczny test na obecnosc 65816

 xba           ; put $01 in B accu
 dec @         ; A=$00 if 65C02
 xba           ; get $01 back if 65816
 inc @         ; make $01/$02
 
 cmp #2
 bne cpu6502

cpu65816

 ldx &lttext65816
 ldy &gttext65816
 jsr $c642
 rts
 
cpu6502

 ldx &lttext6502
 ldy &gttext6502
 jsr $c642
 rts

text6502  dta c'6502',$9b
text65816 dta c'65816',$9b
</pre>
</span>
<br />



<A NAME="banks">
<p class="duzy">
BANKI PAMIÊCI
</p>

Pewnie ka¿demu, kto mia³ do czynienia z architektur± ma³ego Atari, pojêcie "bank pamiêci" kojarzy siê z pamiêci± rozszerzon±, podzielon± na banki wielko¶ci 16kb, prze³±czane w obszar <tt>&lt$4000..$7FFF&gt</tt>.
<p></p>

<tt>MADS</tt> te¿ mo¿e to rozumieæ w ten sposób (opcja <b><tt>OPT B+</tt></b>, <A HREF="#banks_spr">Sprzêtowe banki pamiêci</A>), jednak domy¶lnie rozumie to w sposób bardziej wirtualny (opcja <b><tt>OPT B-</tt></b>, <A HREF="#banks_wir">Wirtualne banki pamiêci</A>).

<p></p>

Banków dotycz± n/w pseudo rozkazy:
<span style="color: #0000FF">
<pre>
 LMB #value
 NMB
 RMB
</pre>
</span>


<A NAME="_lmb">
<p></p>
<tt><h3>LMB # (Load Memory Bank)</h3></tt>
Ustawiamy licznik banków <tt>MADS-a</tt> na konkretn± warto¶æ z zakresu <tt>&lt$00..$FF&gt</tt> (BANK = value), np.
<span style="color: #0000FF">
<pre>
 lmb #0
 lmb #bank
 lmb #5 , $6500      ; tylko gdy OPT B+
</pre>
</span>

<A NAME="_nmb">
<p></p>
<tt><h3>NMB (Next Memory Bank)</h3></tt>
Zwiêkszamy o 1 licznik banków <tt>MADS-a</tt> (BANK = BANK + 1).
<span style="color: #0000FF">
<pre>
 nmb
 nmb  $6500          ; tylko gdy OPT B+
</pre>
</span>

<A NAME="_rmb">
<p></p>
<tt><h3>RMB (Reset Memory Bank)</h3></tt>
Zerujemy licznik banków <tt>MADS-a</tt> (BANK = 0).
<span style="color: #0000FF">
<pre>
 rmb
 rmb $3500           ; tylko gdy OPT B+
 rmb $8500           ; tylko gdy OPT B+
</pre>
</span>

<br />


<tt>MADS</tt> podczas asemblacji, ka¿dej nowo zdefiniowanej etykiecie przypisuje aktualn± warto¶æ licznika banków. Programista mo¿e mieæ wp³yw na warto¶æ licznika banków dziêki w/w pseudo rozkazom.

<p>
<li>Etykiety z przypisanym licznikiem banków <tt>MADS-a</tt> <b>=0</b> s± zasiêgu <tt><b>globalnego</b></tt>.
<li>Etykiety z przypisanym licznikiem banków <tt>MADS-a</tt> <b>&gt0</b> s± zasiêgu <tt><b>lokalnego</b></tt>.
</p>

<br />



<A NAME="banks_wir">
<u><tt><h2>Wirtualne banki pamiêci (OPT B-)</h2></tt></u>

<p>
W <tt>MADS</tt> przez pojêcie "wirtualny bank pamiêci" rozumiany jest ka¿dy obszar oznaczony przez nowo zdefiniowan± etykietê z przypisan± aktualn± warto¶ci± licznika banków (domy¶lnie licznik banków jest wyzerowany). Czyli wirtualny bank pamiêci to nie koniecznie obszar pamiêci <tt>&lt$4000..$7FFF&gt</tt>, ale ka¿da etykieta reprezentuj±ca jaki¶ obszar kodu programu, której przypisany zosta³ kod (warto¶æ licznika banków) z zakresu <b><tt>&lt$00..$FF&gt</tt></b> przy pomocy odpowiednich pseudo rozkazów oddanych na u¿ytek programisty (<tt>NMB, RMB, LMB</tt>).
</p>

<p>
Wyj±tek stanowi± bloki .RELOC w których nie mo¿na samodzielnie zmieniaæ licznika banków, realizuje to automatycznie MADS, który zwiêksza licznik za ka¿dym wywo³aniem dyrektywy .RELOC. Licznik banków w takim przypadku przyjmuje warto¶ci z zakresu <b>&lt$0001..$FFF7&gt</b>.
</p>

Programista mo¿e odczytaæ warto¶æ licznika banków, który zosta³ przypisany etykiecie za pomoc± operatora <tt>'='</tt> np.:
<span style="color: #0000FF">
<pre>
label

 ldx #=label
</pre>
</span>

W w/w przyk³adzie do rejestru <tt><b>regX</b> CPU</tt> zapisali¶my warto¶æ licznika banków pamiêci <tt>MADS-a</tt> przypisany etykiecie <tt>LABEL</tt>.

<p></p>

Innym przydatnym operatorem mo¿e byæ znak dwukropka <tt>':'</tt> umieszczony na pocz±tku nazwy etykiety. Spowoduje to ¿e <tt>MADS</tt> odczyta warto¶æ takiej etykiety pomijaj±c ograniczenia zasiêgu, które wprowadza licznik banków <tt>MADS-a</tt>. Niekiedy mo¿e spowodowaæ to komplikacje, np. je¶li wyst±pi³o wiêcej etykiet o tej samej nazwie ale w ró¿nych obszarach lokalnych albo w obszarach o ró¿nych warto¶ciach licznika wirtualnych banków.

<span style="color: #0000FF">
<pre>
 lmb #5

label5
 nop

 lmb #6

label6
 nop

 lda :label5
</pre>
</span>

Dla w/w przyk³adu brak operatora <tt>':'</tt> na pocz±tku nazwy etykiety w rozkazie <tt>'lda :label5'</tt> skoñczy siê komunikatem b³êdu <tt><b>ERROR: Undeclared label LABEL5 (BANK=6)</b></tt>.

<p></p>
Wirtualnych banków pamiêci mo¿na u¿yc do indeksowania tablicy zawieraj±cej warto¶ci dla <tt>PORTB</tt>. Takie te¿ jest ich zastosowanie w przypadku wybrania opcji <b><tt>OPT B+</tt></b>.
<p></p>
<br />



<A NAME="banks_spr">
<u><tt><h2>Sprzêtowe banki pamiêci (OPT B+)</h2></tt></u>

Ten tryb dzia³ania <tt>MADS-a</tt> mo¿na okre¶liæ jako "czu³y na banki" (<tt>BANK SENSITIVE</tt>).

<p></p>

Sprzêtowe banki pamiêci s± rozszerzeniem wirtualnych banków. Rozumiane s± przez <tt>MADS</tt> jako banki rozszerzonej pamiêci, w³±czane w obszar <tt>&lt$4000..$7FFF&gt</tt>. Dzia³anie pseudo rozkazów <tt>NMB, RMB, LMB</tt> zostaje rozszerzone o wywo³anie makra <tt>@BANK_ADD</tt>, które mo¿na znale¼æ w katalogu <tt>..\EXAMPLES\MACROS\</tt>.

<p></p>
W tym trybie dzia³ania <tt>MADS</tt> potrzebuje deklaracji konkretnych makr:
<span style="color: #0000FF">
<pre>
 @BANK_ADD
 @BANK_JMP
</pre>
</span>

oraz potrzebuje definicji etykiet o nazwach:

<span style="color: #0000FF">
<pre>
@TAB_MEM_BANKS
@PROC_ADD_BANK
</pre>
</span>

Etykieta <tt><b>@TAB_MEM_BANKS</b></tt> definiuje adres tablicy, z której warto¶ci bêd± przepisywane do rejestru <tt>PORTB</tt> odpowiedzialnego za prze³±czanie banków rozszerzonej pamiêci. Mo¿emy sobie u³atwiæ sprawê i skorzystaæ z gotowej procedury wykrywaj±cej banki rozszerzonej pamiêci do³±czonej do <tt>MADS-a</tt>, plik <tt>..\EXAMPLES\PROCEDURES\@MEM_DETECT.ASM</tt>.

<p></p>
Etykieta <tt><b>@PROC_ADD_BANK</b></tt> u¿ywana jest przez makro <tt>@BANK_ADD</tt> i definiuje adres pod jakim znajdzie siê kod programu prze³±czaj±cy bank pamiêci rozszerzonej.

<p></p>

Programista mo¿e odczytaæ warto¶æ licznika banków, który zosta³ przypisany etykiecie za pomoc± operatora <tt>'='</tt>, np.:
<span style="color: #0000FF">
<pre>
label

 ldy #=label
</pre>
</span>

W w/w przyk³adzie do rejestru <tt>regY</tt> zapisali¶my warto¶æ licznika banków pamiêci <tt>MADS-a</tt> przypisany etykiecie <tt>LABEL</tt>.


<p></p>
<u>Je¶li licznik banków <tt>MADS-a</tt> = 0 to:</u>
<li>kod programu musi znajdowaæ siê poza obszarem <b>&lt$4000..$7FFF&gt</b>
<li>nowo zdefiniowane etykiety w tym obszarze s± globalne
<li>mo¿na odwo³ywaæ siê do wszystkich zdefiniowanych etykiet bez ograniczeñ, bez wzglêdu na numer banku
<li>skok w obszar banku mo¿liwy przy u¿yciu makra <b>@BANK_JMP</b> (..\EXAMPLES\MACROS\@BANK_JMP.MAC), parametr dla tego makra nie musi byæ poprzedzony operatorem ':'


<p></p>
<u>Je¶li licznik banków <tt>MADS-a</tt> &gt 0 to:</u>
<li>kod programu musi znajdowaæ siê w obszarze <b>&lt$4000..$7FFF&gt</b>
<li>nowo zdefiniowane etykiety w tym obszarze s± lokalne
<li>mo¿na odwo³ywaæ siê tylko do etykiet globalnych i tych zdefiniowanych w obszarze aktualnego banku
<li>pseudo rozkaz LMB, NMB powoduje wykonanie makra <b>@BANK_ADD</b>, które w³±cza nowy bank rozszerzonej pamiêci na podstawie licznika banków MADS-a oraz ustawia nowy adres asemblacji (domy¶lnie na <b>$4000</b>)
<li>pseudo rozkaz RMB powoduje wyzerowanie licznika banków pamiêci MADS-a oraz ustawienie nowego adresu asemblacji poza bankiem (domy¶lnie na <b>$8000</b>)
<li>skok w obszar innego banku mo¿liwy przy u¿yciu makra <b>@BANK_JMP</b> (..\EXAMPLES\MACROS\@BANK_JMP), parametr dla tego makra musi byæ poprzedzony operatorem ':'

<p>
Przyk³adem wykorzystania tego trybu pracy <tt>MADS-a</tt> jest plik <tt>..\EXAMPLES\XMS_BANKS.ASM</tt>. W tym przyk³adzie kod programu znajduje siê w dwóch ró¿nych bankach rozszerzonej pamiêci i wykonuje siê jakby by³ jedn± ca³o¶ci±.
</p>

<p></p>
<br />


</div>

</tt>


<A NAME="zmiany">
</tt><h2>HISTORIA</h2></tt>

<p class="tekst-wiekszy">
v2.1.0
<p class="tekst">
- dodany komunikat ostrze¿enia 'Buggy indirect jump' w przypadku u¿ycia rozkazu JMP(ABS)<br>
- dodana dyrektywa .FILEEXISTS('filename') zwracajaca 1 gdy plik w podanej ¶cie¿ce istnije, 0 gdy nie istnieje<br>
- rozszerzony komunikat  'Value out of range (VALUE must be between X and Y)'<br>


<p class="tekst-wiekszy">
v2.0.9
<p class="tekst">
- .cbm 'text' konwersja na znaki ekranowe Commodore C64<br>
- usuniêty b³±d kiedy procedura .PROC znajduj±ca siê w bloku .LOCAL nie zosta³a oznaczona jako "do asemblacji" mimo tego ¿e by³o do niej odwo³anie z poziomu makra .MACRO w bloku .LOCAL<br>
- usuniêty b³±d, etykiety tymczasowe ?label by³y oznaczane "do relokacji"<br>


<p class="tekst-wiekszy">
v2.0.8
<p class="tekst">
- krótszy kod dla #CYCLE<br>
- poprawki dla .BY, .WO, .HE, .SB, .CB, .FL<br>
- komunikat b³êdu 'Improper syntax' w przypadku u¿ycia .BY, .WO, .HE, .SB, .CB, .FL w bloku .STRUCT<br>
- dodane nowe dyrektywy dla 65816 .LONGA ON|OFF, .LONGI ON|OFF<br>
- poprawione dzia³anie ¶ledzenia rozmiaru rejestrów 65816 gdy 'OPT T+'<br>
- dodany prze³±cznik -FV:VALUE pozwalaj±cy ustaliæ warto¶æ wype³nienia pamiêci gdy 'OPT F+'<br>
- dodana mo¿liwo¶æ podania argumentu jako ci±gu dwóch znaków (poprzednio tylko 1 znak) np. lda #'AB' , mwa #'XY' $80<br>


<p class="tekst-wiekszy">
v2.0.7
<p class="tekst">
- poprawione generowanie kodu wynikowego dla nielegali DOP, SHA<br>
- dodane nowe dyrektywy (65816) .A8, .A16, .I8, .I16, .AI8, .IA8, .AI16, .IA16 pozwalaj±ce ustawiæ rozmiar rejestrów AXY<br>
- dodane nowe dyrektywy (65816) .ASIZE, .ISIZE zwracaj±ce aktualnie ustawiony rozmiar rejestrów AXY<br>
- rozkaz JMP zmieniany jest na JML (65816) tylko gdy skok dotyczy innego 64KB banku ni¿ obecny<br>
- dodany nowy prze³±cznik '-ml:value' (margin-left property), który umo¿liwia zmianê lewego marginesu generowanego listingu w zakresie od 32 do 128 znaków<br>


<p class="tekst-wiekszy">
v2.0.6
<p class="tekst">
- poprawione parsowanie parametrów makra zapisanych przy pomocy etykiet
<pre>
    .macro test currentRow, previousRow
        .print Tmp%%currentRowAllowed
        .print Tmp%%previousRowAllowed
    .endm
</pre>
<p class="tekst">
- poprawione alokowanie danych .ARRAY gdy nie ma okre¶lonego rozmiaru, lub jest to tablica inna ni¿ jednowymiarowa<br>
- zwiêkszona liczba przebiegów dla .PROC, w pewnych warunkach dla parametru "xa .reg" parametr by³ ¼le interpretowany<br>
- nowa dyrektywa .DEFINE pozwalaj±ca definiowaæ jedno liniowe makra (mo¿na definiowaæ wielokrotnie w tym samym przebiegu)
<pre>
  .DEFINE MACRO_NAME expression

  .DEFINE pisz .print %%1+%%2

  pisz (5,12)

  .define text .sb

  text 'atari'
</pre>
<p class="tekst">
- nowa dyrektywa .UNDEF MACRO_NAME, usuwa definicjê jedno liniowego makra MACRO_NAME<br>


<p class="tekst-wiekszy">
v2.0.5
<p class="tekst">
- tablice .ARRAY w bloku .PROC s± pomijane je¶li u¿yto prze³±cznik -X (exclude unreferenced procedure)<br>
- u¿ycie .ARRAY w bloku .STRUCT nie bêdzie generowaæ ju¿ zer w pliku wynikowym<br>
- nowa dyrektywa .XGET, pozwalaj±ca wczytaæ do bufora pamiêci MADS-a plik i dodatkowo zmodyfikowaæ jego bajty pod warunkiem ¿e s± ró¿ne od zera (przydatne dla VBXE)<br>


<p class="tekst-wiekszy">
v2.0.4
<p class="tekst">
- usuniêty b³±d powoduj±cy b³êdny zapis bloku aktualizacji dla starszego bajtu adresu w bloku .RELOC<br>
- .DB i .DW usuniête<br>
- .DBYTE (MSB/LSB) odk³ada s³owo w odwrotnej kolejno¶ci (starszy/m³odszy)<br>
- dodane dyrektywy .WGET (WORD), .LGET (LONG), .DGET (DWORD)<br>
- poprawione dzia³anie makro rozkazków ADW, SBW, np.:
<pre>
	adw (tmp),y #1 posx
	adw (tmp),y ptr2 ptr4
</pre>

<p class="tekst-wiekszy">
v2.0.2
<p class="tekst">
- poprawione alokowanie danych dla .SB [+&ltbyte&gt],&ltbytes|string|char&gt <br>


<p class="tekst-wiekszy">
v2.0.1
<p class="tekst">
- poprawione alokowanie danych dla .ARRAY gdy typ wiêkszy od .BYTE<br>
- .SIZEOF zwraca rozmiar dla wbudowanych typów .BYTE, .WORD, .LONG, .DWORD<br>
- dodana relokowalna wersja playera MPT examples\players\mpt_player_reloc.asm<br>
- poprawione dzia³anie dyrektywy .DS w blokach SDX (blk sparta $xxx) które nie s± relokowalne<br>


<p class="tekst-wiekszy">
v1.9.8
<p class="tekst">
- naprawione dzia³anie rozkazów 65816 PEA, PEI, PER<br>
- dodana mo¿liwo¶æ podania kodu dla .RELOC [.BYTE|WORD] [TYPE]<br>


<p class="tekst-wiekszy">
v1.9.7
<p class="tekst">
- dyrektywa .DEF definiuje etykiety o zasiegu lokalnym, je¶li poprzedziæ j± znakiem ':' to globalne<br>
- poprawki dla liczb zmiennoprzecinkowych .FL, poprawione kodowane zera, dokonywane zaokr±glenie do 10 miejsc po przecinku<br>
- dla bloków Sparta DOS X 'blk reloc' i 'blk empty' dodana mo¿liwo¶æ okre¶lenia innego typu pamiêci ni¿ $00 (main), $02 (extended), np.:
<pre>
  blk reloc $40
</pre>
<p class="tekst">
- poprawka umo¿liwiaj±ca u¿ycie dyrektywy .PRINT po 'blk empty'<br>
- dodana mo¿liwo¶æ definiowania wielowymiarowych tablic .ARRAY, np.:
<pre>
.array scr [24][40]
  [11][16] = "atari"
.enda

  mva #"!" scr[11][22]
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ definiowania tablicy .ARRAY poprzez dyrektywê .DS, np.:
<pre>
tmp .ds .array [5][12][4] .word
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ definiowania tablicy .ARRAY poprzez pseudorozkaz EQU (=), np.:
<pre>
fnt = $e000 .array [128] [8] .byte
</pre>
<p class="tekst">
- naprawione dzia³anie makrorozkazu ADW w po³±czeniu z makrorozkazem SCC itp.<br>
- poprawki dla .REPT, m.in. komentarz wieloliniowy /* */ jest teraz w³a¶ciwie rozpoznawany<br>



<p class="tekst-wiekszy">
v1.9.6
<p class="tekst">
- poprawione dzia³anie etykiet anonimowych dla mnemoników ³±czonych znakiem ':', np.:
<pre>
       ldx #8
@      lda:cmp:req 20
       dex
       bne @-
</pre>
<p class="tekst">
- dodany pseudo rozkaz COS(centre,amp,size[,first,last]) generuj±cy warto¶ci dla funkcji cosinus<br>
- dodany komunikat b³êdu 'Improper syntax' w przypadku u¿ycia dyrektywy .DS w bloku .STRUCT<br>
- naprawione dzia³anie pseudo rozkazu ORG, np.:
<pre>
	opt h-
	ORG [a($ffff),d'atari',c'ble',20,30,40],$8000,$a000
</pre>
<p class="tekst">
- addytywne bloki .LOCAL otrzymuj± kolejne adresy, poprzednio adres ustalany by³ na podstawie pierwszego wyst±pienia takiego bloku<br>
- dodany komunikat ostrze¿enia w przypadku stworzenia kolejnego addytywnego bloku .LOCAL o tej samej nazwie "Ambiguous label LOCAL_NAME"<br>
- dodane mnemoniki PER (PEA rell), PEI (PEA (zp)) dla 65816<br>
- dodane nowy typ danych M (najstarszy bajt LONG) i G (najstarszy bajt DWORD) dla pseudorozkazu DTA, np.:
<pre>
 dta m($44556677)   ; -> $55
 dta g($44556677)   ; -> $44
</pre>
<p class="tekst">
- dyrektywa .LEN (.SIZEOF) rozszerzona o obs³ugê danych alokowanych poprzez DTA STRUCT_NAME, np.:
<pre>
.STRUCT free_ptr_struct
  prev .WORD
  next .word
.ENDS

free_ptr_t dta free_ptr_struct [3]

	.print .sizeof(free_ptr_t)    ; free_ptr_struct [0..3] = 16 bytes
</pre>
<p class="tekst">
- zmiany dla operacji odczytu plików poprzez ICL, INS itp. plik do odczytu/zapisu bêdzie poszukiwany najpierw w ¶cie¿ce, która prowadzi do obecnie otwartego pliku, nastêpnie ze ¶cie¿ki z której zosta³ uruchomiony g³ówny asemblowany plik i na koñcu ze ¶cie¿ek podanych parametrem -i (additional include directories)<br>
- poprawione rozpoznawanie wielko¶ci znaków gdy aktywowany jest prze³±cznik -c (char sensitive) dla struktur, np.:
<pre>
.struct fcb
sEcbuf  .byte
.ends

data dta fcb [1] (0)

        lda     data[0].sEcbuf
</pre>
<p class="tekst">
- rozszerzone dzia³anie dyrektywy .REPT o mo¿liwo¶æ jej zagnie¿d¿ania np.:
<pre>
 .rept 2,#*2              ;  1 - $0000
                          ;  2 - $0000
 .print '1 - ',#          ;  1 - $0001
                          ;  2 - $0000
 .rept :1                 ;  2 - $0001
 .print '2 - ',.r         ;  2 - $0002
 .endr                    ;
                          ;
 .endr                    ;
</pre>
<p class="tekst">
- krótsza wersja pêtli #WHILE bez wyra¿enia, pêtla trwa dopóki LABEL <> 0
<pre>
#while .word label
#end
</pre>


<p class="tekst-wiekszy">
v1.9.5
<p class="tekst">
- dodany pseudorozkaz SET pozwalaj±cy redefiniowaæ etykietê, podobne dzia³anie jak etykiety tymczasowe zaczynaj±ce siê znakiem '?', np.:
<pre>
temp set 12

     lda #temp

temp set 23

     lda #temp
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ wymuszenia trybu adresowania w stylu XASM ('a:', 'z:'), np.:
<pre>
 XASM        MADS
 lda a:0     lda.a 0
 ldx z:0     lda.z 0
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ okre¶lenia nowego adresu relokacji kodu w stylu XASM ('r:'), np.:
<pre>
 XASM        MADS
 org r:$40   org $40,*
</pre>
<p class="tekst">
- poprawione dzia³anie parametru '-x Exclude unreferenced procedures', zmienne .VAR nie s± alokowane gdy procedura jest nieu¿ywana<br>
- rozszerzona sk³adnia dla jednoliniowych pêtli :rept, mo¿liwe wykorzystanie licznika pêtli jako parametru :1 (%%1), np.:
<pre>
line0
line1
line2
line3

ladr :4 dta l(line:1)
hadr :4 dta h(line:1)
</pre>
<p class="tekst">
- dodany komunikat ostrze¿enia w przypadku u¿ycia nielegalnych niestabilnych rozkazów CPU6502, np. CIM<br>
- dodana nowa funkcjonalno¶æ dla pseudorozkazów RUN, INI, które teraz zachowuj± adres asemblacji, poprzednio przestawia³y adres asemblacji na $2E0 (RUN), $2E2 (INI)<br>
- dodana obs³uga etykiet anonimowych (anonymous labels) @, @+[1..9] (forward), @-[1..9] (backward), w celu zapewnienia przejrzysto¶ci kodu ograniczone jest u¿ywania takich etykiet tylko dla skoków warunkowych oraz do 10 wyst±pieñ w przód/ty³, np.:
<pre>
@ dex   ---- -------
  bne @+   |  --   |
  stx $80  |   |   |
@ lda #0   |  --   |
  bne @- ---       |
  bne @-1  ---------
</pre>
<p class="tekst">
- rozszerzone dzia³anie dyrektyw #IF, #WHILE o zmienne deklarowane przez .VAR, dotychczas wymagane by³o podanie typu zmiennej, np.:
<pre>
 .var temp .word

 #if temp>#2100
 #end

 #if .word temp>#2100
 #end
</pre>


<p class="tekst-wiekszy">
v1.9.4
<p class="tekst">
- dodana normalizacja ¶cie¿ek dla plików, tak aby dzia³a³y pod Unixami, znaki '\' zamieniane s± na '/'<br>
- poprawione przekazywanie dyrektyw jako parametrów do procedur i makr, dyrektywy nie by³y rozpoznawane przy w³±czonym prze³±czniku -c (case sensitive)<br>
- poprawione dzia³anie .USE [.USING]<br>
- dodana informacja w postaci ostrze¿enia (WARNING) o etykiecie powoduj±cej nieskoñczon± ilo¶æ przebiegów asemblacji (INFINITE LOOP)<br>
- dodany zapis dwóch bajtów nag³ówka FF FF dla pliku zawieraj±cego blok o adresie ³adowania $FFFF<br>
- komentarze po mnemonikach nie wymagaj±cych argumentu zostan± potraktowane jako b³±d, wyj±tkiem jest ³±czenie rozkazów w stylu xasm poprzez znak ':', np.:
<pre>
 pla $00          ->  ERROR: Extra characters on line
 pha:pla $00      ->  OK
</pre>
<p class="tekst">
- rozszerzona sk³adnia makr o mo¿liwo¶æ u¿ywania parametrów w postaci nazw a nie tylko warto¶ci numerycznych-decymalnych, np.:
<pre>
.macro SetColor val,reg
 lda :val
 sta :reg
.endm

.macro SetColor2 (arg1, arg2)
 lda #:arg1
 sta :arg2
.endm
</pre>
<p class="tekst">
- naprawione definiowanie etykiet dla n/w sytuacji, pierwsza etykieta nie zostanie zignorowana
<pre>
temp  label = 100
</pre>


<p class="tekst-wiekszy">
v1.9.3
<p class="tekst">
- poprawione przetwarzanie bloków .PROC, które w pewnych okoliczno¶ciach mog³y zostaæ pominiête podczas asemblacji<br>
- poprawiony zapis BLK EMPTY dla plików SDX je¶li zastosowali¶my deklaracjê takiego bloku przez .DS<br>
- poprawki dotycz±ce testowania koñca linii<br>
- dodane dyrektywy .FILESIZE, .SIZEOF jako odpowiednik dotychczasowej dyrektywy .LEN<br>
- rozszerzona sk³adnia dla pól struktury .STRUCT, np.:
<pre>
.struct name
 .byte label0
 .byte :5 label1
 label2 .byte
 label3 :2 .word
.ends
</pre>


<p class="tekst-wiekszy">
v1.9.2
<p class="tekst">
- mo¿liwo¶æ okre¶lenia adresu dla .ZPVAR = $XX<br>
- usprawnione odwo³ania do etykiet wyliczeniowych .ENUM, np. enum_label(field0, field1)<br>
- dodana mo¿liwo¶æ generowania bloku dla symboli zewnêtrznych BLK UPDATE EXTRN dla plików DOS-a, poprzednio tylko dla plików .RELOC, np.:
<pre>
  .extrn vbase .word
  org $2000
  lda #$80
  sta vbase+$5d

  blk update extrn
</pre>
<p class="tekst">
- dodany komunikat b³êdu "Could not use NAME in this context" w przypadku rozkazów odwo³añ do bloków .MACRO, .ENUM, .STRUCT<br>
- poprawiony b³±d który uniemo¿liwia³ u¿ycie 'EQU' w nazwie etykiety<br>
- dodana dyrektywa .CB +byte,....., ostatni bajt ci±gu znakowego zapisywany jest w inwersie<br>
- dodana obs³uga segmentów poprzez dyrektywy .SEGDEF, .SEGMENT, .ENDSEG<br>
- dodana nowa dyrektywa #CYCLE #N generuj±ca kod 6502 o zadanej liczbie cykli N<br>
- dodana obs³uga nielegalnych rozkazów CPU 6502, przyk³ad w pliku ..\examples\test6502_illegal.asm<br>
- uaktualnione pliki konfiguracyjne dla Notepad++ '..\syntax\Notepad++'<br>
- poprawiony zapis pliku LST<br>
- naprawiona alokacja pamiêci dla zmiennych strukturalnych, rozszerzona sk³adnia dla .STRUCT
<pre>
.struct LABEL
 x,y,z .word     // wiele zmiennych tego samego typu w jednej linii
 .byte a,b
.ends

.enum type
  a=1,b=2
.ende

.struct label2
  x type
  type y
.ends
</pre>


<p class="tekst-wiekszy">
v1.9.0
<p class="tekst">
- naprawiony zapis linii z komentarzem  /* */ do pliku listingu *.LST, poprzednio takie linie nie by³y zapisywane<br>
- poprawka dla etykiet deklarowanych z linii komend -d:label, poprzednio takie etykiety widziane by³y tylko w pierwszym przebiegu<br>
- w przypadku addytywno¶ci bloków .LOCAL tylko pierwszy adres z takich bloków jest zapisywany<br>
- poprawki dotycz±ce parsowania makr, poprzednio etykiety zaczynaj±ce siê od END mog³y zostaæ zinterpretowane jako pseudo rozkaz END<br>
- poprawka odczytu dla pustego pliku relokowalnego, poprzednio wystêpowa³ b³±d 'Value out of range'<br>
- poprawki dla .USING (.USE)


<p class="tekst-wiekszy">
v1.8.8 - 1.8.9
<p class="tekst">
- uaktualniony silnik duchów programowych ..\EXAMPLES\SPRITES\CHARS o duchy 8x24<br>
- w przypadku braku podania rozszerzenia pliku i braku istnienia takiego pliku dla ICL 'filename' zostanie domy¶lnie przyjête rozszerzenie *.ASM ICL 'filename.asm'<br>
- poprawione dzia³anie komentarzy /* */ w blokach .MACRO i .REPT<br>
- usuniêty b³±d uniemo¿liwiaj±cy poprawn± asemblacjê bloku #IF, #WHILE dla wyra¿eñ ³±czonych przez .OR, .AND<br>
- prze³±czniki w linii komend mog± byæ poprzedzone tylko znakiem '-', poprzednio tak¿e '/' jednak by³y problemy z dzia³aniem tego znaku na MacOSX<br>
- poprawiony zakres dzia³ania dyrektywy .USING, dla aktualnej przestrzeni nazw i kolejnych zawieraj±cych siê w tej przestrzeni nazw

<p class="tekst-wiekszy">
v1.8.6 - 1.8.7
<p class="tekst">
- usprawnione rozpoznawanie komentarzy /* */ w wyra¿eniach<br>
- domy¶lny adres dla .ZPVAR ustawiony na $0080, poprzednio $0000<br>
- dodana nowa dyrektywa .ELIF jako krótszy odpowiednik dyrektywy .ELSEIF<br>
- rozszerzone dzia³anie dyrektywy .LEN o mo¿liwo¶æ podania jako parametru nazwy pliku, zwracana jest wówczas d³ugo¶æ takiego pliku<br>
- usprawnione dzia³anie dyrektywy .DEF w wyra¿eniach warunku .IF (.IFDEF, .IFNDEF)

<p class="tekst-wiekszy">
v1.8.5
<p class="tekst">
- dodane makro relokuj±ce modu³y RMT ...\EXAMPLES\MSX\RMT_PLAYER_RELOCATOR\<br>
- dodany test sk³adni dla nie asemblowanych procedur .PROC gdy aktywny jest prze³±cznik -x "Exclude unreferenced procedures"<br>
- poprawione dzia³anie prze³±cznika "-d:label[=value]", podanie warto¶ci dla etykiety jest teraz opcjonalne, domy¶lnie mads przypisze warto¶æ 1<br>
- dyrektywy .DS i .ALIGN nie spowoduj± alokacji zmiennych zdefiniowanych przez .VAR<br>
- alokacja zmiennych .VAR przed nowym blokiem ORG nie nast±pi je¶li blok ORG znajduje siê w bloku .LOCAL lub .PROC<br>
- poprawione ³amanie wierszy znakiem '\' w ci±gach ograniczonych nawiasami ()<br>
- usuniêty b³±d powoduj±cy relokowanie adresu dla wyra¿enia dyrektywy .ERROR (ERT)<br>
- usuniête zauwa¿one b³êdy przy parsowaniu parametrów linii komend<br>
- usuniête zauwa¿one b³êdy dotycz±ce optymalizacji d³ugo¶ci kodu makro rozkazów MVA, MWA itp.<br>
- poprawiony kod realizuj±cy zagnie¿d¿anie bloków .PROC<br>
- poprawiony kod realizuj±cy dzia³anie pseudo rozkazów warunku IFT ELI ELS EIF<br>
- dodany komunikat "'#' is allowed only in repeated lines" dla przypadków u¿ycia licznika pêtli # (.R) poza pêtl±<br>
- usuniêty b³±d powoduj±cy b³êdne alokowanie zmiennych zadeklarowanych przez dyrektywê .VAR podczas wykonywania makra<br>
- w celu ujednolicenia sk³adni odwo³ania do etykiet typów wyliczeniowych mo¿liwe s± tylko poprzez znak kropki '.', poprzednio tak¿e przez '::'<br>
- mo¿liwe krótsze odwo³ania do typów wyliczeniowych enum_label(fields), np. :
<pre>
.enum typ
 val0 = 1
 val1 = 5
 val2 = 9
.ende

 lda #typ(val0|val2)  ; == "lda #typ.val0|typ.val2"
</pre>
<p class="tekst">
- rozszerzona sk³adnia dyrektywy .SAV, np.:
<pre>
 .sav 'filename',offset,length
 .sav 'filenema',length
 .sav [offset] 'filename',offset2,length
 .sav length
 .sav offset,length
</pre>
<p class="tekst">
- rozszerzona sk³adnia dyrektywy .ARRAY, w przypadku braku podania maksymalnego indeksu tablicy zostanie
  on obliczony na podstawie ilo¶ci wprowadzonych elementów, elementy mo¿na wprowadzaæ bez konieczno¶ci
  poprzedzenia ich indeksem [expression], np.:
<pre>
.array temp .byte
 1,4,6                  ; [0..2]   = 1,4,6
 [12] = 9,3             ; [12..13] = 9,3
 [5]:[8] = 10,16        ; [5..6]   = 10,16 ; [8..9] = 10,16
 0,0,\                  ; [14..17] = 0,0,1,1
 1,1
.enda                   ; 18 elementów, TEMP [0..17]
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ alokacji zmiennej typu strukturalnego przy pomocy dyrektyw .VAR i .ZPVAR, np.:
<pre>
.struct Point
 x .byte
 y .byte
.ends

 .var a,b,c Point
 .zpvar Point f,g,i
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ alokacji zmiennej typu wyliczeniowego przy pomocy dyrektyw .VAR i .ZPVAR, np.:
<pre>
.enum Boolean
 false = 0
 true = 1
.ende

 .var test Boolean
 .zpvar Boolean test
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ deklaracji pól struktury przy pomocy typów wyliczeniowych, np.:
<pre>
.enum EState
  DONE, DIRECTORY_SEARCH, INIT_LOADING, LOADING
.ende
 
.struct SLoader
    m_file_start .word
    m_file_length .word
 
    m_state EState
.ends
</pre>
<p class="tekst">


<p class="tekst-wiekszy">
v1.8.3 - 1.8.4
<p class="tekst">
- nowy silnik duchów programowych z minimalnymi wymaganiami pamiêci, bez dodatkowych buforów pamiêci obrazu ...EXAMPLES\SPRITES\CHARS_NG<br>
- nowa wersja pakera Huffmana (kompatybilna z Free Pascal Compiler-em, "fpc -MDelphi sqz15.pas") i dekompresora Huffmana SQZ15 ...EXAMPLES\COMPRESSION\SQUASH<br>
- poprawiony kod generowany dla rozkazów MVP, MVN, PEA, BRA (CPU 65816)<br>
- dodane nowe rozkazy BRL, JSL, JML (CPU 65816), jako odpowiedniki rozkazów d³ugich skoków BRA, JSR, JMP<br>
- blok aktualizacji etykiet zewnêtrznych (external) zosta³ rozszerzony o zapis m³odszego i starszego bajtu adresu takiej etykiety<br>
- poprawione dzia³anie dyrektywy .USE (.USING), dzia³a niezale¿nie od przestrzeni nazw w której zostanie u¿yta<br>
- usuniêty b³±d, który powodowa³ w pewnych sytuacjach pomijanie asemblacji bloku #IF, #WHILE<br>
- dodana mo¿liwo¶æ definiowania zmiennych poprzez dyrektywê .DS lub pseudo rozkaz ORG przed blokiem .RELOC<br>
- dodana dodatkowa forma sk³adni dla dyrektywy .VAR, z tym ¿e dla takiego przypadku nie ma mo¿liwo¶ci okre¶lenia adresu umiejscowienia zmiennych w pamiêci
<pre>
 .VAR .TYPE lab1 lab2 lab3 .TYPE lab4 .TYPE lab5 lab6 ...

 .var .byte a,b,c .dword i j
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ definicji pojedyñczych zmiennych typu strukturalnego w krótszy sposób ani¿eli dot±d przez DTA
<pre>
.struct @point
 x .byte
 y .byte
.ends

pointA	@point		; pointA dta @point [0] <=> pointA dta @point
pointB	@point		; pointB dta @point [0] <=> pointB dta @point

points	dta @point [100]
</pre>
<p class="tekst">
- dodana nowa dyrektywa .ZPVAR umo¿liwiaj±ca automatyczne przydzielenie miejsca zmiennym na stronie zerowej
<pre>
 .ZPVAR TYPE label1, label2 label3 = $80	; LABEL1=$80, LABEL2=LABEL1+TYPE, LABEL3=LABEL2+TYPE
 .ZPVAR label4, label5 TYPE			; LABEL4=LABEL3+TYPE, LABEL5=LABEL4+TYPE

 .print .zpvar
</pre>
<p class="tekst">
- poprawione dzia³anie dyrektywy .ERROR i pseudo rozkazu ERT, mo¿liwe jest umieszczenie dodatkowych informacji w wierszu podobnie jak dla .PRINT (.ECHO) np.:
<pre>
  ERT *>$6000 , 'BUUU przekroczyli¶my zakres pamiêci o ' , *-$6000 , ' bajtów'
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ zagnie¿d¿ania bloków procedur .PROC, ten sam kod mo¿e byæ wywo³ywany z ró¿nymi parametrami np.:
<pre>
.proc copySrc (.word src+1) .var

 .proc ToDst (.word src+1, dst+1) .var
 .endp

	ldy #0
src	lda $ffff,y
dst	sta $ffff,y
	iny
	bne src

	rts
.endp

	copySrc.ToDst #$a080 #$b000

	copySrc #$a360
</pre>
<p class="tekst">
- dodane nowe dyrektywy .ENUM i .ENDE (.EEND)
<pre>
.enum	dni_tygodnia

	poniedzialek = 1
	wtorek, sroda = 5, czwartek = 7
	piatek
	sobota
	niedziela

.ende

	ift dzien==dni_tygodnia::wtorek
	.print 'wtorek'
	eif
</pre>
<p class="tekst">
- rozszerzona funkcjonalno¶æ komentarzy wieloliniowych /* */ o mo¿liwo¶æ umieszczania ich gdziekolwiek
<pre>
 lda #12+ /* komentarz */ 23
</pre>
<p class="tekst">
- umo¿liwiona relokacja adresów definiowanych dyrektyw± .DEF
<pre>
 .reloc 
 .def label=*
 lda label
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ u¿ycia znaków { } do oznaczenia bloku (z wyj±tkiem bloków .MACRO), znak '{','}' zostaje rozpoznany na pocz±tku nowego wiersza, np.:
<pre>
#while .word ad+1<=#$bc40+39
{
ad	sta $bc40

	inw ad+1
}

.proc lab
{
	.local temp2
	{
	}

	.array tab [255] .long
	{}
}
</pre>


<p class="tekst-wiekszy">
v1.8.2
<p class="tekst">
- zniesione ograniczenie d³ugo¶ci pliku dla pseudo rozkazu INS (poprzednio d³ugo¶æ wczytywanego pliku ograniczona by³a do 65536 bajtów)<br>
- dodany komunikat b³êdu 'The referenced label ... has not previously been defined properly' w przypadku etykiet, które nie zosta³y zdefiniowane do koñca, np. tylko w pierwszym przebiegu warto¶ci± nieokre¶lon±<br>
- dodana nowa dyrektywa .ECHO jako odpowiednik dyrektywy .PRINT, dodatkowo informacje generowane przez .PRINT (.ECHO) zapisywane s± teraz tak¿e w listingu *.LST<br>
- dodana nowa dyrektywa .ALIGN pozwalaj±ca na wyrównanie do zadanego zakresu pamiêci, dodatkowo mo¿na okre¶liæ warto¶æ jak± wype³niæ pamiêæ
<pre>
  [label] .ALIGN N[,fill]
</pre>
<p class="tekst">
- dodany nowy prze³±cznik -U (Warn of unused labels)<br>


<p class="tekst-wiekszy">
1.8.1
<p class="tekst">
- rozszerzone dzia³anie znaku backslash '\', umieszczenie go na koñcu wiersza oznacza kontynuacjê aktualnego wiersza od nowego wiersza, np.:
<pre>
  macro_temp \
  _____________________________________parametr1_________________________________________________\
  _____________________________________parametr2_________________________________________________\
  _____________________________________parametr3_________________________________________________

  lda\
  #____________________________________label________________________________________\
  +__________________________________expression___________________________________
</pre>
<p class="tekst">
- zmienione testowanie niekoñcz±cego wywo³ywania siê makr po którym wyst±pi b³±d 'Infinite loop'<br>
- naprawiony zapis etykiet do pliku *.LAB, b³±d powsta³ po dodaniu addytywno¶ci obszarów LOCAL<br>
- poprawione dzia³anie pseudo rozkazu SIN (kod zapo¿yczony z XASM)<br>
- poprawione rozpoznawanie dyrektyw przy w³±czonym prze³±czniku -C (Case sensitive)<br>
- usprawniony odczyt bloków .REPT (wskazanie prawid³owej linii z b³êdem) i .MACRO<br>
- zablokowane u¿ycie .VAR w bloku .REPT<br>
- umo¿liwione zagnie¿d¿anie oraz wielokrotne uruchamianie (poprzez makra) pêtli .REPT i :repeat (poprzednio wystêpowa³ komunikat 'Use .REPT directive')<br>
- umo¿liwione przekazywanie parametrów do bloku .REPT, np.
<pre>
.REPT 10, #
label:1           ; LABEL0, LABEL1, LABEL2 ... LABEL9
.ENDR

.REPT 5, $12,$33,$44,$55,$66
 dta :1,:2,:3,:4,:5            ; $12,$33,$44,$55,$66
 dta :5,:4,:3,:2,:1            ; $66,$55,$44,$33,$12
.ENDR
</pre>


<p class="tekst-wiekszy">
1.7.9 - 1.8.0
<p class="tekst">
- poprawiony b³±d w opisie prze³±cznika -F, poprzednio 'Label at first column', prawid³owy opis to 'CPU command at first column'<br>
- przepisana od nowa obs³uga dyrektywy .DS i opcji OPT F+ (dodana mo¿liwo¶æ u¿ycia bloków RUN i INI)<br>
- przepisana od nowa obs³uga opcji OPT ?+ (etykiety lokalne w standardzie MAE)<br>
- dodana mo¿liwo¶æ upublicznienia w blokach PUBLIC tablic zadeklarowanych przez .ARRAY oraz deklaracji struktur .STRUCT<br>
- dyrektywa generuj±ca kod 6502 dla decyzji .TEST zast±piona zosta³a przez dyrektywê #IF, dyrektywa .ENDT przez #END, dodatkowo mo¿liwe jest u¿ycie dyrektywy #ELSE np.:
<pre>
 # if .byte i>#8 .and .byte i<#200
 # else
       #if .word j = #12
       #end
 # end
</pre>
<p class="tekst">
- dyrektywa generuj±ca kod 6502 dla iteracji .WHILE zast±piona zosta³a przez dyrektywê #WHILE, dyrektywa .ENDW przez #END, np.:
<pre>
 lda 20               ->       lda 20
 # while .byte @=20   ->  wait cmp 20
 # end                ->       sne
                      ->       jmp wait
</pre>
<p class="tekst">
- dyrektywy #IF i #WHILE akceptuj± dwa dodatkowe operatory '==' i '!='<br>
- dodana dyrektywa .EXITM jako odpowiednik .EXIT<br>
- dodana dyrektywa .FI jako odpowiednik .ENDIF<br>
- dodana dyrektywa .IFDEF jako krótszy odpowiednik dyrektyw .IF .DEF<br>
- dodana dyrektywa .IFNDEF jako krótszy odpowiednik dyrektyw .IF .NOT .DEF<br>
- umo¿liwione zosta³o definiowanie makr w obszarze procedury .PROC, podsumowuj±c aktualnie dopuszczalne jest zdefiniowanie makra w obszarze .LOCAL i .PROC<br>
- wyst±pienie jakiegokolwiek ostrze¿enia podczas asemblacji nie zmieni kodu wyj¶cia (exit_code=0), zmiana podyktowana potrzeb± kompatybilno¶ci z linuxowym makefile<br>
- ujednolicony sposób deklaracji etykiet lokalnych i globalnych, "bia³e znaki" przed nazw± etykiety nie wymusz± zdefiniowania takiej etykiety jako globalnej, umo¿liwi to tylko dyrektywa .DEF :LABEL<br>
- poprawione makra @CALL.MAC i @CALL_2.MAC, zmienna tymczasowa globalna ?@stack_offset modyfikowana jest teraz przez dyrektywê .DEF<br>
- rezygnacja z opcji -E (Eat White spaces), aktualnie jest ta opcja zawsze w³±czona<br>
- poprawione wy¶wietlanie numeru linii z b³êdem w aktualnie wykonywanym makrze<br>
- skrócone nazwy etykiet tworzonych podczas wykonywania makr (³atwiejsza ich identyfikacja w pliku *.LAB)<br>
- poprawione dzia³anie opcji OPT H-<br>
- dodane nowe makro rozkazy INL (increse LONG), IND (increse DWORD), DEL (decrese LONG), DED (decrese DWORD)<br>
- dodane nowe makro rozkazy CPB (compare BYTE), CPW (compare WORD), CPL (compare LONG), CPD (compare DWORD)<br>
- usprawnione i rozszerzone dzia³anie dyrektyw #TEST i #WHILE w oparciu o kod generowany przez makro rozkazy CPB, CPW, CPL, CPD, dyrektywy #TEST i #WHILE dla wyra¿eñ '=#0' i '<>#0' generuj± najkrótszy kod wynikowy<br>
- dodana optymalizacja d³ugo¶ci generowanego kodu dla makro rozkazów MWA, MWX, MWY<br>
- dodana nowa opcja OPT R optymalizuj±ca kod makro rozkazów MWA, MWX, MWY, MVA, MVX, MVY ze wzglêdu na zawarto¶æ rejestrów, np.:
<pre>
                    opt r-        opt r+
    mva #0 $80  ->  lda #$00  ->  lda #0 
    mva #0 $81  ->  sta $80   ->  sta $80
                    lda #$00  ->  sta $81
                    sta $81   ->
</pre>
<p class="tekst">
- rozszerzona funkcjonalno¶æ dyrektywy .DEF o mo¿liwo¶æ przypisania warto¶ci nowo deklarowanej etykiecie, np.:
<pre>
 .def label = 1
</pre>
<p class="tekst">
- rozszerzona funkcjonalno¶æ dyrektywy .DEF o mo¿liwo¶æ zdefiniowania etykiety globalnej niezale¿nie od aktulnego obszaru lokalnego, np.:
<pre>
 .def :label
</pre>
<p class="tekst">
- umo¿liwiona zosta³a addytywno¶æ obszarów .LOCAL, tzn. mo¿e istnieæ wiele obszarów lokalnych o tej samej nazwie, symbole zawarte w takich obszarach nale¿eæ bêd± do wspólnej przestrzeni nazw, np.:
<pre>
.local namespace

 .proc proc1
 .endp

.endl

.local namespace

 .proc proc2
 .endp

.endl
</pre>


<p class="tekst-wiekszy">
1.7.8
<p class="tekst">
- dodane dyrektywy .MEND, .PGEND, .REND jako odpowiedniki .ENDM, .ENDPG, .ENDR<br>
- obecnie deklaracja makra musi koñczyæ siê dyrektyw± .ENDM lub .MEND (poprzednio dopuszczalne by³o u¿ycie dyrektywy .END)<br>
- poprawiony sposób wykonywania makr dziêki czemu umo¿liwione zosta³o wykonanie dyrektywy .ENDL z poziomu  wykonywanego makra<br>
- poprawione zauwa¿one b³êdy dotycz±ce starszych bajtów relokowanego adresu oraz bloku aktualizacji symboli publicznych<br>
- dodana nowa dyrektywa .USING (.USE) pozwalaj±ca okre¶liæ ¶cie¿kê poszukiwañ dla nazw etykiet<br>
- poprawione dzia³anie dyrektyw .LOCAL, .DEF, których b³êdne dzia³anie objawia³o siê w szczególnych przypadkach<br>
- poprawione dzia³anie makro rozkazów skoków (SNE, RNE itp.), których b³êdne dzia³anie objawia³o siê w szczególnych przypadkach<br>
- rozszerzona sk³adnia dyrektywy .TEST (kod 6502 dla warunku) o dowoln± ilo¶æ wyra¿eñ po³±czonych przez .OR lub .AND (brak mo¿liwo¶ci zmiany piorytetu warto¶ciowania przy pomocy nawiasów), np.:
<pre>
 .test .byte k>#10+1 .or .word j>#100 .and .word j<#105 .or .byte k<=#5
 ...
 ...
 .endt
</pre>

<p class="tekst">
- rozszerzona sk³adnia dyrektywy .WHILE (kod 6502 dla pêtli) o dowoln± ilo¶æ wyra¿eñ po³±czonych przez .OR lub .AND (brak mo¿liwo¶ci zmiany piorytetu warto¶ciowania przy pomocy nawiasów), np.:
<pre>
 .while .byte k>#4 .and .byte k<#39
 ...
 ...
 .endw
</pre>


<p class="tekst-wiekszy">
1.7.6 - 1.7.7
<p class="tekst">
- dodany nowy prze³±cznik -B:ADDRESS umo¿liwiaj±cy asemblacje od zadanego adresu<br>
- dodany nowa opcja OPT F+- pozwalaj±ca tworzyæ bloki ci±g³ej pamiêci (przydatne dla cartów)<br>
- dodana obs³uga parametrów typu .LONG i .DWORD przekazywanych do procedur .PROC typu .VAR (poprzednio akceptowanymi typami parametrów by³ tylko .BYTE i .WORD)<br>
- dodana nowa dyrektywa .FL realizuj±ca zapis liczb rzeczywistych REAL w formacie FP Atari, np.:
<pre>
pi .fl 3.1415926535897932384626433832795  ; 40 03 14 15 92 65
tb .fl 0.5 12.34 -2.30 0.00002
tb .fl 0.5, 12.34, -2.30, 0.00002
</pre>
<p class="tekst">
- umo¿liwiony zosta³ zapis warto¶ci innych typów ni¿ tylko .BYTE w bloku .ARRAY<br>
- dodana obs³uga typów wielokrotnych dla .STRUCT, poprzednio takie typy by³y akceptowane jednak pamiêæ nie by³a w³a¶ciwie dla nich rezerwowana, np.:
<pre>
  .struct test
   x :200 .byte
   y :999 .long
  .ends

buf dta test [0]
</pre>
<p class="tekst">
- poprawione b³êdy dotycz±ce generowania kodu relokowalnego zauwa¿one przez Laoo, np.:
<pre>
  .reloc

   lda temp
temp .long $aabbcc
</pre>
<p class="tekst">
- b³±d 'Addres relocation overload' wyst±pi teraz tylko gdy wyra¿enie bêdzie dotyczyæ wiêcej ni¿ jednej etykiety relokowalnej, poprzednio ka¿de wyra¿enie z udzia³em etykiety relokowalnej powodowa³o wy¶wietlenie tego komunikatu b³êdu<br>
- blok aktualizacji symboli plublicznych rozszerzony zosta³ o mo¿liwo¶æ przekazywania sta³ych ró¿nych typów B-YTE, W-ORD, L-ONG, D-WORD, poprzednio przekazywanym typem by³ tylko W-ORD<br>
- zmienione dzia³anie dyrektywy .VAR w blokach .LOCAL znajduj±cych siê w bloku .PROC, zmienne takie zawsze odk³adane s± na koñcu bloku przed dyrektyw± .ENDP, w pozosta³ych przypadkach na koñcu bloku .LOCAL przed dyrektyw± .ENDL<br>
- umo¿liwiona zosta³a relokowalno¶æ kodu generowanego przez dyrektywy .WHILE i .TEST<br>
- poprawione dzia³anie testowania warto¶ci typu .WORD w kodzie generowanym przez dyrektywy .WHILE i .TEST<br>
- dodana nowa dyrektywa .ADR zwracaj±ca adres etykiety przed zmian± adresu asemblacji<br>
- dodana nowa dyrektywa .LEN zwracaj±ca d³ugo¶æ bloków zdefiniowanych przez .PROC i .ARRAY<br>
- poprawione dzia³anie operacji dzielenia, mno¿enia i modulo, poprzednio b³êdnie by³ interpretowany piorytet dla tych operacji<br>
- komentarze z koñca linii nie poprzedzone znakiem komentarza bêd± powodowaæ wyst±pienie b³êdu 'Unexpected end of line'<br>
- dodana mo¿liwo¶æ przypisania zmiennej pól zdefiniowanych przez strukture, np.:
<pre>
@point .struct
       x .byte
       y .byte
       .ends

a @point
b @point
c @point
</pre>
<p class="tekst">
- rozszerzona sk³adnia .STRUCT o mo¿liwo¶æ dodania nowych pól bez definiowania nazwy pola, np.:
<pre>
 .struct @id
  id .word
 .ends

 .struct @mem
  @id
  adr .word
 .ends
</pre>
<p class="tekst">
- rozszerzona sk³adnia makro rozkazu MWA o mo¿liwo¶æ u¿ycia adresowania po¶redniego strony zerowej  postindeksowanego Y, np.:
<pre>
  mwa ($80),y $a000,x
  mwa $bc40,y ($f0),y
  mwa ($80),y ($82),y
</pre>
<p class="tekst">
- rozszerzona sk³adnia dyrektywy .EXTRN, obecnie mo¿liwe jest zapowiedzenie wiêkszej ilo¶ci etykiet ró¿nych typów w jednym wierszu, zapowiedzenie procedury .PROC w takim wierszu musi znajdowaæ siê na jego koñcu, np.:
<pre>
  .extrn a,b,c,d .byte  x y z .word  line .proc(.byte x,y) .reg
</pre>
<p class="tekst">
- rozszerzona sk³adnia dyrektywy .VAR, obecnie mo¿liwe jest zadeklarowanie wiêkszej ilo¶ci etykiet ró¿nych typów w jednym wierszu oraz przypisanie im adresu od którego zostan± od³o¿one w pamiêci, np.:
<pre>
  .var x y z .byte bit :2 .dword = $80
</pre>
<p class="tekst">
- rozszerzona sk³adnia dla parametrów procedur przekazywanych przez zmienne .VAR, mo¿liwe jest podanie przesuniêcia np.:
<pre>
move .proc (.word src+1,dst+1) .var

src lda $ffff
dst sta $ffff

     .endp
</pre>
<p class="tekst">
- dodana nowa dyrektywa .NOWARN wy³±czaj±ca wy¶wietlenie ostrze¿enia dla aktualnie asemblowanego wiersza, np.:
<pre>
 .nowarn PROCNAME
</pre>
<p class="tekst">
- dodane nowe makro rozkazy PHR, PLR, realizuj±ce odk³adanie i zdejmowanie warto¶ci rejestrów z udzia³em stosu sprzêtowego, np.:
<pre>
  PHR -> PHA         PLR -> PLA
         TXA                TAY
         PHA                PLA
         TYA                TAX
         PHA                PLA
</pre>
<p class="tekst">
- dodane nowe makro rozkazy ADB, SBB realizuj±ce dodawanie i odejmowanie warto¶ci typu .BYTE, np.:
<pre>
 ADB $80 #12 $b000  ->  lda $80
                        clc
                        adc #12
                        sta $b000

 SBB #200 $a000     ->  lda #200
                        sec
                        sbc $a000
                        sta $a000
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ u¿ycia sk³adni C dla liczb szestnastkowych, np.:
<pre>
 lda 0x2000
 ldx #0x12

temp = 0x8000
</pre>


<p class="tekst-wiekszy">
1.7.5
<p class="tekst">
- dyrektywa .DS w blokach relokowalnych SDX RELOC i MADS RELOC deklaruje od teraz pusty blok<br>
- dodany nowy prze³±cznik -F, który umo¿liwia umieszczanie rozkazów CPU i pseudo rozkazów od pierwszej kolumny w wierszu<br>
- przepisane od nowa procedury odczytu bloków .MACRO, .REPT oraz procedura realizuj±ca dzielenie wiersza przy pomocy znaku '\'<br>
- dodane nowe pseudo rozkazy ADW, SBW realizuj±ce dodawanie i odejmowanie warto¶ci typu WORD dla CPU6502, np.:
<pre>
  adw hlp #40        ; hlp=hlp+40
  adw hlp #20 pom    ; pom=hlp+20
</pre>
<p class="tekst">
- rozszerzone dzia³anie dyrektywy .DEF o mo¿liwo¶æ zdefiniowania etykiety, np.: .DEF label<br>
- zwiêkszona liczba przebiegów dla deklaracji etykiet przez EQU dla pewnych szczególnych przypadków<br>


<p class="tekst-wiekszy">
1.7.4
<p class="tekst">
- naprawione dzia³anie dyrektywy .PRINT, dot±d mog³a nie wy¶wietliæ warto¶ci etykiet zaczynaj±cej siê na literê 'A','B','C','D','E','F','G','H','L','T','V'<br>
- zablokowane dzia³anie dyrektywy .DS w blokach .RELOC i SDX oraz naprawione jej dzia³anie z instrukcj± warunkow± .IF (IFT)<br>
- usprawnione przeszukiwanie ¶cie¿ek dostêpu -i:path (mo¿na odwo³ywaæ siê do podkatalogów tam zawartych)<br>
- w przypadku wyst±pienia b³êdów podczas asemblacji wy¶wietlane s± one wszystkie a nie tylko pierwszy z b³êdów<br>
- poprawione zauwa¿one b³êdy, m.in. u¿ycie makra w pliku .RELOC mog³o spowodowaæ w pewnych sytuacjach zapis b³êdnej informacji o relokownych adresach<br>
- uproszczony zosta³ sposób koñczenia procedur wykorzystuj±cych stos programowy MADS-a, nie ma potrzeby u¿ywania dyrektywy .EXIT, a dyrektywa .ENDP nie powoduje ju¿ dodatkowych dzia³añ na stosie programowym<br>
- dodana nowa dyrektywa .SYMBOL jako odpowiednik bloku aktualizacji BLK UPDATE NEW SYMBOL 'SYMBOL', dyrektywê .SYMBOL mo¿na u¿yæ w dowolnym miejscu programu<br>
- dodane automatyczne wywo³ywanie bloków aktualizacji (ADDRESS, EXTERNAL, PUBLIC, SYMBOL) dla .RELOC i SDX<br>
- dodane nowe dyrektywy .BY, .WO, .HE, .EN, .SB (zapo¿yczone z MAE)<br>
- dodany nowy prze³±cznik OPT ?- (domy¶lnie) etykiety ze znakiem zapytania (?labels) traktowane s± jako etykiety tymczasowe, OPT ?+ etykiety ze znakiem zapytania (?labels) traktowane s± jako lokalne i tymczasowe, nazw± obszaru lokalnego jest ostatnio u¿yta etykieta bez znaku zapytania<br>
- dodane dyrektywy .LEND, .PEND, .AEND, .WEND, .TEND, .SEND jako odpowiedniki dyrektyw .ENDL, .ENDP, .ENDW, ENDW, .ENDT, .ENDS<br>
- dodane nowe dyrektywy .GLOBAL i .GLOBL jako odpowiednik (zamiennik) dyrektywy .PUBLIC<br>
- dodana optymalizacja skoków warunkowych JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS, je¶li jest taka mo¿liwo¶æ wybierany jest skok krótki typu BEQ, BNE, BPL, BMI, BCC, BCS, BVC, BVS<br>
- dodany nowy domy¶lny separator znak spacji dla przekazywanych parametrów do .PROC, .MACRO, dot±d by³ to tylko znak przecinka<br>
- usprawnienia dotycz±ce przekazywania parametrów do makr i procedur, np. paramatrem makra mo¿e byæ dyrektywa zwracaj±ca warto¶æ wyra¿enia lub symbol licznika pêtli '#'
<pre>
  :12 makro #
</pre><p class="tekst">
- dodana mo¿liwo¶æ u¿ycia znaku spacji jako separatora dla .VAR, .EXTRN, np.
<pre>
  .EXTRN a b c d .word
  .VAR i = 1  j = 2 .byte
  .VAR a b c d .byte
</pre><p class="tekst">
- rozszerzona sk³adnia dla .VAR umo¿liwiaj±ca zaincjowanie zmiennych sta³±, np.:
<pre>
 .var i = 10  j = 12 .byte
 .var a , b = 2 .byte
</pre><p class="tekst">
- dodane nowe dyrektywy .WHILE, .ENDW pozwalaj±ce na automatyczne wygenerowanie kodu dla pêtli WHILE, np.:
<pre>
         ldx #$ff
 .while .word adr < #$bc40+40*24
         stx $bc40
    adr: equ *-2
         inw adr
 .endw
</pre><p class="tekst">
- dodane nowe dyrektywy .TEST, .ENDT pozwalaj±ce na automatyczne wygenerowanie kodu dla warunku, np.:
<pre>
 .test .byte (@>=#'a')
  .test .byte (@<=#'z')
      
  .endt
 .endt
</pre>
 

<p class="tekst-wiekszy">
1.7.3
<p class="tekst">
- dodana mo¿liwo¶æ zmiany adresu asemblacji .PROC lub .LOCAL bez zmiany adresu ³adowania<br>
- usuniêto optymalizacjê kodu dla makro rozkazów MWA itp., która mog³a powodowaæ w szczególnych przypadkach zapêtlenie siê MADS-a<br>
- dodane dyrektywy .REG, .VAR pozwalaj±ce okre¶liæ sposób przekazywania parametrów do procedur (.REG przez rejestry CPU, .VAR przez zmienne)<br>
- dodana dyrektywa .VAR pozwalaj±ca na deklaracjê zmiennych w blokach .PROC, .LOCAL, zadeklarowane zmiennne s± fizycznie odk³adane na koñcu takiego bloku<br>
- rozszerzona sk³adnia dla dyrektywy .EXTRN, np. EXTRN label1,label2,label3... TYPE<br>
- jesli brak deklaracji etykiet dla stosu programowego MADS-a, przyjmowane s± domy¶lne warto¶ci @PROC_VARS_ADR=$0500, @STACK_ADDRESS=$0600, @STACK_POINTER=$FE<br>
- dodany repeat_counter #, który mo¿na u¿ywaæ zamiennie z dyrektyw± .R<br>
- wystapi b³±d '^ not relocatable' przy próbie relokacji rozkazu 'lda ^label'<br>
- dodana obs³uga symboli publicznych dla sta³ych (C-ONSTANT) w blokach PUBLIC<br>
- poprawiona relokowalnosc dla tablic .ARRAY, danych stworzonych przez .STRUCT, parametrów przekazywanych do procedur przez sta³a #
</p>


<p class="tekst-wiekszy">
v1.7.2
<p class="tekst">
- przepisana na nowo obs³uga pseudo rozkazów REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS, SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS<br>
- poprawione dzia³anie dyrektywy .LINK dla bloków o sta³ych adresach<br>
- poprawione testowanie s³ów zarezerwowanych (mo¿na u¿ywaæ nazw zarezerwowanych dla 65816 gdy u¿ywamy tylko 6502)<br>
- zmiany w listingu, wy¶wietla informacje o numerze banku tylko gdy bank &gt 0<br>
- dodana obs³uga makro rozkazów MWA, MWX, MWY, MVA, MVX, MVY, ADD, SUB, INW, DEW (do ich obs³ugi nie s± ju¿ potrzebne makra)
</p>


<p class="tekst-wiekszy">
v1.7.1
<p class="tekst">
- dodana mo¿liwo¶æ u¿ywania nazw mnemoników 65816 w trybie pracy 6502, w trybie 65816 wyst±pi ju¿ b³±d <b>Reserved word</b><br>
- poprawione dzia³anie pseudo rozkazów skoków SCC, RNE itp. w makrach<br>
- usprawnione wykonywanie wielu makr rozdzielonych znakiem dwukropka ':'
</p>


<p class="tekst-wiekszy">
v1.7.0
<p class="tekst">
- usuniêty b³±d, który powodowa³ zbyt ma³a liczbê przebiegów asemblacji<br>
- dodana obs³uga pseudo rozkazów JEQ, JNE, JPL, JMI, JCC, JCS, JVC, JVS (makra nie s± ju¿ potrzebne do ich obs³ugi)
</p>


<p class="tekst-wiekszy">
v1.6.9
<p class="tekst">
- rozszerzona sk³adnia dla .ARRAY, .PUT<br>
- dodany pseudo rozkaz EXT pozwalaj±cy na deklaracje etykiety external<br>
- dodane makra JEQ, JNE, JPL, JMI, JCC, JCS<br>
- dodane dyrektywy .PAGES i .ENDPG<br>
- dodana dyrektywa .END zastepujaca inne dyrektywy .END?<br>
- prze³±cznik -H zast±piony zosta³ przez -HC (generuje plik nag³ówkowy dla CC65)<br>
- dodany nowy prze³±cznik -HM generuj±cy plik nag³ówkowy dla MADS-a z sortowaniem na etykiety typu CONSTANTS, VARIABLES, PROCEDURES<br>
- dodana nowa dyrektywa .RELOC generuj±ca kod relokowalny w formacie MADS-a
</p>


<p class="tekst-wiekszy">
v1.6.8
<p class="tekst">
- dodana nowa dyrektywa .PUT oraz rozszerzona sk³adnia dla dyrektywy .GET (../EXAMPLES/MSX/MPT_PLAYER/MPT_RELOCATOR.MAC , ../EXAMPLES/MSX/TMC_PLAYER/TMC_RELOCATOR.MAC)<br>
- dodana obs³uga pseudo rozkazów XASM-a REQ, RNE, RPL, RMI, RCC, RCS, RVC, RVS, SEQ, SNE, SPL, SMI, SCC, SCS, SVC, SVS<br>
- dodana mo¿liwo¶æ ³±czenia dowolnej liczby znanych MADS-owi mnemoników przy pomocy znaku ':' (styl XASM-a), np.: 
<pre>
  lda:cmp:req 20
  ldx:ldy:lda:iny label
</pre>

<p class="tekst-wiekszy">
v1.6.6 - 1.6.7
<p class="tekst">
- ¼ród³o MADS-a kompatybilne z Free Pascal Compiler, po kompilacji mo¿liwe jest jego u¿ywanie na innych platformach systemowych, jak np. Linux, Mac OS, OS/2 itp.<br>
- od teraz MADS sam dobiera odpowiedni± liczbê przebiegów asemblacji, prze³±cznik '/3' nie jest ju¿ potrzebny<br>
- poprawiony i rozbudowany zosta³ mechanizm przekazywania parametrów do MADS-a (rozdzia³ 'Prze³±czniki assemblera')<br>
- poprawione zosta³o wywo³anie makra w linii rozdzielanej znakiem '\' oraz usprawnione rozpoznawanie i wykonywanie linii rozdzielanych znakami '\'<br>
- poprawiony b³±d, w którym MADS myli³ dyrektywê .ENDM z pseudorozkazem IFT<br>
- poprawione dzia³anie instrukcji warunkowych .ELSEIF, .ELSE<br>
- poprawione testowanie poprawno¶ci instrukcji warunkowych w makrach<br>
- obs³uga procedur .PROC zosta³a rozbudowana o nowe makra i mechanizmy, dziêki którym podobna jest w dzia³aniu jak i ³atwo¶ci u¿ycia do procedur z jêzyków wy¿szego poziomu<br>
- dla procedur .PROC z zadeklarowanymi parametrami potrzebna jest teraz dodatkowa deklaracja @PROC_VARS_ADR<br>
- brak ograniczeñ w liczbie parametrów przekazywanych do procedur, jedynym ograniczeniem jest dostêpna pamiêæ<br>
- dodany nowy prze³±cznik /d:label=value pozwalaj±cy zdefiniowaæ now± etykietê MADS-a z poziomu linii poleceñ<br>
- dodany nowy prze³±cznik /x "Exclude unreferenced procedures" pozwalaj±cy pomin±æ podczas asemblacji nie u¿ywane w programie procedury zadeklarowane dyrektyw± .PROC<br>
- nowa opcja OPT T+ (track sep, rep) ¶ledz±ca zmiany rozmiaru rejestrów A,X,Y dokonywane przez rozkazy SEP, REP (CPU 65816)<br>
- nowe biblioteki w katalogu ..\EXAMPLES\LIBRARIES<br>
- w deklaracji obszaru lokalnego .LOCAL nie jest wymagane podanie nazwy obszaru<br>
- nowe operatory '-=', '+=', '++', '--' pozwalaj±ce zmniejszyæ/zwiêkszyæ warto¶æ etykiety tymczasowej, np.:
<pre>
  ?label --      ->   ?label=?label-1
  ?lab ++        ->   ?lab=?lab+1
  ?temp += 3     ->   ?temp=?temp+3
  ?ofset -= 5    ->   ?ofset=?ofset-5
</pre>
<p class="tekst">
- rozszerzona o znak przecinka sk³adnia deklaracji parametrów procedur, np.:
<pre>
 .proc nazwa (.byte a,b,c .word d,e)
 .endp
</pre>

</html>