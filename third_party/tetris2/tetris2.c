/* Simple Tetris in the terminal, adapted for CP/M-65, */
/* generated by using p2c with tetris.pas for CP/M 2.2 Apple ][ */
/* A.Baumann, 14.12.2024, 0BSD clause */

#include <cpm.h>
#include <ctype.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "lib/screen.h"

#define Delay           200
#define BoardHeight     20
#define BoardWidth      10
#define NofShapes       7

static uint8_t Shapes[NofShapes][4][4] = {
  /* I */
  { { 0, 0, 0, 0 },
    { 1, 1, 1, 1 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* O */
  { { 0, 1, 1, 0 },
    { 0, 1, 1, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* T */
  { { 0, 1, 0, 0 },
    { 1, 1, 1, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* J */
  { { 1, 0, 0, 0 },
    { 1, 1, 1, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* L */
  { { 0, 0, 1, 0 },
    { 1, 1, 1, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* S */
  { { 0, 1, 1, 0 },
    { 1, 1, 0, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } },
  /* Z */
  { { 1, 1, 0, 0 },
    { 0, 1, 1, 0 },
    { 0, 0, 0, 0 },
    { 0, 0, 0, 0 } }
};
static uint8_t ShapeChars[NofShapes] = {'I', 'O', 'T', 'J', 'L', 'S', 'Z' };

uint8_t Board[BoardHeight][BoardWidth];
bool GameOver;
uint8_t CurrentPiece, NextPiece;
int8_t PosX, PosY;

static void InitializeBoard(void)
{
  memset(Board, 0xFF, sizeof(Board));
}

static void DrawBoard(void)
{
  uint8_t x, y;

  for (y = 1; y <= BoardHeight; y++) {
    for (x = 1; x <= BoardWidth; x++) {
      screen_setcursor(x,y);
      if (Board[y-1][x-1] != 0xFF) {
	screen_setstyle(1);
        screen_putchar(ShapeChars[Board[y-1][x-1]]);
      } else {
        screen_setstyle(0);
        screen_putchar('.');
      }
    }
  }
  screen_setstyle(0);
}


static void DrawPiece(uint8_t piece, int8_t x, int8_t y,bool Erase)
{
  uint8_t nx, ny;

  screen_setstyle(!Erase);
  for (ny = 0; ny <= 3; ny++) {
    for (nx = 0; nx <= 3; nx++) {
      if (Shapes[piece][ny][nx] == 1) {
        screen_setcursor(x + nx, y + ny);
        if (Erase)
          screen_putchar('.');
        else
          screen_putchar(ShapeChars[piece]);
      }
    }
  }
  screen_setstyle(0);
}

static bool CanMove(int8_t dx, int8_t dy)
{
  int8_t x, y;

  for (y = 0; y <= 3; y++) {
    for (x = 0; x <= 3; x++) {
      if (Shapes[CurrentPiece][y][x] == 1) {
        if (PosX + x + dx < 1 || PosX + x + dx > BoardWidth ||
            PosY + y + dy > BoardHeight ||
            Board[PosY + y + dy - 1][PosX + x + dx - 1] != 0xFF)
          return false;
      }
    }
  }
  return true;
}

static void DrawNextPiece(void)
{
  int8_t x, y;

  for (y = 10; y <= 13; y++) {
    for (x = 12; x <= 15; x++) {
      screen_setcursor(x, y);
      screen_putchar('.');
    }
  }
  DrawPiece(NextPiece, 12, 10, false);  
}

static void NewPiece(void)
{
  CurrentPiece = NextPiece;
  NextPiece = (uint8_t)rand() % NofShapes;
  DrawNextPiece();
  PosX = BoardWidth / 2 - 2;
  PosY = 1;
  if (!CanMove(0, 0))
    GameOver = true;
}

static void RotatePiece(void)
{
  uint8_t Temp[4][4];
  uint8_t Save[4][4];
  uint8_t x, y;

  for (y = 0; y <= 3; y++)
    for (x = 0; x <= 3; x++)
      Save[y][x] = Shapes[CurrentPiece][y][x];
  for (y = 0; y <= 3; y++)
    for (x = 0; x <= 3; x++)
      Temp[y][x] = Shapes[CurrentPiece][3 - x][y];
  for (y = 0; y <= 3; y++)
    for (x = 0; x <= 3; x++)
      Shapes[CurrentPiece][y][x] = Temp[y][x];
  if (!CanMove(0, 0))
    for (y = 0; y <= 3; y++)
      for (x = 0; x <= 3; x++)
        Shapes[CurrentPiece][y][x] = Save[y][x];
}

static void PlacePiece(void)
{
  uint8_t x, y;

  for (y = 0; y <= 3; y++) {
    for (x = 0; x <= 3; x++) {
      if (Shapes[CurrentPiece][y][x] == 1)
        Board[PosY + y - 1][PosX + x - 1] = CurrentPiece;
    }
  }
}

static bool ClearLines(void)
{
  uint8_t x, y, ny;
  bool Full;
  bool Redraw = false;

  for (y = 1; y <= BoardHeight; y++) {
    Full = true;
    for (x = 0; x < BoardWidth; x++) {
      if (Board[y-1][x] == 0xFF)
        Full = false;
    }
    if (Full) {
      for (ny = y; ny >= 2; ny--) {
        for (x = 0; x < BoardWidth; x++)
          Board[ny-1][x] = Board[ny-2][x];
      }
      for (x = 0; x < BoardWidth; x++)
        Board[0][x] = 0xFF;
      Redraw = true;
    }
  }
  return Redraw;
}

static void HandleInput(void)
{
  uint8_t c;

  c = screen_getchar(Delay);
  if (c > 0) {
    switch (c) {
    case 'A': case 'a': case SCREEN_KEY_LEFT:
      if (CanMove(-1, 0)) {
        DrawPiece(CurrentPiece, PosX, PosY, true);
        PosX--;
        DrawPiece(CurrentPiece, PosX, PosY, false);
      }
      break;

    case 'D': case 'd': case SCREEN_KEY_RIGHT:
      if (CanMove(1, 0)) {
        DrawPiece(CurrentPiece, PosX, PosY, true);
        PosX++;
        DrawPiece(CurrentPiece, PosX, PosY, false);
      }
      break;

    case 'S': case 's': case SCREEN_KEY_DOWN:
      if (CanMove(0, 1)) {
        DrawPiece(CurrentPiece, PosX, PosY, true);
        PosY++;
        DrawPiece(CurrentPiece, PosX, PosY, false);
      }
      break;

    case ' ':
      while (CanMove(0, 1)) {
        DrawPiece(CurrentPiece, PosX, PosY, true);
        PosY++;
        DrawPiece(CurrentPiece, PosX, PosY, false);
      }
      break;

    case 'W': case 'w': case SCREEN_KEY_UP:
      DrawPiece(CurrentPiece, PosX, PosY, true);
      RotatePiece();
      DrawPiece(CurrentPiece, PosX, PosY, false);
      break;

    case 'P': case 'p':
      screen_setcursor(12,7);
      cpm_printstring("Game paused.");
      screen_setcursor(12,8);
      cpm_printstring("Press any key to continue.");
      screen_waitchar();
      screen_clear();
      DrawBoard();
      DrawNextPiece();
      break;

    case 'Q': case 'q':
      GameOver = true;
      break;
    }
  }
}

int main(void)
{
  if(!screen_init()) {
    cpm_printstring("No SCREEN driver, exiting\n\r");
    cpm_warmboot();
  }
  screen_clear();
  screen_showcursor(0);

  srand( 21342 );
  InitializeBoard();
  DrawBoard();
  GameOver = false;
  NextPiece = (uint8_t)rand() % NofShapes;
  NewPiece();
  while (!GameOver) {
    DrawPiece(CurrentPiece, PosX, PosY, false);
    HandleInput();
    if (CanMove(0, 1)) {
      DrawPiece(CurrentPiece, PosX, PosY, true);
      PosY++;
      DrawPiece(CurrentPiece, PosX, PosY, false);
    } else {
      PlacePiece();
      while (ClearLines()) {
        DrawBoard();
      }
      NewPiece();
    }
    if (PosY >= BoardHeight)
      GameOver = true;
  }
  screen_clear();
  printf("Thanks for playing.\n");
  screen_showcursor(1);

  cpm_warmboot();
}
