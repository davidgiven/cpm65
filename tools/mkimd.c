/* mkimd - Generates an 8'', SSDD IMD disk file image for the KIM-1 + K-1013 FDC
 *         from a raw CP/M one. The raw input image must be generated with this
 *         parameters: 77 tracks, 26 sect/track, 256 bytes/sect, no skew.
 * 
 * IMD format reference: https://oldcomputers-ddns.org/public/pub/manuals/imd.pdf
 *
 * Copyright Â© 2024 Eduardo Casino
 * This file is licensed under the terms of the 2-clause BSD license. Please
 * see the COPYING file in the root project directory for the full text.
 */ 

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <errno.h>

#define HEADS   1
#define CYLS    77
#define SECTS   26
#define CSIZE   1           // Code for 256 bytes/sector
#define NSIZE   256         // Sector size in bytes
#define MODE    3           // Code for 500 kbps MFM 

#define NORMAL_DATA     1
#define COMPRESSED_DATA 2

// Sector skew between tracks
#define SKEW    8

typedef struct {
    uint8_t mode;
    uint8_t cyl;
    uint8_t head;
    uint8_t sects;
    uint8_t csize;
    uint8_t smap[SECTS];
} track_info_t;

// Sector interleave table
uint8_t sector_map[SECTS] = {
                0, 13, 1, 14, 2, 15, 3, 16, 4, 17, 5, 18, 6,
                19, 7, 20, 8, 21, 9, 22, 10, 23, 11, 24, 12, 25
        };

#define TMBUF_LEN   32
char time_buf[TMBUF_LEN];

const char header_fmt[] = "IMD 1.18: %s\r\nGenerated by CP/M-65 mkimd\x1a";
const char time_fmt[] = "%d/%m/%y %H:%M:%S";

char *input_filename, *output_filename;

uint8_t sect_buffer[NSIZE + 1];     // Sector size + 1 byte for sector data type

static bool same_byte( uint8_t *buffer, int size )
{
    int i = 0;

    for ( i = 1; i < size; ++i )
    {
        if ( buffer[i] != buffer[i-1] )
        {
            break;
        }
    }

    return ( i == size );
}

static void write_header( FILE *fd )
{
    time_t now;

    time( &now );
    strftime( time_buf, TMBUF_LEN, time_fmt, localtime( &now) );

    fprintf( fd, header_fmt, time_buf );
}

static void write_image( void )
{
    FILE *ifp, *ofp;
    size_t fsize;

    ifp = fopen( input_filename, "r" );
    if ( ifp == NULL )
    {
        fprintf( stderr, "cannot open input file: %s\n", strerror(errno) );
        exit( 1 );
    }

    fseek( ifp, 0L, SEEK_END );
    fsize = ftell( ifp );

    ofp = fopen( output_filename, "w+" );
    if ( ofp == NULL )
    {
        fprintf( stderr, "cannot open output file: %s\n", strerror(errno) );
        exit( 1 );
    }

    write_header( ofp );

    // Initialize immutable track values

    track_info_t trinfo;
    trinfo.mode = MODE;
    trinfo.sects = SECTS;
    trinfo.csize = CSIZE;

    // Initialize skew factor

    uint8_t skew = 0;

    for ( int cyl = 0; cyl < CYLS; ++cyl, skew += SKEW )
    {
        trinfo.cyl = cyl;
        trinfo.head = 0;

        // Populate sector map

        for ( int s = 0; s < SECTS; ++ s )
        {
            trinfo.smap[s] = sector_map[(s+skew)%SECTS];
        }

        // Write track info

        fwrite( &trinfo, sizeof( trinfo ), 1, ofp );

        // Copy sectors

        for ( int s = 0; s < SECTS; ++s )
        {
            // Search for sector

            size_t off = ( cyl * SECTS + trinfo.smap[s] ) * NSIZE;

            if ( off < fsize)
            {
                // Read sector

                fseek( ifp, off, SEEK_SET );
                fread( &sect_buffer[1], NSIZE, 1, ifp );

                // Check if all the sector bytes are the same

                if ( same_byte( &sect_buffer[1], NSIZE ))
                {
                    sect_buffer[0] = COMPRESSED_DATA;
                    fwrite( sect_buffer, 2, 1, ofp );       // Write compressed sector
                }
                else
                {
                    sect_buffer[0] = NORMAL_DATA;
                    fwrite( sect_buffer, NSIZE+1, 1, ofp ); // Write normal sector
                }
            }
            else
            {
                // End of file, this sector is unused

                sect_buffer[0] = COMPRESSED_DATA;
                sect_buffer[1] = 0xE5;                      // Filler byte
                fwrite( sect_buffer, 2, 1, ofp );           // Write compressed sector
            }
        }
        // Calculate new sector skew

        skew += ( SECTS - SKEW ) % SECTS;
    }

    fclose( ifp );
    fclose( ofp );
}

int main( int argc, char* const argv[] )
{
    for (;;)
    {
        switch ( getopt( argc, argv, "i:o:" ) )
        {
            case -1:
                write_image();
                return 0;

            case 'i':
                input_filename = optarg;
                break;

            case 'o':
                output_filename = optarg;
                break;
            default:
                fprintf( stderr, "Usage: mkimd -i <rawimage> -o <imdimage>\n" );
                exit( 1 );
        }
    }
}
